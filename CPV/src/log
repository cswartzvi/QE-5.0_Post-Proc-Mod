Only in ../../../ffn2_tsvdw_master/CPV: atoms_type.F90
Only in ../../../ffn2_tsvdw_master/CPV: atoms_type_module.mod
Only in ../../../ffn2_tsvdw_master/CPV: atoms_type.o
diff ./berryion.f90 ../../../ffn2_tsvdw_master/CPV/berryion.f90
23,24c23
<   use kinds,      only : dp
<   use constants,  only : pi
---
>   use constants,  only : pi, fpi
26c25
<   use cell_base,  only : alat, at
---
>   use cell_base,  only : a1, a2, a3
30,32c29,31
<   real(dp) tau0(3,*)
<   real(dp) fion(3,*)
<   real(dp) enbi, evalue
---
>   real(8) tau0(3,*)
>   real(8) fion(3,*)
>   real(8) enbi, evalue
37c36,37
<   real(dp) :: gmes, pola
---
>   real(8) gmes
>   real(8) pola
39,40c39
<   complex(dp) temp, ci
<   real(dp), external:: g_mes
---
>   complex(8) temp, ci
42,43c41,42
<   temp = (0.0_dp,0.0_dp)
<   ci = (0.0_dp,1.0_dp)
---
>   temp = (0.d0,0.d0)
>   ci = (0.d0,1.d0)
45,46c44,56
<   gmes = g_mes ( ipol, at, alat)
<   pola=0.0_dp
---
>   if(ipol.eq.1) then
>      gmes=a1(1)**2+a1(2)**2+a1(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.2) then
>      gmes=a2(1)**2+a2(2)**2+a2(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.3) then
>      gmes=a3(1)**2+a3(2)**2+a3(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   pola=0.d0
72c82
<       use kinds, only : dp
---
> 
76c86
<       real(dp) tau(3,*), cdz(3)
---
>       real(8) tau(3,*), cdz(3)
78c88
<       real(dp) zmas
---
>       real(8) zmas
109c119
< ! this subroutine adds an electric force, in order
---
> ! this subroutine adds a electric force, in order
113d122
<           use kinds,     only : dp
118c127
<           real(dp) fion(3,*)
---
>           real(8) fion(3,*)
123,124c132,133
<           real(dp) fcm!force appplied on center of mass
<           real(dp) tch!total charge
---
>           real(8) fcm!force appplied on center of mass
>           real(8) tch!total charge
Only in ../../../ffn2_tsvdw_master/CPV: berryion.F90
Only in ../../../ffn2_tsvdw_master/CPV: berryion.o
Only in .: berry_phase.f90
Only in ../../../ffn2_tsvdw_master/CPV: betax.mod
diff ./bforceion.f90 ../../../ffn2_tsvdw_master/CPV/bforceion.f90
17c17
< ! at         : input, direct lattice vectors, divided by alat
---
> ! a1,a2,a3   : input, direct lattice vectors
26,27c26,27
<   use uspp_param, only: nvb, ish
<   use kinds, only : dp
---
>   use cvan
>   use parameters
29c29
<   use cell_base, only: at, alat
---
>   use cell_base, only: a1, a2, a3
32,33c32,33
<   use electrons_base, only: nbsp, nbspx, nspin, nbspx_bgrp
<   use mp_global, only: nbgrp
---
>   use electrons_base, only: n => nbsp, nx => nbspx, nspin
>   use cp_main_variables,  only : nlax, descla, collect_bec
38,41c38,41
<   real(dp) evalue
<   complex(dp) qmatinv(nbspx,nbspx),gqq(nhm,nhm,nas,nsp)
<   real(dp) bec0(nhsa,nbspx),becdr(nhsa,nbspx,3)
<   real(dp) fion(3,*)
---
>   real(8) evalue
>   complex(8) qmatinv(nx,nx),gqq(nhm,nhm,nas,nsp)
>   real(8) bec0(nhsa,n),becdr(nhsa,nspin*nlax,3)
>   real(8) fion(3,*)
47,49c47,48
<   complex(dp) ci, temp, temp1,temp2,temp3
<   real(dp) :: gmes
<   real(dp), external :: g_mes
---
>   complex(8) ci, temp, temp1,temp2,temp3
>   real(8) gmes
50a50
>   real(8), allocatable :: becdr_repl(:,:,:)
54,56d53
<   if( nbgrp > 1 ) &
<      call errore(' bforceion ', ' parallelization over bands not yet implemented ', 1 )
< 
58c55,74
<   gmes = g_mes (ipol, at, alat) 
---
>      
>   ALLOCATE( becdr_repl( nhsa,n,3 ) )
>   CALL collect_bec( becdr_repl(:,:,1), becdr(:,:,1), descla, nspin )
>   CALL collect_bec( becdr_repl(:,:,2), becdr(:,:,2), descla, nspin )
>   CALL collect_bec( becdr_repl(:,:,3), becdr(:,:,3), descla, nspin )
> 
>   if(ipol.eq.1) then
>      gmes=a1(1)**2+a1(2)**2+a1(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.2) then
>      gmes=a2(1)**2+a2(2)**2+a2(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.3) then
>      gmes=a3(1)**2+a3(2)**2+a3(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
> 
> 
73,74c89,90
<               do i=1,nbsp
<                  do j=1,nbsp
---
>               do i=1,n
>                  do j=1,n
80c96
<      &  (  becdr(inl,i,1)*bec0(jnl,j)+bec0(inl,i)*becdr(jnl,j,1))*qmatinv(j,i)
---
>      &  (  becdr_repl(inl,i,1)*bec0(jnl,j)+bec0(inl,i)*becdr_repl(jnl,j,1))*qmatinv(j,i)
83c99
<      &  (  becdr(inl,i,2)*bec0(jnl,j)+bec0(inl,i)*becdr(jnl,j,2))*qmatinv(j,i)
---
>      &  (  becdr_repl(inl,i,2)*bec0(jnl,j)+bec0(inl,i)*becdr_repl(jnl,j,2))*qmatinv(j,i)
86c102
<      &  (  becdr(inl,i,3)*bec0(jnl,j)+bec0(inl,i)*becdr(jnl,j,3))*qmatinv(j,i)
---
>      &  (  becdr_repl(inl,i,3)*bec0(jnl,j)+bec0(inl,i)*becdr_repl(jnl,j,3))*qmatinv(j,i)
99a116,117
> 
>   DEALLOCATE( becdr_repl )
Only in ../../../ffn2_tsvdw_master/CPV: bforceion.F90
Only in ../../../ffn2_tsvdw_master/CPV: bforceion.o
Only in ../../../ffn2_tsvdw_master/CPV: cdvan.mod
Only in .: cell_nose.f90
Only in ../../../ffn2_tsvdw_master/CPV: cg.F90
diff ./cglib.f90 ../../../ffn2_tsvdw_master/CPV/cglib.f90
18,19c18,20
<       USE cp_main_variables, ONLY: descla
<       USE descriptors,       ONLY: la_descriptor , ldim_cyclic
---
>       USE cp_main_variables, ONLY: descla, nlax, nrlx
>       USE descriptors,       ONLY: la_npc_ , la_npr_ , la_comm_ , la_me_ , la_nrl_ , &
>                                    lambda_node_ , ldim_cyclic
25c26
<       real(DP) :: zmat( MAXVAL(descla(:)%nrlx), nudx, nspin ), fmat( MAXVAL(descla(:)%nrlx), nudx, nspin ), fdiag( nx )
---
>       real(DP) :: zmat( nrlx, nudx, nspin ), fmat( nrlx, nudx, nspin ), fdiag( nx )
44,47c45,48
<          np_rot   = descla( iss )%npr * descla( iss )%npc
<          me_rot   = descla( iss )%mype
<          nrl      = descla( iss )%nrl
<          comm_rot = descla( iss )%comm
---
>          np_rot   = descla( la_npr_  , iss ) * descla( la_npc_ , iss )
>          me_rot   = descla( la_me_   , iss )
>          nrl      = descla( la_nrl_  , iss )
>          comm_rot = descla( la_comm_ , iss )
49c50
<          IF( descla( iss )%active_node > 0 ) THEN
---
>          IF( descla( lambda_node_ , iss ) > 0 ) THEN
51c52
<             ALLOCATE( mtmp( MAXVAL(descla(:)%nrlx), nudx ) )
---
>             ALLOCATE( mtmp( nrlx, nudx ) )
89a91
>       use cvan
91c93
<       use uspp_param, only: nh, ish, nvb
---
>       use uspp_param, only: nh
95,96c97,98
<       USE cp_main_variables, ONLY: descla
<       USE descriptors,       ONLY: la_descriptor
---
>       USE cp_main_variables, ONLY: descla, nlax, nrlx
>       USE descriptors,       ONLY: la_npc_ , la_npr_ , la_comm_ , la_me_ , la_nrl_
102c104
<       real(kind=DP)    z0( MAXVAL(descla(:)%nrlx), nudx, nspin )
---
>       real(kind=DP)    z0( nrlx, nudx, nspin )
112,115c114,117
<          np_rot   = descla( iss )%npr * descla( iss )%npc
<          me_rot   = descla( iss )%mype
<          nrl      = descla( iss )%nrl
<          comm_rot = descla( iss )%comm
---
>          np_rot   = descla( la_npr_  , iss ) * descla( la_npc_ , iss )
>          me_rot   = descla( la_me_   , iss )
>          nrl      = descla( la_nrl_  , iss )
>          comm_rot = descla( la_comm_ , iss )
241c243,244
<       use mp_global, only: intra_bgrp_comm
---
>       use mp_global, only: intra_image_comm, mpime
>       use cvan 
244c247,248
<       use gvect, only: gstart
---
>       use control_flags, only: iprint, iprsta
>       use reciprocal_vectors, only: ng0 => gstart
247c251
<       use uspp_param, only: nh, nvb, ish
---
>       use uspp_param, only: nh
284c288
<                if(gstart==2) bectmp(i,j)=bectmp(i,j)-DBLE(a(1,j))*DBLE(b(1,i))
---
>                if(ng0.eq.2) bectmp(i,j)=bectmp(i,j)-DBLE(a(1,j))*DBLE(b(1,i))
289c293
<          call mp_sum( bectmp(:,:), intra_bgrp_comm)
---
>          call mp_sum( bectmp(:,:), intra_image_comm)
315c319
< & ('N','N',nl_max,nss,nl_max,1.d0,qq_tmp,nl_max,becb(:,istart),nhsa,0.d0,qqb_tmp,nl_max, intra_bgrp_comm)
---
> & ('N','N',nl_max,nss,nl_max,1.d0,qq_tmp,nl_max,becb(:,istart),nhsa,0.d0,qqb_tmp,nl_max, intra_image_comm)
317c321
< &('T','N',nss,nss,nl_max,1.d0,beca(:,istart),nhsa,qqb_tmp,nl_max,1.d0,bectmp,nss, intra_bgrp_comm)
---
> &('T','N',nss,nss,nl_max,1.d0,beca(:,istart),nhsa,qqb_tmp,nl_max,1.d0,bectmp,nss, intra_image_comm)
349c353,354
<       use mp_global, only: intra_bgrp_comm
---
>       use mp_global, only: intra_image_comm
>       use cvan
352c357,358
<       use gvect, only: gstart
---
>       use control_flags, only: iprint, iprsta
>       use reciprocal_vectors, only: ng0 => gstart
355c361
<       use uspp_param, only: nh, ish, nvb
---
>       use uspp_param, only: nh
373c379
<                if (gstart==2) b(1,i) = CMPLX(dble(b(1,i)),0.0d0,kind=dp)
---
>                if (ng0.eq.2) b(1,i) = CMPLX(dble(b(1,i)),0.0d0,kind=dp)
378c384
<                if (gstart==2) sca = sca - dble(a(1,j))*dble(b(1,i))
---
>                if (ng0.eq.2) sca = sca - dble(a(1,j))*dble(b(1,i))
384c390
<          call mp_sum( scar, intra_bgrp_comm )
---
>          call mp_sum( scar, intra_image_comm )
394c400
<                if (gstart==2) b(1,i) = CMPLX(dble(b(1,i)),0.0d0,kind=dp)
---
>                if (ng0.eq.2) b(1,i) = CMPLX(dble(b(1,i)),0.0d0,kind=dp)
411c417,418
<       use mp_global, only: intra_bgrp_comm
---
>       use mp_global, only: intra_image_comm
>       use cvan
414c421,422
<       use gvect, only: gstart
---
>       use control_flags, only: iprint, iprsta
>       use reciprocal_vectors, only: ng0 => gstart
417c425
<       use uspp_param, only: nh, ish, nvb
---
>       use uspp_param, only: nh
477c485
<                         if (gstart==2) sca = sca - ema0bg(1)*DBLE(CONJG(betae(1,inl))*betae(1,jnl))
---
>                         if (ng0.eq.2) sca = sca - ema0bg(1)*DBLE(CONJG(betae(1,inl))*betae(1,jnl))
484c492
<                         if (gstart==2) sca = sca - DBLE(CONJG(betae(1,inl))*betae(1,jnl))
---
>                         if (ng0.eq.2) sca = sca - DBLE(CONJG(betae(1,inl))*betae(1,jnl))
493c501
<       call mp_sum( m_minus1, intra_bgrp_comm )
---
>       call mp_sum( m_minus1, intra_image_comm )
508c516
<       call mp_bcast( c_matrix, ionode_id, intra_bgrp_comm )
---
>       call mp_bcast( c_matrix, ionode_id, intra_image_comm )
534,535c542,544
<       use mp_global, only: intra_bgrp_comm
<       use uspp_param, only: nh, nvb, ish
---
>       use mp_global, only: intra_image_comm
>       use cvan
>       use uspp_param, only: nh
539a549
>       use control_flags, only: iprint, iprsta
541c551
<       use gvect, only: gstart
---
>       use reciprocal_vectors, only: ng0 => gstart
573c583
<                         if (gstart==2) becktmp = becktmp-ema0bg(1)*DBLE(CONJG(betae(1,inl))*c0(1,i)) 
---
>                         if (ng0.eq.2) becktmp = becktmp-ema0bg(1)*DBLE(CONJG(betae(1,inl))*c0(1,i)) 
579c589
<             call mp_sum( beck, intra_bgrp_comm )
---
>             call mp_sum( beck, intra_image_comm )
592c602
<                     beck, nhsa, 0.0d0, qtemp,nhsavb,intra_bgrp_comm )
---
>                     beck, nhsa, 0.0d0, qtemp,nhsavb,intra_image_comm )
656c666
<       USE gvect, ONLY: gstart
---
>       USE reciprocal_vectors, ONLY: gstart
659c669
<       USE mp_global,          ONLY: intra_bgrp_comm
---
>       USE mp_global,          ONLY: intra_image_comm
684c694
<       CALL mp_sum( ene_ave(1:n), intra_bgrp_comm )
---
>       CALL mp_sum( ene_ave(1:n), intra_image_comm )
708,709c718,720
<       use mp_global, only: intra_bgrp_comm
<       use uspp_param, only: nh, nvb, ish
---
>       use mp_global, only: intra_image_comm
>       use cvan
>       use uspp_param, only: nh
713a725
>       use control_flags, only: iprint, iprsta
715c727
<       use gvect, only: gstart
---
>       use reciprocal_vectors, only: ng0 => gstart
751c763
<                         if (gstart==2) becktmp = becktmp-ema0bg(1)*DBLE(CONJG(betae(1,inl))*c0(1,i))
---
>                         if (ng0.eq.2) becktmp = becktmp-ema0bg(1)*DBLE(CONJG(betae(1,inl))*c0(1,i))
757c769
<             call mp_sum( beck, intra_bgrp_comm )
---
>             call mp_sum( beck, intra_image_comm )
Only in ../../../ffn2_tsvdw_master/CPV: cglib.F90
Only in ../../../ffn2_tsvdw_master/CPV: cglib.o
Only in ../../../ffn2_tsvdw_master/CPV: cg_module.mod
Only in ../../../ffn2_tsvdw_master/CPV: cg.o
diff ./cg_sub.f90 ../../../ffn2_tsvdw_master/CPV/cg_sub.f90
13c13
<       lambdap, lambda, nlam, vpot, c0, cm, phi, dbec  )
---
>       lambdap, lambda, vpot  )
16c16
<       use control_flags, only: iprint, thdyn, tpre, iverbosity, &
---
>       use control_flags, only: iprint, thdyn, tpre, iprsta, &
18c18
<       use control_flags, only: nbeg, nomore, tsde, tortho, tnosee, &
---
>       use control_flags, only: ndr, ndw, nbeg, nomore, tsde, tortho, tnosee, &
20a21
>       use core, only: nlcc_any
25c26
<                                 nbspx, nbsp, ispin
---
>                                 nx => nbspx, n => nbsp, ispin
30,32c31,33
<       use gvect, only: ngm
<       use gvecs, only: ngms
<       use smallbox_gvec, only: ngb
---
>       use gvecp, only: ngm
>       use gvecs, only: ngs
>       use gvecb, only: ngb
34,36c35,43
<       use gvect, only: gstart
<       use ions_base, only: na, nat, nax, nsp, rcmax
<       use cell_base, only: omega, alat, tpiba2
---
>       use reciprocal_vectors, only: ng0 => gstart
>       use cvan, only: nvb, ish
>       use ions_base, only: na, nat, pmass, nax, nsp, rcmax
>       use grid_dimensions, only: nnr => nnrx, nr1, nr2, nr3
>       use cell_base, only: ainv, a1, a2, a3
>       use cell_base, only: omega, alat
>       use cell_base, only: h, hold, deth, wmass, tpiba2
>       use smooth_grid_dimensions, only: nnrsx, nr1s, nr2s, nr3s
>       use smallbox_grid_dimensions, only: nnrb => nnrbx, nr1b, nr2b, nr3b
38,39c45,46
<       use io_global,                ONLY : stdout, ionode, ionode_id
<       use mp_global,                ONLY : intra_bgrp_comm, np_ortho, me_ortho, ortho_comm
---
>       use io_global,                ONLY : io_global_start, stdout, ionode, ionode_id
>       use mp_global,                ONLY : intra_image_comm, np_ortho, me_ortho, ortho_comm, me_image
40a48
>       use cdvan
41a50
>       use io_files,                 only : psfile, pseudo_dir
43,46c52,53
<       use uspp,                     only : nhsa=> nkb, nhsavb=> nkbus, &
<                                            betae => vkb, rhovan => becsum, &
<                                            deeq, qq, nlcc_any
<       use uspp_param,               only : nh, nvb, ish
---
>       use uspp,                     only : nhsa=> nkb, nhsavb=> nkbus, betae => vkb, rhovan => becsum, deeq,qq
>       use uspp_param,               only : nh
49a57
>       use wavefunctions_module,     only : c0, cm, phi => cp
56,63c64,68
<       use orthogonalize_base,       ONLY : calphi_bgrp
<       use cp_interfaces,            ONLY : rhoofr, dforce, compute_stress, vofrho, nlfl_bgrp, prefor
<       use cp_interfaces,            ONLY : nlsm2_bgrp, calbec, caldbec_bgrp, nlfq_bgrp
<       use cp_interfaces,            ONLY : collect_lambda, distribute_lambda
<       USE cp_main_variables,        ONLY : descla, drhor, drhog
<       USE descriptors,              ONLY : la_descriptor, ldim_cyclic
<       USE mp_global, ONLY:  me_image, my_image_id, nbgrp
<       USE fft_base,  ONLY: dffts, dfftp
---
>       use orthogonalize_base,       ONLY : calphi
>       use cp_interfaces,            ONLY : rhoofr, dforce, compute_stress
>       USE cp_main_variables,        ONLY : nlax, collect_lambda, distribute_lambda, descla, nrlx, nlam
>       USE descriptors,              ONLY : la_npc_ , la_npr_ , la_comm_ , la_me_ , la_nrl_ , ldim_cyclic
>       USE mp_global, ONLY:  me_image,my_image_id
71c76
<       integer :: nfi, nlam
---
>       integer :: nfi
74,75c79,80
<       real(dp) :: bec(nhsa,nbspx)
<       real(dp) :: becdr(nhsa,nbspx,3)
---
>       real(dp) :: bec(nhsa,n)
>       real(dp) :: becdr(nhsa,nspin*nlax,3)
78,79c83,84
<       real(dp) :: rhor(dfftp%nnr,nspin)
<       real(dp) :: vpot(dfftp%nnr,nspin)
---
>       real(dp) :: rhor(nnr,nspin)
>       real(dp) :: vpot(nnr,nspin)
81,86c86,91
<       real(dp) :: rhos(dffts%nnr,nspin)
<       real(dp) :: rhoc(dfftp%nnr)
<       complex(dp) :: ei1(-dfftp%nr1:dfftp%nr1,nat)
<       complex(dp) :: ei2(-dfftp%nr2:dfftp%nr2,nat)
<       complex(dp) :: ei3(-dfftp%nr3:dfftp%nr3,nat)
<       complex(dp) :: sfac( ngms, nsp )
---
>       real(dp) :: rhos(nnrsx,nspin)
>       real(dp) :: rhoc(nnr)
>       complex(dp) :: ei1(-nr1:nr1,nat)
>       complex(dp) :: ei2(-nr2:nr2,nat)
>       complex(dp) :: ei3(-nr3:nr3,nat)
>       complex(dp) :: sfac( ngs, nsp )
91,94d95
<       complex(dp) :: c0( ngw, nbspx )
<       complex(dp) :: cm( ngw, nbspx )
<       complex(dp) :: phi( ngw, nbspx )
<       real(dp) :: dbec(nhsa,nbspx,3,3)
97c98
<       integer :: i, j, ig, k, is, iss,ia, iv, jv, il, ii, jj, kk, ip, nrlx
---
>       integer :: i, j, ig, k, is, iss,ia, iv, jv, il, ii, jj, kk, ip
130d130
<       nrlx = MAXVAL(descla(:)%nrlx)
132,133c132,133
<       allocate(bec0(nhsa,nbspx),becm(nhsa,nbspx), becdrdiag(nhsa,nbspx,3))
<       allocate (ave_ene(nbspx))
---
>       allocate(bec0(nhsa,n),becm(nhsa,n), becdrdiag(nhsa,nspin*nlax,3))
>       allocate (ave_ene(n))
138,141d137
< 
<       if( nbgrp > 1 ) &
<          call errore(' runcg_uspp ', ' parallelization over bands not yet implemented ', 1 )
< 
176c172,175
<       CALL gram_bgrp( betae, bec, nhsa, c0, ngw )
---
> 
>       call gram(betae,bec,nhsa,c0,ngw,n)
> 
>       !call calbec(1,nsp,eigr,c0,bec)
180c179,180
<       CALL calphi_bgrp( c0, SIZE(c0,1), bec, nhsa, betae, phi, nbsp )
---
>       ! call calphiid(c0,bec,betae,phi)
>       CALL calphi( c0, SIZE(c0,1), bec, nhsa, betae, phi, n )
197c197
<       allocate(hpsi(ngw,nbspx),hpsi0(ngw,nbspx),gi(ngw,nbspx),hi(ngw,nbspx))
---
>       allocate(hpsi(ngw,n),hpsi0(ngw,n),gi(ngw,n),hi(ngw,n))
204c204
<              call rhoofr(nfi,c0(:,:),irb,eigrb,bec,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>              call rhoofr(nfi,c0(:,:),irb,eigrb,bec,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
209c209
<                       rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,c0,bec,dbec,firstiter,vpot)
---
>                       rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,c0,bec,firstiter,vpot)
216,217c216,217
<             call rhoofr(nfi,c0diag,irb,eigrb,becdiag,dbec,                        &
<                      &                    rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>             call rhoofr(nfi,c0diag,irb,eigrb,becdiag                        &
>                      &                    ,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
242c242
<           call vofrho(nfi,vpot,drhor,rhog,drhog,rhos,rhoc,tfirst,tlast,             &
---
>           call vofrho(nfi,vpot,rhog,rhos,rhoc,tfirst,tlast,             &
303,304c303,304
<         do i=1,nbsp,2
<           call dforce( i, bec, betae, c0,c2,c3,rhos, dffts%nnr, ispin,f,nbsp,nspin)
---
>         do i=1,n,2
>           call dforce( i, bec, betae, c0,c2,c3,rhos, nnrsx, ispin,f,n,nspin)
319c319
<           if(i+1 <= nbsp) then
---
>           if(i+1 <= n) then
322c322
<           if (gstart==2) then
---
>           if (ng0.eq.2) then
324c324
<             if(i+1 <= nbsp) then
---
>             if(i+1 <= n) then
330c330
<         if(pre_state) call ave_kin(c0,SIZE(c0,1),nbsp,ave_ene)
---
>         if(pre_state) call ave_kin(c0,SIZE(c0,1),n,ave_ene)
335,336c335,336
<         hpsi0=hpsi
<         gi = hpsi
---
>         hpsi0(1:ngw,1:n)=hpsi(1:ngw,1:n)
>         gi(1:ngw,1:n) = hpsi(1:ngw,1:n)
366c366
<            do i=1,nbsp
---
>            do i=1,n
370c370
<               if (gstart==2) then
---
>               if (ng0.eq.2) then
375c375
<            call mp_sum( gamma, intra_bgrp_comm )
---
>            call mp_sum( gamma, intra_image_comm )
378c378
<               do i=1,nbsp
---
>               do i=1,n
398,399c398,399
<               me_rot = descla( iss )%mype
<               np_rot = descla( iss )%npc * descla( iss )%npr
---
>               me_rot = descla( la_me_ , iss )
>               np_rot = descla( la_npc_ , iss ) * descla( la_npr_ , iss )
406c406
<                  CALL mp_bcast( fmat_ , ip - 1 , intra_bgrp_comm )
---
>                  CALL mp_bcast( fmat_ , ip - 1 , intra_image_comm )
413c413
<                        if (gstart==2) then
---
>                        if (ng0.eq.2) then
426,427c426,427
<                  me_rot = descla( iss )%mype
<                  np_rot = descla( iss )%npc * descla( iss )%npr
---
>                  me_rot = descla( la_me_ , iss )
>                  np_rot = descla( la_npc_ , iss ) * descla( la_npr_ , iss )
434c434
<                     CALL mp_bcast( fmat_ , ip - 1 , intra_bgrp_comm )
---
>                     CALL mp_bcast( fmat_ , ip - 1 , intra_image_comm )
457c457
<            call mp_sum( gamma, intra_bgrp_comm )
---
>            call mp_sum( gamma, intra_image_comm )
469c469
<           hi=gi!hi is the search direction
---
>           hi(1:ngw,1:n)=gi(1:ngw,1:n)!hi is the search direction
482c482
<           hi=gi+gamma*hi
---
>           hi(1:ngw,1:n)=gi(1:ngw,1:n)+gamma*hi(1:ngw,1:n)
501c501
<           do i=1,nbsp
---
>           do i=1,n               
505c505
<             if (gstart==2) then
---
>             if (ng0.eq.2) then
516,517c516,517
<             me_rot = descla( iss )%mype
<             np_rot = descla( iss )%npc * descla( iss )%npr
---
>             me_rot = descla( la_me_ , iss )
>             np_rot = descla( la_npc_ , iss ) * descla( la_npr_ , iss )
524c524
<                CALL mp_bcast( fmat_ , ip - 1 , intra_bgrp_comm )
---
>                CALL mp_bcast( fmat_ , ip - 1 , intra_image_comm )
532c532
<                      if (gstart==2) then
---
>                      if (ng0.eq.2) then
544c544
<       call mp_sum( dene0, intra_bgrp_comm )
---
>       call mp_sum( dene0, intra_image_comm )
555c555
<       cm=c0+spasso*passof*hi
---
>       cm(1:ngw,1:n)=c0(1:ngw,1:n)+spasso*passof*hi(1:ngw,1:n)
560,561c560,562
<         call calbec(1,nsp,eigr,cm,becm)
<         CALL gram_bgrp( betae, becm, nhsa, cm, ngw )
---
>       call calbec(1,nsp,eigr,cm,becm)
>       call gram(betae,becm,nhsa,cm,ngw,n)
>         !call calbec(1,nsp,eigr,cm,becm)
565c566
<           call rhoofr(nfi,cm(:,:),irb,eigrb,becm,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>           call rhoofr(nfi,cm(:,:),irb,eigrb,becm,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
569c570
<                         rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,dbec,.false., vpot  )  
---
>                         rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,.false., vpot  )  
575c576
<           call rhoofr(nfi,c0diag,irb,eigrb,becdiag,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>           call rhoofr(nfi,c0diag,irb,eigrb,becdiag,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
586c587
<         call vofrho(nfi,vpot,drhor,rhog,drhog,rhos,rhoc,tfirst,tlast,             &
---
>         call vofrho(nfi,vpot,rhog,rhos,rhoc,tfirst,tlast,             &
608c609
<         if( iverbosity > 1 ) write(6,*) ene0,dene0,ene1,passo, gamma, esse
---
>         if(iprsta.gt.1) write(6,*) ene0,dene0,ene1,passo, gamma, esse
617,618c618,619
<         cm=c0+spasso*passo*hi
<         if(gstart==2) then
---
>         cm(1:ngw,1:n)=c0(1:ngw,1:n)+spasso*passo*hi(1:ngw,1:n)
>         if(ng0.eq.2) then
623c624
<         CALL gram_bgrp( betae, becm, nhsa, cm, ngw )
---
>         call gram(betae,becm,nhsa,cm,ngw,n)
629c630
<           call rhoofr(nfi,cm(:,:),irb,eigrb,becm,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>           call rhoofr(nfi,cm(:,:),irb,eigrb,becm,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
633c634
<                       rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,dbec,.false., vpot  )
---
>                       rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,.false., vpot  )
638c639
<           call rhoofr(nfi,c0diag,irb,eigrb,becdiag,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>           call rhoofr(nfi,c0diag,irb,eigrb,becdiag,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
649c650
<         call vofrho(nfi,vpot,drhor,rhog,drhog,rhos,rhoc,tfirst,tlast,             &
---
>         call vofrho(nfi,vpot,rhog,rhos,rhoc,tfirst,tlast,             &
675c676
<             if( iverbosity > 1 ) then
---
>             if(iprsta.gt.1) then
690c691
<           c0=c0+spasso*passov*hi
---
>           c0(1:ngw,1:n)=c0(1:ngw,1:n)+spasso*passov*hi(1:ngw,1:n)
693c694
<           CALL gram_bgrp( betae, bec, nhsa, c0, ngw )
---
>           call gram(betae,bec,nhsa,c0,ngw,n)
700c701
<           c0=c0+spasso*passov*hi
---
>           c0(1:ngw,1:n)=c0(1:ngw,1:n)+spasso*passov*hi(1:ngw,1:n)
703c704
<           CALL gram_bgrp( betae, bec, nhsa, c0, ngw )
---
>           call gram(betae,bec,nhsa,c0,ngw,n)
715c716
<             cm=c0+spasso*passov*hi
---
>             cm(1:ngw,1:n)=c0(1:ngw,1:n)+spasso*passov*hi(1:ngw,1:n)
719c720
<             CALL gram_bgrp( betae, bec, nhsa, cm, ngw )
---
>             call gram(betae,bec,nhsa,cm,ngw,n)
722c723
<               call rhoofr(nfi,cm(:,:),irb,eigrb,becm,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>               call rhoofr(nfi,cm(:,:),irb,eigrb,becm,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
726c727
<                           rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,dbec,.false., vpot  )
---
>                           rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,cm,becm,.false., vpot  )
731c732
<               call rhoofr(nfi,c0diag,irb,eigrb,becdiag,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>               call rhoofr(nfi,c0diag,irb,eigrb,becdiag,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
742c743
<             call vofrho(nfi,vpot,drhor,rhog,drhog,rhos,rhoc,tfirst,tlast,             &
---
>             call vofrho(nfi,vpot,rhog,rhos,rhoc,tfirst,tlast,             &
771c772
<         CALL calphi_bgrp( c0, SIZE(c0,1), bec, nhsa, betae, phi, nbsp )
---
>         CALL calphi( c0, SIZE(c0,1), bec, nhsa, betae, phi, n )
781c782
<                     rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,c0,bec,dbec,firstiter, vpot  )
---
>                     rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac,c0,bec,firstiter, vpot  )
803,804c804,805
<             call caldbec_bgrp( eigr, c0, dbec, descla )
<             call rhoofr(nfi,c0(:,:),irb,eigrb,bec,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>             call  caldbec( ngw, nhsa, n, 1, nsp, eigr, c0, dbec )
>             call rhoofr(nfi,c0(:,:),irb,eigrb,bec,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
810,811c811,813
<             call caldbec_bgrp( eigr, c0diag, dbec, descla )
<             call rhoofr(nfi,c0diag,irb,eigrb,becdiag,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6)
---
>             call  caldbec( ngw, nhsa, n, 1, nsp, eigr, c0diag, dbec )
>             call rhoofr(nfi,c0diag,irb,eigrb,becdiag                         &
>                      &                    ,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6)
825c827
<           call vofrho(nfi,vpot,drhor,rhog,drhog,rhos,rhoc,tfirst,tlast,             &
---
>           call vofrho(nfi,vpot,rhog,rhos,rhoc,tfirst,tlast,             &
837c839
<         if (tfor .or. tprnfor) call nlfq_bgrp( c0, eigr, bec, becdr, fion ) ! call nlfq(c0,eigr,bec,becdr,fion)
---
>         if (tfor .or. tprnfor) call nlfq(c0,eigr,bec,becdr,fion)
839c841
<         if (tfor .or. tprnfor) call nlfq_bgrp( c0diag, eigr, becdiag, becdrdiag, fion ) ! call nlfq(c0diag,eigr,becdiag,becdrdiag,fion)
---
>         if (tfor .or. tprnfor) call nlfq(c0diag,eigr,becdiag,becdrdiag,fion)
843,844c845,846
<         do i=1,nbsp,2
<           call dforce(i,bec,betae,c0,c2,c3,rhos,dffts%nnr,ispin,f,nbsp,nspin)
---
>         do i=1,n,2
>           call dforce(i,bec,betae,c0,c2,c3,rhos,nnrsx,ispin,f,n,nspin)
872c874
<             if(i+1 <= nbsp) then
---
>             if(i+1 <= n) then
876c878
<           if (gstart==2) then
---
>           if (ng0.eq.2) then
878c880
<             if(i+1 <= nbsp) then
---
>             if(i+1 <= n) then
901c903
<                  if( gstart == 2 ) then
---
>                  if( ng0 == 2 ) then
909c911
<            CALL mp_sum( lambda_repl, intra_bgrp_comm )
---
>            CALL mp_sum( lambda_repl, intra_image_comm )
911c913
<            CALL distribute_lambda( lambda_repl, lambda( :, :, is ), descla( is ) )
---
>            CALL distribute_lambda( lambda_repl, lambda( :, :, is ), descla( :, is ) )
929c931
<               CALL cyc2blk_redist( nss, fmat0(1,1,iss), nrlx, SIZE(fmat0,2), lambda_dist, nlam, nlam, descla(iss) )
---
>               CALL cyc2blk_redist( nss, fmat0(1,1,iss), nrlx, SIZE(fmat0,2), lambda_dist, nlam, nlam, descla(1,iss) )
934c936
<                                   0.0d0, lambdap(1,1,iss), nlam, descla(iss) )
---
>                                   0.0d0, lambdap(1,1,iss), nlam, descla(1,iss) )
944c946
<            call nlsm2_bgrp( ngw, nhsa, eigr, c0, becdr, nbspx, nbsp )
---
>            call nlsm2(ngw,nhsa,n,nspin,eigr,c0(:,:),becdr)
950c952
<         CALL nlfl_bgrp( bec, becdr, lambda, descla, fion ) 
---
>         call nlfl(bec,becdr,lambda,fion)
Only in ../../../ffn2_tsvdw_master/CPV: cg_sub.F90
Only in ../../../ffn2_tsvdw_master/CPV: cg_sub.o
diff ./chargedensity.f90 ../../../ffn2_tsvdw_master/CPV/chargedensity.f90
24c24
<        USE gvect, ONLY: gstart
---
>        USE reciprocal_vectors, ONLY: gzero
42c42
<         IF( gstart == 2 ) THEN
---
>         IF( gzero ) THEN
68c68
<       ( nfi, c_bgrp, irb, eigrb, bec_bgrp, dbec, rhovan, rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin, tstress, ndwwf )
---
>       ( nfi, c, irb, eigrb, bec, rhovan, rhor, rhog, rhos, enl, denl, ekin, dekin, tstress, ndwwf )
101c101
<       USE control_flags,      ONLY: iprint, iverbosity, thdyn, tpre, trhor
---
>       USE control_flags,      ONLY: iprint, iprsta, thdyn, tpre, trhor
103,105c103,105
<       USE gvect,              ONLY: ngm,  nl, nlm
<       USE gvecs,              ONLY: ngms, nls, nlsm
<       USE smallbox_gvec,              ONLY: ngb
---
>       USE gvecp,              ONLY: ngm
>       USE gvecs,              ONLY: ngs, nps, nms
>       USE gvecb,              ONLY: ngb
107c107,108
<       USE gvect,              ONLY: gstart
---
>       USE recvecs_indexes,    ONLY: np, nm
>       USE reciprocal_vectors, ONLY: gstart
109a111,112
>       USE grid_dimensions,    ONLY: nr1, nr2, nr3, &
>                                     nr1x, nr2x, nr3x, nnrx
111c114,116
<       USE electrons_base,     ONLY: nspin, nbsp_bgrp, ispin_bgrp, f_bgrp
---
>       USE smooth_grid_dimensions, ONLY: nr1s, nr2s, nr3s, &
>                                         nr1sx, nr2sx, nr3sx, nnrsx
>       USE electrons_base,     ONLY: nx => nbspx, n => nbsp, f, ispin, nspin
115c120,121
<       USE mp_global,          ONLY: intra_bgrp_comm, nbgrp, inter_bgrp_comm, me_bgrp
---
>       USE mp_global,          ONLY: intra_image_comm, nogrp, me_image, &
>                                     use_task_groups, ogrp_comm, nolist
118,119c124
<       USE cp_interfaces,      ONLY: stress_kin, enkin
<       USE fft_interfaces,     ONLY: fwfft, invfft
---
>       USE cp_interfaces,      ONLY: fwfft, invfft, stress_kin
121,122c126,128
<       USE cp_interfaces,      ONLY: checkrho, ennl, calrhovan, dennl
<       USE cp_main_variables,  ONLY: iprint_stdout, descla
---
>       USE cp_interfaces,      ONLY: checkrho
>       USE cdvan,              ONLY: dbec, drhovan
>       USE cp_main_variables,  ONLY: iprint_stdout, drhor, drhog
124c130,131
<       USE cp_main_variables,  ONLY: rhopr ! Lingzhu Kong
---
>       USE cell_base,          ONLY: a1, a2, a3
>       USE cp_main_variables,  ONLY: rhopr
128,129c135
<       REAL(DP) bec_bgrp(:,:)
<       REAL(DP) dbec(:,:,:,:)
---
>       REAL(DP) bec(:,:)
132d137
<       REAL(DP) drhor(:,:,:,:)
138,139c143
<       COMPLEX(DP) drhog( :, :, :, : )
<       COMPLEX(DP) c_bgrp( :, : )
---
>       COMPLEX(DP) c( :, : )
148a153
>       REAL(DP), EXTERNAL :: enkin, ennl
151d155
<       REAL(DP), ALLOCATABLE :: drhovan(:,:,:,:,:)
156a161
> 
170,173c175
<       ekin = enkin( c_bgrp, f_bgrp, nbsp_bgrp )
<       !
<       IF( nbgrp > 1 ) &
<          CALL mp_sum( ekin, inter_bgrp_comm )
---
>       ekin = enkin( c, ngw, f, n )
179,182c181
<          CALL stress_kin( dekin, c_bgrp, f_bgrp )
<          !
<          IF( nbgrp > 1 ) &
<             CALL mp_sum( dekin, inter_bgrp_comm )
---
>          CALL stress_kin( dekin, c, f )
190c189
<          CALL calrhovan( rhovan, bec_bgrp, iwf )
---
>          CALL calrhovan( rhovan, bec, iwf )
196,201c195
<          CALL ennl( enl, rhovan, bec_bgrp )
<          !
<          IF( nbgrp > 1 ) THEN
<             CALL mp_sum( enl, inter_bgrp_comm )
<             CALL mp_sum( rhovan, inter_bgrp_comm )
<          END IF
---
>          enl = ennl( rhovan, bec )
207,214c201
<          ALLOCATE( drhovan( nhm*(nhm+1)/2, nat, nspin, 3, 3 ) )
<          !
<          CALL dennl( bec_bgrp, dbec, drhovan, denl, descla ) 
<          !
<          IF( nbgrp > 1 ) THEN
<             CALL mp_sum( denl, inter_bgrp_comm )
<             CALL mp_sum( drhovan, inter_bgrp_comm )
<          END IF
---
>          CALL dennl( bec, dbec, drhovan, denl ) 
226c213
< ! Lingzhu Kong
---
> !        CALL read_rho( nspin, rhor )
234a222,223
> 
>          ALLOCATE( psi( nnrx ) )
236d224
<          ALLOCATE( psi( dfftp%nnr ) )
239c227
<             DO ir=1,dfftp%nnr
---
>             DO ir=1,nnrx
244c232
<                rhog(ig,iss)=psi(nl(ig))
---
>                rhog(ig,iss)=psi(np(ig))
249c237
<             DO ir=1,dfftp%nnr
---
>             DO ir=1,nnrx
254,255c242,243
<                fp=psi(nl(ig))+psi(nlm(ig))
<                fm=psi(nl(ig))-psi(nlm(ig))
---
>                fp=psi(np(ig))+psi(nm(ig))
>                fm=psi(np(ig))-psi(nm(ig))
271c259
<          IF ( MOD( nbsp_bgrp, 2 ) /= 0 ) THEN
---
>          IF ( MOD( n, 2 ) /= 0 ) THEN
273,274c261,262
<             IF( SIZE( c_bgrp, 2 ) < nbsp_bgrp + 1 ) &
<                CALL errore( ' rhoofr ', ' c second dimension too small ', SIZE( c_bgrp, 2 ) )
---
>             IF( SIZE( c, 2 ) < n+1 ) &
>                CALL errore( ' rhoofr ', ' c second dimension too small ', SIZE( c, 2 ) )
276c264
<             c_bgrp( :, nbsp_bgrp + 1 ) = ( 0.d0, 0.d0 )
---
>             c( :, n+1 ) = ( 0.d0, 0.d0 )
288,289c276,277
<                psis(nlsm(ig))=CONJG(c_bgrp(ig,i))
<                psis(nls(ig))=c_bgrp(ig,i)
---
>                psis(nms(ig))=CONJG(c(ig,i))
>                psis(nps(ig))=c(ig,i)
295,296c283,284
<             sa1=f_bgrp(i)/omega
<             DO ir=1,dffts%nnr
---
>             sa1=f(i)/omega
>             DO ir=1,nnrsx
300c288
<          ELSE IF( dffts%have_task_groups ) THEN
---
>          ELSE IF( use_task_groups ) THEN
306c294
<             ALLOCATE( psis( dffts%nnr ) ) 
---
>             ALLOCATE( psis( nnrsx ) ) 
308c296
<             DO i = 1, nbsp_bgrp, 2
---
>             DO i = 1, n, 2
310c298
<                CALL c2psi( psis, dffts%nnr, c_bgrp( 1, i ), c_bgrp( 1, i+1 ), ngw, 2 )
---
>                CALL c2psi( psis, nnrsx, c( 1, i ), c( 1, i+1 ), ngw, 2 )
314,318c302,306
<                iss1 = ispin_bgrp(i)
<                sa1  = f_bgrp(i) / omega
<                IF ( i .NE. nbsp_bgrp ) THEN
<                   iss2 = ispin_bgrp(i+1)
<                   sa2  = f_bgrp(i+1) / omega
---
>                iss1 = ispin(i)
>                sa1  = f(i) / omega
>                IF ( i .NE. n ) THEN
>                   iss2 = ispin(i+1)
>                   sa2  = f(i+1) / omega
324c312
<                DO ir = 1, dffts%nnr
---
>                DO ir = 1, nnrsx
331,334d318
<             IF( nbgrp > 1 ) THEN
<                call mp_sum( rhos, inter_bgrp_comm )
<             END IF
<             !
341c325
<          ALLOCATE( psis( dffts%nnr ) ) 
---
>          ALLOCATE( psis( nnrsx ) ) 
345c329
<             DO ir=1,dffts%nnr
---
>             DO ir=1,nnrsx
349,350c333,334
<             DO ig=1,ngms
<                rhog(ig,iss)=psis(nls(ig))
---
>             DO ig=1,ngs
>                rhog(ig,iss)=psis(nps(ig))
355c339
<              DO ir=1,dffts%nnr
---
>              DO ir=1,nnrsx
359,361c343,345
<             DO ig=1,ngms
<                fp= psis(nls(ig)) + psis(nlsm(ig))
<                fm= psis(nls(ig)) - psis(nlsm(ig))
---
>             DO ig=1,ngs
>                fp= psis(nps(ig)) + psis(nms(ig))
>                fm= psis(nps(ig)) - psis(nms(ig))
367c351
<          ALLOCATE( psi( dfftp%nnr ) )
---
>          ALLOCATE( psi( nnrx ) )
375,377c359,361
<             DO ig=1,ngms
<                psi(nlm(ig))=CONJG(rhog(ig,iss))
<                psi(nl (ig))=      rhog(ig,iss)
---
>             DO ig=1,ngs
>                psi(nm(ig))=CONJG(rhog(ig,iss))
>                psi(np(ig))=      rhog(ig,iss)
380c364
<             DO ir=1,dfftp%nnr
---
>             DO ir=1,nnrx
391,393c375,377
<             DO ig=1,ngms
<                psi(nlm(ig))=CONJG(rhog(ig,isup))+ci*CONJG(rhog(ig,isdw))
<                psi(nl(ig))=rhog(ig,isup)+ci*rhog(ig,isdw)
---
>             DO ig=1,ngs
>                psi(nm(ig))=CONJG(rhog(ig,isup))+ci*CONJG(rhog(ig,isdw))
>                psi(np(ig))=rhog(ig,isup)+ci*rhog(ig,isdw)
396c380
<             DO ir=1,dfftp%nnr
---
>             DO ir=1,nnrx
402c386
<          IF ( dft_is_meta() ) CALL kedtauofr_meta( c_bgrp, psi, SIZE( psi ), psis, SIZE( psis ) ) ! METAGGA
---
>          IF ( dft_is_meta() ) CALL kedtauofr_meta( c, psi, SIZE( psi ), psis, SIZE( psis ) ) ! METAGGA
410,413c394,396
<          IF ( ttstress ) THEN
<             CALL drhov( irb, eigrb, rhovan, drhovan, rhog, rhor, drhog, drhor )
<             DEALLOCATE( drhovan )
<          END IF
---
>          !
>          IF ( ttstress ) &
>             CALL drhov( irb, eigrb, rhovan, rhog, rhor, drhog, drhor )
421c404
<          CALL old_write_rho( ndwwf, nspin, rhor )
---
>          CALL old_write_rho( ndwwf, nspin, rhor, a1, a2, a3 )
427c410
<       IF( ( iverbosity > 2 ) .OR. ( nfi == 0 ) .OR. &
---
>       IF( ( iprsta > 2 ) .OR. ( nfi == 0 ) .OR. &
430,433c413,416
<          IF( iverbosity > 2 ) THEN
<             CALL checkrho( dfftp%nnr, nspin, rhor, rmin, rmax, rsum, rnegsum )
<             rnegsum = rnegsum * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
<             rsum    = rsum    * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>          IF( iprsta > 2 ) THEN
>             CALL checkrho( nnrx, nspin, rhor, rmin, rmax, rsum, rnegsum )
>             rnegsum = rnegsum * omega / DBLE(nr1*nr2*nr3)
>             rsum    = rsum    * omega / DBLE(nr1*nr2*nr3)
473c456
<             rsumr(iss)=SUM(rhor(:,iss),1)*omega/DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>             rsumr(iss)=SUM(rhor(:,iss),1)*omega/DBLE(nr1*nr2*nr3)
483,484c466,467
<          CALL mp_sum( rsumg( 1:nspin ), intra_bgrp_comm )
<          CALL mp_sum( rsumr( 1:nspin ), intra_bgrp_comm )
---
>          CALL mp_sum( rsumg( 1:nspin ), intra_image_comm )
>          CALL mp_sum( rsumr( 1:nspin ), intra_image_comm )
505c488
<          ALLOCATE( psis( dffts%tg_nnr * dffts%nogrp ) ) 
---
>          ALLOCATE( psis( dffts%nnrx * nogrp ) ) 
507c490
<          ALLOCATE( tmp_rhos ( dffts%nr1x*dffts%nr2x*dffts%tg_npp( me_bgrp + 1 ), nspin ) )
---
>          ALLOCATE( tmp_rhos ( nr1sx * nr2sx * dffts%tg_npp( me_image + 1 ), nspin ) )
511c494
<          do i = 1, nbsp_bgrp, 2*dffts%nogrp
---
>          do i = 1, n, 2*nogrp
527c510
<             !  nlsm and nls matrices: hold conversion indices form 3D to
---
>             !  nms and nps matrices: hold conversion indices form 3D to
535c518
<             do eig_index = 1, 2*dffts%nogrp, 2   
---
>             do eig_index = 1, 2*nogrp, 2   
539c522
<                IF ( ( i + eig_index - 1 ) <= nbsp_bgrp ) THEN
---
>                IF ( ( i + eig_index - 1 ) <= n ) THEN
552,553c535,536
<                      psis(nlsm(ig)+eig_offset*dffts%tg_nnr)=conjg(c_bgrp(ig,i+eig_index-1))+ci*conjg(c_bgrp(ig,i+eig_index))
<                      psis(nls(ig)+eig_offset*dffts%tg_nnr)=c_bgrp(ig,i+eig_index-1)+ci*c_bgrp(ig,i+eig_index)
---
>                      psis(nms(ig)+eig_offset*dffts%nnrx)=conjg(c(ig,i+eig_index-1))+ci*conjg(c(ig,i+eig_index))
>                      psis(nps(ig)+eig_offset*dffts%nnrx)=c(ig,i+eig_index-1)+ci*c(ig,i+eig_index)
576,577c559,560
<             DO ii = 1, dffts%nogrp
<                IF( dffts%nolist( ii ) == me_bgrp ) EXIT
---
>             DO ii = 1, nogrp
>                IF( nolist( ii ) == me_image ) EXIT
587,594c570,577
<             IF( ii + i - 1 < nbsp_bgrp ) THEN
<                iss1=ispin_bgrp( ii + i - 1 )
<                sa1 =f_bgrp( ii + i - 1 )/omega
<                iss2=ispin_bgrp( ii + i )
<                sa2 =f_bgrp( ii + i )/omega
<             ELSE IF( ii + i - 1 == nbsp_bgrp ) THEN
<                iss1=ispin_bgrp( ii + i - 1 )
<                sa1 =f_bgrp( ii + i - 1 )/omega
---
>             IF( ii + i - 1 < n ) THEN
>                iss1=ispin( ii + i - 1 )
>                sa1 =f( ii + i - 1 )/omega
>                iss2=ispin( ii + i )
>                sa2 =f( ii + i )/omega
>             ELSE IF( ii + i - 1 == n ) THEN
>                iss1=ispin( ii + i - 1 )
>                sa1 =f( ii + i - 1 )/omega
598c581
<                iss1=ispin_bgrp( nbsp_bgrp )
---
>                iss1=ispin( n )
614c597
<             !to each processor. In the original code this is nnr. In the task-groups
---
>             !to each processor. In the original code this is nnrsx. In the task-groups
618,620c601,602
<             ir =  dffts%nr1x*dffts%nr2x*dffts%tg_npp( me_bgrp + 1 ) 
<             IF( ir > SIZE( psis ) ) &
<                CALL errore( ' rhoofr ', ' psis size too small ', ir )
---
>             IF( nr1sx * nr2sx * dffts%tg_npp( me_image + 1 ) > SIZE( psis ) ) &
>                CALL errore( ' rhoofr ', ' psis size too low ', nr1sx * nr2sx * dffts%tg_npp( me_image + 1 ) )
623c605
<             do ir = 1, dffts%nr1x*dffts%nr2x*dffts%tg_npp( me_bgrp + 1 )
---
>             do ir = 1, nr1sx * nr2sx * dffts%tg_npp( me_image + 1 )
630,635c612,613
<          IF( nbgrp > 1 ) THEN
<             CALL mp_sum( tmp_rhos, inter_bgrp_comm )
<          END IF
< 
<          IF ( dffts%nogrp > 1 ) THEN
<             CALL mp_sum( tmp_rhos, gid = dffts%ogrp_comm )
---
>          IF ( nogrp > 1 ) THEN
>             CALL mp_sum( tmp_rhos, gid = ogrp_comm )
644,646c622,624
<          DO ii = 1, dffts%nogrp
<             IF ( dffts%nolist( ii ) == me_bgrp ) EXIT !Exit the loop
<             from = from +  dffts%nr1x*dffts%nr2x*dffts%npp( dffts%nolist( ii ) + 1 )! From where to copy initially
---
>          DO ii = 1, nogrp
>             IF ( nolist( ii ) == me_image ) EXIT !Exit the loop
>             from = from +  nr1sx*nr2sx*dffts%npp( nolist( ii ) + 1 )! From where to copy initially
650c628
<             CALL dcopy( dffts%nr1x*dffts%nr2x*dffts%npp(me_bgrp+1), tmp_rhos(from,ir), 1, rhos(1,ir), 1)
---
>             CALL dcopy( nr1sx*nr2sx*dffts%npp(me_image+1), tmp_rhos(from,ir), 1, rhos(1,ir), 1)
674,676c652,658
<       use gvect,              ONLY: g, ngm, nl, nlm
<       use cell_base,          ONLY: tpiba
<       USE fft_interfaces,     ONLY: invfft
---
>       use reciprocal_vectors, only: gx
>       use recvecs_indexes,    only: np, nm
>       use gvecp,              only: ngm
>       use grid_dimensions,    only: nr1, nr2, nr3, &
>                                     nr1x, nr2x, nr3x, nnrx
>       use cell_base,          only: tpiba
>       USE cp_interfaces,      ONLY: invfft
684c666
<       real(DP) ::    gradr( dfftp%nnr, 3, nspin )
---
>       real(DP) ::    gradr( nnrx, 3, nspin )
691c673
<       allocate( v( dfftp%nnr ) ) 
---
>       allocate( v( nnrx ) ) 
697c679
<          do ig = 1, dfftp%nnr
---
>          do ig = 1, nnrx
702,703c684,685
<             v(nl (ig))=      ci*tpiba*g(1,ig)*rhog(ig,iss)
<             v(nlm(ig))=CONJG(ci*tpiba*g(1,ig)*rhog(ig,iss))
---
>             v(np(ig))=      ci*tpiba*gx(1,ig)*rhog(ig,iss)
>             v(nm(ig))=CONJG(ci*tpiba*gx(1,ig)*rhog(ig,iss))
711c693
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnrx
715c697
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnrx
720,723c702,705
<             v(nl(ig))= tpiba*(      ci*g(2,ig)*rhog(ig,iss)-           &
<      &                                 g(3,ig)*rhog(ig,iss) )
<             v(nlm(ig))=tpiba*(CONJG(ci*g(2,ig)*rhog(ig,iss)+           &
<      &                                 g(3,ig)*rhog(ig,iss)))
---
>             v(np(ig))= tpiba*(      ci*gx(2,ig)*rhog(ig,iss)-           &
>      &                                 gx(3,ig)*rhog(ig,iss) )
>             v(nm(ig))= tpiba*(CONJG(ci*gx(2,ig)*rhog(ig,iss)+           &
>      &                                 gx(3,ig)*rhog(ig,iss)))
730c712
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnrx
751c733
<       USE mp_global, ONLY: intra_bgrp_comm
---
>       USE mp_global, ONLY: intra_image_comm
774,775c756,757
<       CALL mp_sum( rsum, intra_bgrp_comm )
<       CALL mp_sum( rnegsum, intra_bgrp_comm )
---
>       CALL mp_sum( rsum, intra_image_comm )
>       CALL mp_sum( rnegsum, intra_image_comm )
781c763
< SUBROUTINE drhov(irb,eigrb,rhovan,drhovan,rhog,rhor,drhog,drhor)
---
> SUBROUTINE drhov(irb,eigrb,rhovan,rhog,rhor,drhog,drhor)
794c776,778
<       USE uspp_param,               ONLY: nhm, nh, nvb
---
>       USE cvan,                     ONLY: nvb
>       USE uspp_param,               ONLY: nhm, nh
>       USE grid_dimensions,          ONLY: nr1, nr2, nr3, nr1x, nr2x, nr3x, nnr => nnrx
796,797c780,782
<       USE smallbox_gvec,            ONLY: ngb, npb, nmb
<       USE gvect,                    ONLY: ngm, nlm, nl
---
>       USE gvecb,                    ONLY: ngb, npb, nmb
>       USE gvecp,                    ONLY: ng => ngm
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, nnrb => nnrbx
799,803c784,789
<       USE qgb_mod,                  ONLY: qgb, dqgb
<       USE fft_interfaces,           ONLY: fwfft, invfft
<       USE fft_base,                 ONLY: dfftb, dfftp, dfftb
<       USE mp_global,                ONLY: my_bgrp_id, nbgrp, inter_bgrp_comm
<       USE mp,                       ONLY: mp_sum
---
>       USE qgb_mod,                  ONLY: qgb
>       USE cdvan,                    ONLY: drhovan
>       USE dqgb_mod,                 ONLY: dqgb
>       USE recvecs_indexes,          ONLY: nm, np
>       USE cp_interfaces,            ONLY: fwfft, invfft
>       USE fft_base,                 ONLY: dfftb, dfftp
808c794
<       REAL(DP),    INTENT(IN) ::  rhor(dfftp%nnr,nspin)
---
>       REAL(DP),    INTENT(IN) ::  rhor(nnr,nspin)
810,811c796
<       REAL(DP),    INTENT(IN) ::  drhovan(nhm*(nhm+1)/2,nat,nspin,3,3)
<       COMPLEX(DP), INTENT(IN) ::  eigrb(ngb,nat), rhog(ngm,nspin)
---
>       COMPLEX(DP), INTENT(IN) ::  eigrb(ngb,nat), rhog(ng,nspin)
813,814c798,799
<       REAL(DP),    INTENT(OUT) :: drhor(dfftp%nnr,nspin,3,3)
<       COMPLEX(DP), INTENT(OUT) :: drhog(ngm,nspin,3,3)
---
>       REAL(DP),    INTENT(OUT) :: drhor(nnr,nspin,3,3)
>       COMPLEX(DP), INTENT(OUT) :: drhog(ng,nspin,3,3)
817,818c802,803
<      &     isa, ia, ir, ijs
<       REAL(DP) :: asumt, dsumt
---
>      &     isa, ia, ir
>       REAL(DP) sum, dsum
824,828d808
<       INTEGER  :: itid, mytid, ntids
< #ifdef __OPENMP
<       INTEGER  :: omp_get_thread_num, omp_get_num_threads
<       EXTERNAL :: omp_get_thread_num, omp_get_num_threads
< #endif
830,838d809
< !$omp parallel default(none), private(i,j,iss,ir,ig,mytid,ntids,itid), shared(nspin,dfftp,drhor,drhog,rhor,rhog,ainv,ngm) 
< #ifdef __OPENMP
<       mytid = omp_get_thread_num()  ! take the thread ID
<       ntids = omp_get_num_threads() ! take the number of threads
< #else
<       mytid = 0
<       ntids = 1
< #endif
<       itid  = 0
842,850c813,818
<                IF( MOD( itid,  ntids ) == mytid ) THEN
<                   DO ir=1,dfftp%nnr
<                      drhor(ir,iss,i,j)=-rhor(ir,iss)*ainv(j,i)
<                   END DO
<                   DO ig=1,ngm
<                      drhog(ig,iss,i,j)=-rhog(ig,iss)*ainv(j,i)
<                   END DO
<                END IF
<                itid = itid + 1 
---
>                DO ir=1,nnr
>                   drhor(ir,iss,i,j)=-rhor(ir,iss)*ainv(j,i)
>                END DO
>                DO ig=1,ng
>                   drhog(ig,iss,i,j)=-rhog(ig,iss)*ainv(j,i)
>                END DO
854d821
< !$omp end parallel
856c823
<       IF ( nvb <= 0 ) RETURN
---
>       IF ( nvb == 0 ) RETURN
858c825,827
<       ALLOCATE( v( dfftp%nnr ) )
---
>       ALLOCATE( v( nnr ) )
>       ALLOCATE( qv( nnrb ) )
>       ALLOCATE( dqgbt( ngb, 2 ) )
871,885d839
< !$omp parallel default(none) &
< !$omp          shared(nvb, na, ngb, nh, eigrb, dfftb, irb, v, &
< !$omp                 nmb, ci, npb, i, j, dqgb, qgb, nhm, rhovan, drhovan ) &
< !$omp          private(mytid, ntids, is, ia, nfft, ifft, iv, jv, ijv, ig, iss, isa, &
< !$omp                  qv, itid, dqgbt, dsumt, asumt )
< 
<                ALLOCATE( qv( dfftb%nnr ) )
<                ALLOCATE( dqgbt( ngb, 2 ) )
< 
< #ifdef __OPENMP
<                mytid = omp_get_thread_num()  ! take the thread ID
<                ntids = omp_get_num_threads() ! take the number of threads
<                itid  = 0
< #endif
< 
890c844
< #ifdef __MPI
---
> #ifdef __PARA
893,896c847
<                      IF ( ( dfftb%np3( isa ) <= 0 ) ) THEN
<                         isa = isa + nfft
<                         CYCLE
<                      END IF
---
>                      IF ( dfftb%np3( isa ) <= 0 ) go to 15
899,901d849
<                      !
<                      !  nfft=2 if two ffts at the same time are performed
<                      !
903,913d850
<                      IF (ia.EQ.na(is)) nfft=1
< #endif
< 
< #ifdef __OPENMP
<                      IF ( mytid /= itid ) THEN
<                         isa = isa + nfft
<                         itid = MOD( itid + 1, ntids )
<                         CYCLE
<                      ELSE
<                         itid = MOD( itid + 1, ntids )
<                      END IF
915d851
< 
917c853,856
<                      qv(:) = (0.d0, 0.d0)
---
>                      IF (ia.EQ.na(is)) nfft=1
>                      !
>                      !  nfft=2 if two ffts at the same time are performed
>                      !
921a861,862
>                               sum = rhovan(ijv,isa+ifft-1,iss)
>                               dsum=drhovan(ijv,isa+ifft-1,iss,i,j)
923,927c864,865
<                                  asumt = 2.0d0 *  rhovan( ijv, isa+ifft-1, iss )
<                                  dsumt = 2.0d0 * drhovan( ijv, isa+ifft-1, iss, i, j )
<                               ELSE
<                                  asumt =  rhovan( ijv, isa+ifft-1, iss )
<                                  dsumt = drhovan( ijv, isa+ifft-1, iss, i, j )
---
>                                  sum =2.d0*sum
>                                  dsum=2.d0*dsum
930,931c868,870
<                                  dqgbt(ig,ifft)=dqgbt(ig,ifft) + asumt*dqgb(ig,ijv,is,i,j)
<                                  dqgbt(ig,ifft)=dqgbt(ig,ifft) + dsumt*qgb(ig,ijv,is)
---
>                                  dqgbt(ig,ifft)=dqgbt(ig,ifft) +        &
>      &                                (sum*dqgb(ig,ijv,is,i,j) +        &
>      &                                dsum*qgb(ig,ijv,is) )
938a878
>                      qv(:) = (0.d0, 0.d0)
943,944c883,885
<                            qv(nmb(ig))=  CONJG(eigrb(ig,isa  )*dqgbt(ig,1)) &
<      &                        + ci*      CONJG(eigrb(ig,isa+1)*dqgbt(ig,2))
---
>                            qv(nmb(ig))=                                 &
>      &                             CONJG(eigrb(ig,isa  )*dqgbt(ig,1)) &
>      &                        + ci*CONJG(eigrb(ig,isa+1)*dqgbt(ig,2))
948,949c889,891
<                            qv(npb(ig)) =       eigrb(ig,isa)*dqgbt(ig,1)
<                            qv(nmb(ig)) = CONJG(eigrb(ig,isa)*dqgbt(ig,1))
---
>                            qv(npb(ig)) = eigrb(ig,isa)*dqgbt(ig,1)
>                            qv(nmb(ig)) =                                &
>      &                             CONJG(eigrb(ig,isa)*dqgbt(ig,1))
952,953c894,895
<                      !
<                      CALL invfft( 'Box', qv, dfftb, isa )
---
> !
>                      CALL invfft('Box',qv, dfftb, isa)
963c905
<                      isa = isa + nfft
---
>   15                 isa = isa + nfft
967,969d908
< 
<                DEALLOCATE( dqgbt )
<                DEALLOCATE( qv )
971,976c910
< !$omp end parallel
< 
< 
<                iss = 1
< 
<                DO ir=1,dfftp%nnr
---
>                DO ir=1,nnr
982,983c916,917
<                DO ig=1,ngm
<                   drhog(ig,iss,i,j) = drhog(ig,iss,i,j) + v(nl(ig))
---
>                DO ig=1,ng
>                   drhog(ig,iss,i,j) = drhog(ig,iss,i,j) + v(np(ig))
998,999d931
<                ALLOCATE( qv( dfftb%nnr ) )
<                ALLOCATE( dqgbt( ngb, 2 ) )
1003c935
< #ifdef __MPI
---
> #ifdef __PARA
1011,1012c943,944
<                               asumt=rhovan(ijv,isa,iss)
<                               dsumt =drhovan(ijv,isa,iss,i,j)
---
>                               sum=rhovan(ijv,isa,iss)
>                               dsum =drhovan(ijv,isa,iss,i,j)
1014,1015c946,947
<                                  asumt =2.d0*asumt
<                                  dsumt=2.d0*dsumt
---
>                                  sum =2.d0*sum
>                                  dsum=2.d0*dsum
1019,1020c951,952
<      &                               (asumt*dqgb(ig,ijv,is,i,j) +         &
<      &                               dsumt*qgb(ig,ijv,is))
---
>      &                               (sum*dqgb(ig,ijv,is,i,j) +         &
>      &                               dsum*qgb(ig,ijv,is))
1035c967
< 
---
> !
1049,1051d980
< 
<                DEALLOCATE( dqgbt )
<                DEALLOCATE( qv )
1053c982
<                DO ir=1,dfftp%nnr
---
>                DO ir=1,nnr
1057d985
< 
1060,1063c988,990
< 
<                DO ig=1,ngm
<                   fp=v(nl(ig))+v(nlm(ig))
<                   fm=v(nl(ig))-v(nlm(ig))
---
>                DO ig=1,ng
>                   fp=v(np(ig))+v(nm(ig))
>                   fm=v(np(ig))-v(nm(ig))
1073c1000
< 
---
>       DEALLOCATE(dqgbt)
1074a1002
>       DEALLOCATE( qv )
1092c1020
<       USE mp_global,                ONLY: intra_bgrp_comm
---
>       USE mp_global,                ONLY: intra_image_comm
1094c1022,1023
<       USE uspp_param,               ONLY: nh, nhm, nvb
---
>       USE cvan,                     ONLY: nvb
>       USE uspp_param,               ONLY: nh, nhm
1095a1025
>       USE grid_dimensions,          ONLY: nr1, nr2, nr3, nr1x, nr2x, nr3x, nnr => nnrx
1097,1099c1027,1029
<       USE smallbox_gvec,                    ONLY: npb, nmb, ngb
<       USE gvect,                    ONLY: ngm, nl, nlm
<       USE cell_base,                ONLY: omega
---
>       USE gvecb,                    ONLY: npb, nmb, ngb
>       USE gvecp,                    ONLY: ng => ngm
>       USE cell_base,                ONLY: omega, ainv
1101c1031,1032
<       USE control_flags,            ONLY: iprint, iverbosity, tpre
---
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, nnrb => nnrbx
>       USE control_flags,            ONLY: iprint, iprsta, tpre
1103,1104c1034,1036
<       USE fft_interfaces,           ONLY: fwfft, invfft
<       USE fft_base,                 ONLY: dfftb, dfftp, dfftb
---
>       USE recvecs_indexes,          ONLY: np, nm
>       USE cp_interfaces,            ONLY: fwfft, invfft
>       USE fft_base,                 ONLY: dfftb, dfftp
1112,1113c1044,1045
<       REAL(DP),     INTENT(inout):: rhor(dfftp%nnr,nspin)
<       COMPLEX(DP),  INTENT(inout):: rhog(ngm,nspin)
---
>       REAL(DP),     INTENT(inout):: rhor(nnr,nspin)
>       COMPLEX(DP),  INTENT(inout):: rhog(ng,nspin)
1122,1127d1053
< #ifdef __OPENMP
<       INTEGER  :: itid, mytid, ntids
<       INTEGER  :: omp_get_thread_num, omp_get_num_threads
<       EXTERNAL :: omp_get_thread_num, omp_get_num_threads
< #endif
< 
1136c1062,1065
<       ALLOCATE( v( dfftp%nnr ) )
---
>       ALLOCATE( v( nnr ) )
>       ALLOCATE( qv( nnrb ) )
>       v (:) = (0.d0, 0.d0)
>       ALLOCATE( qgbt( ngb, 2 ) )
1138,1147d1066
<       ! private variable need to be initialized, otherwise
<       ! outside the parallel region they have an undetermined value
<       !
< #ifdef __OPENMP
<       mytid = 0
<       ntids = 1
<       itid  = 0
< #endif
<       iss   = 1
<       isa   = 1
1153,1159d1071
< 
< !$omp parallel default(none) &
< !$omp          shared(nvb, na, ngb, nh, rhovan, qgb, eigrb, dfftb, iverbosity, omegab, irb, v, &
< !$omp                 nmb, stdout, ci, npb, rhor, dfftp ) &
< !$omp          private(mytid, ntids, is, ia, nfft, ifft, iv, jv, ijv, sumrho, qgbt, ig, iss, isa, ca, &
< !$omp                  qv, itid, ir )
< 
1163,1176d1074
< !$omp workshare
<          v (:) = (0.d0, 0.d0)
< !$omp end workshare
< 
< #ifdef __OPENMP
<          mytid = omp_get_thread_num()  ! take the thread ID
<          ntids = omp_get_num_threads() ! take the number of threads
<          itid  = 0
< #endif
< 
<          ALLOCATE( qgbt( ngb, 2 ) )
<          ALLOCATE( qv( dfftb%nnr ) )
< 
< 
1179c1077
< #ifdef __MPI
---
> #ifdef __PARA
1183,1187c1081
<                IF ( dfftb%np3( isa ) <= 0 ) THEN
<                   isa = isa + nfft
<                   CYCLE
<                END IF
< 
---
>                IF ( dfftb%np3( isa ) <= 0 ) go to 15
1191,1193d1084
<                !
<                !  nfft=2 if two ffts at the same time are performed
<                !
1195d1085
<                IF( ia .EQ. na(is) ) nfft = 1
1198,1206c1088,1092
< #ifdef __OPENMP
<                IF ( mytid /= itid ) THEN
<                   isa = isa + nfft
<                   itid = MOD( itid + 1, ntids )
<                   CYCLE
<                ELSE
<                   itid = MOD( itid + 1, ntids )
<                END IF
< #endif
---
>                IF( ia .EQ. na(is) ) nfft = 1
> 
>                !
>                !  nfft=2 if two ffts at the same time are performed
>                !
1239a1126
>                CALL invfft('Box',qv,dfftb,isa)
1241d1127
<                CALL invfft( 'Box', qv, dfftb, isa )
1246c1132
<                IF( iverbosity > 2 ) THEN
---
>                IF(iprsta.GT.2) THEN
1251c1137
<      &                 omegab*DBLE(ca)/(dfftb%nr1*dfftb%nr2*dfftb%nr3)
---
>      &                 omegab*DBLE(ca)/(nr1b*nr2b*nr3b)
1255c1141
<      &                 omegab*AIMAG(ca)/(dfftb%nr1*dfftb%nr2*dfftb%nr3)
---
>      &                 omegab*AIMAG(ca)/(nr1b*nr2b*nr3b)
1262,1263c1148
< 
<                isa = isa + nfft
---
>   15           isa=isa+nfft
1267,1269d1151
< 
<          DEALLOCATE(qv)
<          DEALLOCATE(qgbt)
1273,1277c1155
< !$omp end parallel
< 
<          iss = 1
< 
<          DO ir=1,dfftp%nnr
---
>          DO ir=1,nnr
1280d1157
< 
1282c1159
<          IF( iverbosity > 2 ) THEN
---
>          IF(iprsta.GT.2) THEN
1285c1162
<             CALL mp_sum( ca, intra_bgrp_comm )
---
>             CALL mp_sum( ca, intra_image_comm )
1288c1165
<      &           ' rhov: int  n_v(r)  dr = ',omega*ca/(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      &           ' rhov: int  n_v(r)  dr = ',omega*ca/(nr1*nr2*nr3)
1293c1170
<          IF( iverbosity > 2 ) THEN
---
>          IF(iprsta.GT.2) THEN
1301,1302c1178,1179
<          DO ig = 1, ngm
<             rhog(ig,iss)=rhog(ig,iss)+v(nl(ig))
---
>          DO ig = 1, ng
>             rhog(ig,iss)=rhog(ig,iss)+v(np(ig))
1306c1183
<          IF( iverbosity > 2 ) WRITE( stdout,'(a,2f12.8)')                          &
---
>          IF(iprsta.GT.2) WRITE( stdout,'(a,2f12.8)')                          &
1315,1320d1191
< 
<          v (:) = (0.d0, 0.d0)
< 
<          ALLOCATE( qgbt( ngb, 2 ) )
<          ALLOCATE( qv( dfftb%nnr ) )
< 
1324c1195
< #ifdef __MPI
---
> #ifdef __PARA
1356c1227
<                IF( iverbosity > 2 ) THEN
---
>                IF(iprsta.GT.2) THEN
1361c1232
<      &                 omegab*DBLE(ca)/(dfftb%nr1*dfftb%nr2*dfftb%nr3)
---
>      &                 omegab*DBLE(ca)/(nr1b*nr2b*nr3b)
1365c1236
<      &                 omegab*AIMAG(ca)/(dfftb%nr1*dfftb%nr2*dfftb%nr3)
---
>      &                 omegab*AIMAG(ca)/(nr1b*nr2b*nr3b)
1376c1247
<          DO ir=1,dfftp%nnr
---
>          DO ir=1,nnr
1381c1252
<          IF( iverbosity > 2 ) THEN
---
>          IF(iprsta.GT.2) THEN
1383,1384c1254,1255
<             CALL mp_sum( ca, intra_bgrp_comm )
<             WRITE( stdout,'(a,2f12.8)') 'rhov:in n_v  ',omega*ca/(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>             CALL mp_sum( ca, intra_image_comm )
>             WRITE( stdout,'(a,2f12.8)') 'rhov:in n_v  ',omega*ca/(nr1*nr2*nr3)
1389c1260
<          IF( iverbosity > 2 ) THEN
---
>          IF(iprsta.GT.2) THEN
1400,1402c1271,1273
<          DO ig=1,ngm
<             fp=  v(nl(ig)) + v(nlm(ig))
<             fm=  v(nl(ig)) - v(nlm(ig))
---
>          DO ig=1,ng
>             fp=  v(np(ig)) + v(nm(ig))
>             fm=  v(np(ig)) - v(nm(ig))
1408,1410c1279,1281
<          IF( iverbosity > 2 ) THEN
<             WRITE( stdout,'(a,2f12.8,/,a,2f12.8)')                 &
<      &        ' rhov: n_v(g=0) up   = ',omega*DBLE (rhog(1,isup)), &
---
>          IF(iprsta.GT.2) WRITE( stdout,'(a,2f12.8)')                          &
>      &        ' rhov: n_v(g=0) up   = ',omega*DBLE (rhog(1,isup))
>          IF(iprsta.GT.2) WRITE( stdout,'(a,2f12.8)')                          &
1412,1414d1282
<          END IF
<          DEALLOCATE(qgbt)
<          DEALLOCATE( qv )
1417a1286
>       DEALLOCATE(qgbt)
1418a1288
>       DEALLOCATE( qv )
1434a1305
>       use grid_dimensions, ONLY: nr1, nr2, nr3, nr1x, nr2x, nnrx
1438,1439d1308
<       USE io_global,       ONLY: ionode
<       USE mp_global,       ONLY: intra_bgrp_comm, inter_bgrp_comm
1444c1313
<       real(DP) :: rhor( dfftp%nnr, nspin )
---
>       real(DP) :: rhor( nnrx, nspin )
1453,1455c1322
<       CALL read_rho_xml( filename, rhor(:,1), dfftp%nr1, dfftp%nr2, dfftp%nr3, &
<                          dfftp%nr1x, dfftp%nr2x, dfftp%ipp, dfftp%npp, &
<                          ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>       CALL read_rho_xml( filename, rhor(:,1), nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
1461,1463c1328
<          CALL read_rho_xml( filename, rhor(:,2), dfftp%nr1, dfftp%nr2, dfftp%nr3, &
<                             dfftp%nr1x, dfftp%nr2x, dfftp%ipp, dfftp%npp, &
<                             ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>          CALL read_rho_xml( filename, rhor(:,2), nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
1476c1341
<       subroutine old_write_rho( rhounit, nspin, rhor )
---
>       subroutine old_write_rho( rhounit, nspin, rhor, a1, a2, a3 )
1479c1344
< ! collect rhor(nnr,nspin) on first node and write to file
---
> ! collect rhor(nnrx,nspin) on first node and write to file
1482a1348
>       use grid_dimensions, only : nr1x, nr2x, nr3x, nnrx
1484c1350
<       USE mp_global,       ONLY : nproc_bgrp, intra_bgrp_comm
---
>       USE mp_global,       ONLY : nproc_image, intra_image_comm
1489d1354
<       USE cell_base,       ONLY : at, alat
1494c1359,1360
<       real(kind=DP), INTENT(IN) :: rhor( dfftp%nnr, nspin )
---
>       real(kind=DP), INTENT(IN) :: rhor( nnrx, nspin )
>       real(kind=DP), INTENT(IN) :: a1(3), a2(3), a3(3)
1508c1374
<          WRITE( rhounit, '(3(2X,I3))' ) dfftp%nr1x, dfftp%nr2x, dfftp%nr3x
---
>          WRITE( rhounit, '(3(2X,I3))' ) nr1x, nr2x, nr3x
1511,1513c1377,1379
<              ( DBLE(dfftp%nr1x-1) / DBLE(dfftp%nr1x) ) * at(1,1)*alat * bohr_radius_angs, &
<              ( DBLE(dfftp%nr2x-1) / DBLE(dfftp%nr2x) ) * at(2,2)*alat * bohr_radius_angs, &
<              ( DBLE(dfftp%nr3x-1) / DBLE(dfftp%nr3x) ) * at(3,3)*alat * bohr_radius_angs
---
>              ( DBLE( nr1x - 1 ) / DBLE( nr1x ) ) * a1(1) * bohr_radius_angs, &
>              ( DBLE( nr2x - 1 ) / DBLE( nr2x ) ) * a2(2) * bohr_radius_angs, &
>              ( DBLE( nr3x - 1 ) / DBLE( nr3x ) ) * a3(3) * bohr_radius_angs
1517c1383
<       COLLECT_CHARGE: IF( nproc_bgrp > 1 ) THEN
---
>       COLLECT_CHARGE: IF( nproc_image > 1 ) THEN
1519c1385
<          ALLOCATE( displs( nproc_bgrp ), recvcount( nproc_bgrp ) )
---
>          ALLOCATE( displs( nproc_image ), recvcount( nproc_image ) )
1521c1387
<          if (ionode) allocate(rhodist(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x))
---
>          if (ionode) allocate(rhodist(nr1x*nr2x*nr3x))
1523c1389
<          do proc=1,nproc_bgrp
---
>          do proc=1,nproc_image
1537c1403
<             call mp_gather( rhor(:,is), rhodist, recvcount, displs, ionode_id, intra_bgrp_comm )
---
>             call mp_gather( rhor(:,is), rhodist, recvcount, displs, ionode_id, intra_image_comm )
1542c1408
<                write( rhounit, '(F12.7)' ) (rhodist(ir),ir=1,dfftp%nr1x*dfftp%nr2x*dfftp%nr3x)
---
>                write( rhounit, '(F12.7)' ) (rhodist(ir),ir=1,nr1x*nr2x*nr3x)
1552c1418
<             WRITE( rhounit, '(F12.7)' ) ( ( rhor(ir,is), ir = 1, dfftp%nnr ), is = 1, nspin )
---
>             WRITE( rhounit, '(F12.7)' ) ( ( rhor(ir,is), ir = 1, nnrx ), is = 1, nspin )
1563,1564d1428
< 
< 
Only in ../../../ffn2_tsvdw_master/CPV: chargedensity.F90
Only in ../../../ffn2_tsvdw_master/CPV: chargedensity.o
Only in ../../../ffn2_tsvdw_master/CPV: compute_fes_grads.f90
Only in ../../../ffn2_tsvdw_master/CPV: compute_fes_grads.F90
Only in ../../../ffn2_tsvdw_master/CPV: compute_fes_grads.o
Only in ../../../ffn2_tsvdw_master/CPV: compute_scf.f90
Only in ../../../ffn2_tsvdw_master/CPV: compute_scf.F90
Only in ../../../ffn2_tsvdw_master/CPV: compute_scf.o
Only in ../../../ffn2_tsvdw_master/CPV: core.mod
Only in ../../../ffn2_tsvdw_master/CPV: cp_autopilot.F90
Only in ../../../ffn2_tsvdw_master/CPV: cp_autopilot.mod
Only in ../../../ffn2_tsvdw_master/CPV: cp_autopilot.o
Only in ../../../ffn2_tsvdw_master/CPV: cp_electronic_mass.mod
diff ./cp_emass.f90 ../../../ffn2_tsvdw_master/CPV/cp_emass.f90
31c31
<       USE control_flags, ONLY: iverbosity
---
>       USE control_flags, ONLY: iprsta
41c41
<          IF( iverbosity > 3 ) print *,i,' ema0bg(i) ',ema0bg(i)
---
>          IF( iprsta > 3 ) print *,i,' ema0bg(i) ',ema0bg(i)
Only in ../../../ffn2_tsvdw_master/CPV: cp_emass.F90
Only in ../../../ffn2_tsvdw_master/CPV: cp_emass.o
Only in ../../../ffn2_tsvdw_master/CPV: cp_fpmd.f90
Only in ../../../ffn2_tsvdw_master/CPV: cp_fpmd.F90
Only in ../../../ffn2_tsvdw_master/CPV: cp_fpmd.o
diff ./cp_interfaces.f90 ../../../ffn2_tsvdw_master/CPV/cp_interfaces.f90
2c2
< ! Copyright (C) 2002-2010 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
26a27
>    PUBLIC :: chkpstab
43a45,47
>    PUBLIC :: invfft
>    PUBLIC :: fwfft
> 
52d55
<    PUBLIC :: nlfl_bgrp
83a87,88
>    PUBLIC :: n_atom_wfc
>    !
86a92
>    PUBLIC :: print_projwfc
94,112d99
<    PUBLIC :: c_bgrp_expand
<    PUBLIC :: c_bgrp_pack
<    PUBLIC :: vofrho
<    PUBLIC :: enkin
<    PUBLIC :: newinit
<    PUBLIC :: prefor
<    PUBLIC :: denlcc
<    PUBLIC :: dotcsc
<    PUBLIC :: nlsm1
<    PUBLIC :: nlsm2_bgrp
<    PUBLIC :: calbec_bgrp
<    PUBLIC :: ennl
<    PUBLIC :: calrhovan
<    PUBLIC :: calbec
<    PUBLIC :: caldbec_bgrp
<    PUBLIC :: dennl
<    PUBLIC :: nlfq_bgrp
<    PUBLIC :: collect_bec
<    PUBLIC :: distribute_lambda
189a177,185
>    INTERFACE chkpstab
>       LOGICAL FUNCTION chkpstab_x(hg, xgtabmax)
>          USE kinds,              ONLY: DP
>          IMPLICIT NONE
>          REAL(DP), INTENT(IN) :: hg(:)
>          REAL(DP), INTENT(IN) :: xgtabmax
>       END FUNCTION
>    END INTERFACE
> 
197,198c193
<       LOGICAL FUNCTION check_tables_x( gmax )
<          USE kinds,              ONLY: DP
---
>       LOGICAL FUNCTION check_tables_x( )
200d194
<          REAL(DP), INTENT(OUT) :: gmax
221c215
<       SUBROUTINE compute_xgtab_x( xgmin, xgmax )
---
>       SUBROUTINE compute_xgtab_x( xgmin, xgmax, xgtabmax )
224c218
<          REAL(DP), INTENT(OUT)  :: xgmax, xgmin
---
>          REAL(DP), INTENT(OUT)  :: xgmax, xgmin, xgtabmax
243c237
<          ( nfi, c_bgrp, irb, eigrb, bec, dbec, rhovan, rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin, tstress, ndwwf )
---
>          ( nfi, c, irb, eigrb, bec, rhovan, rhor, rhog, rhos, enl, denl, ekin, dekin, tstress, ndwwf )
247c241
<          COMPLEX(DP) c_bgrp( :, : )
---
>          COMPLEX(DP) c( :, : )
251d244
<          REAL(DP) dbec(:,:,:,:)
254d246
<          REAL(DP) drhor(:,:,:,:)
256d247
<          COMPLEX(DP) drhog( :, :, :, : )
269,270c260,261
<          USE gvect,           ONLY: ngm
<          USE fft_base,        ONLY: dfftp
---
>          USE gvecp,           ONLY: ngm
>          USE grid_dimensions, ONLY: nnrx
274c265
<          real(DP)    :: gradr( dfftp%nnr, 3, nspin )
---
>          real(DP)    :: gradr( nnrx, 3, nspin )
281a273
>          USE grid_dimensions, ONLY: nnrx
289c281
<       SUBROUTINE readfile_x                                         &
---
>       SUBROUTINE readfile_cp                                         &
309c301
<       END SUBROUTINE readfile_x
---
>       END SUBROUTINE readfile_cp
314c306
<       SUBROUTINE writefile_x &
---
>       SUBROUTINE writefile_cp &
316c308
<       &       lambda,lambdam,descla,xnhe0,xnhem,vnhe,xnhp0,xnhpm,vnhp,nhpcl,nhpdim,ekincm,&
---
>       &       lambda,lambdam,xnhe0,xnhem,vnhe,xnhp0,xnhpm,vnhp,nhpcl,nhpdim,ekincm,&
319d310
<          USE descriptors,      ONLY: la_descriptor
327d317
<          TYPE(la_descriptor),  INTENT(IN) :: descla( : )
336c326
<       END SUBROUTINE writefile_x
---
>       END SUBROUTINE writefile_cp
342c332
<          ( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec_bgrp, c0_bgrp, cm_bgrp, fromscra, restart )
---
>          ( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec, c0, cm, fromscra, restart )
349,350c339,340
<          real(DP) :: bec_bgrp(:,:)
<          complex(DP) :: c0_bgrp(:,:), cm_bgrp(:,:)
---
>          real(DP) :: bec(:,:)
>          complex(DP) :: c0(:,:), cm(:,:)
357d346
< 
376a366,389
>    INTERFACE invfft
>       SUBROUTINE invfft_x( grid_type, f, dfft, ia )
>          USE fft_types,  only: fft_dlay_descriptor
>          USE kinds,      ONLY: DP
>          IMPLICIT NONE
>          INTEGER, OPTIONAL, INTENT(IN) :: ia
>          CHARACTER(LEN=*),  INTENT(IN) :: grid_type
>          TYPE(fft_dlay_descriptor), INTENT(IN) :: dfft
>          COMPLEX(DP) :: f(:)
>       END SUBROUTINE
>    END INTERFACE
> 
>    INTERFACE fwfft
>       SUBROUTINE fwfft_x( grid_type, f, dfft )
>          USE fft_types,  only: fft_dlay_descriptor
>          USE kinds,      ONLY: DP
>          IMPLICIT NONE
>          CHARACTER(LEN=*), INTENT(IN) :: grid_type
>          TYPE(fft_dlay_descriptor), INTENT(IN) :: dfft
>          COMPLEX(DP) :: f(:)
>       END SUBROUTINE
>    END INTERFACE
> 
> 
378c391
<       SUBROUTINE cp_eigs_x( nfi, lambdap, lambda, desc )
---
>       SUBROUTINE cp_eigs_x( nfi, lambdap, lambda )
380d392
<          USE descriptors,      ONLY: la_descriptor
384d395
<          TYPE(la_descriptor), INTENT(IN) :: desc( : )
410,411c421,422
<       SUBROUTINE ortho_x &
<          ( eigr, cp_bgrp, phi_bgrp, x0, descla, diff, iter, ccc, bephi, becp_bgrp )
---
>       SUBROUTINE ortho_cp &
>          ( eigr, cp, phi, ngwx, x0, descla, diff, iter, ccc, bephi, becp, nbsp, nspin, nupdwn, iupdwn)
413,417c424,431
<          USE descriptors,    ONLY: la_descriptor
<          IMPLICIT NONE
<          TYPE(la_descriptor),  INTENT(IN) :: descla( : )
<          COMPLEX(DP) :: eigr( :, : )
<          COMPLEX(DP) :: cp_bgrp( :, : ), phi_bgrp( :, : )
---
>          USE ions_base,      ONLY: nat
>          USE uspp,           ONLY: nkb
>          USE descriptors,    ONLY: descla_siz_
>          IMPLICIT NONE
>          INTEGER,    INTENT(IN)     :: ngwx, nbsp, nspin
>          INTEGER,    INTENT(IN)     :: nupdwn( nspin ), iupdwn( nspin )
>          INTEGER,     INTENT(IN)    :: descla( descla_siz_ , nspin )
>          COMPLEX(DP) :: cp(ngwx,nbsp), phi(ngwx,nbsp), eigr(ngwx,nat)
420,421c434
<          REAL(DP)    :: bephi(:,:)
<          REAL(DP)    :: becp_bgrp(:,:)
---
>          REAL(DP)    :: bephi(:,:), becp(:,:)
427c440
<          ( iopt, cp, ngwx, phi, becp_dist, qbecp, nkbx, bephi, qbephi, &
---
>          ( iopt, cp, ngwx, phi, becp, qbecp, nkbx, bephi, qbephi, &
430c443
<          USE descriptors,    ONLY: la_descriptor
---
>          USE descriptors,    ONLY: descla_siz_
436,437c449
<          REAL(DP)    :: bephi( :, : )
<          REAL(DP)    :: becp_dist(:,:)
---
>          REAL(DP)    :: bephi( :, : ), becp( :, : )
440c452
<          TYPE(la_descriptor),  INTENT(IN) :: descla
---
>          INTEGER,  INTENT(IN)  :: descla( descla_siz_ )
564c576
<       SUBROUTINE wave_rand_init_x( cm )
---
>       SUBROUTINE wave_rand_init_x( cm, n, noff )
566a579
>          INTEGER,     INTENT(IN)  :: n, noff
612c625
<          USE fft_base,         ONLY: dfftp
---
>          USE grid_dimensions,  ONLY: nr1, nr2, nr3
614,616c627,629
<          COMPLEX(DP) :: ei1( -dfftp%nr1 : dfftp%nr1, nat )
<          COMPLEX(DP) :: ei2( -dfftp%nr2 : dfftp%nr2, nat )
<          COMPLEX(DP) :: ei3( -dfftp%nr3 : dfftp%nr3, nat )
---
>          COMPLEX(DP) :: ei1( -nr1 : nr1, nat )
>          COMPLEX(DP) :: ei2( -nr2 : nr2, nat )
>          COMPLEX(DP) :: ei3( -nr3 : nr3, nat )
628c641
<            vnhh, xnhh0, vnhp, xnhp0, atot, ekin, epot, print_forces, print_stress,tstdout )
---
>            vnhh, xnhh0, vnhp, xnhp0, atot, ekin, epot, print_forces, print_stress )
645c658
<          LOGICAL, INTENT(IN) :: print_forces, print_stress, tstdout
---
>          LOGICAL, INTENT(IN) :: print_forces, print_stress
721c734
<          USE fft_base,           ONLY: dfftp
---
>          USE grid_dimensions,    ONLY: nr1, nr2, nr3
729,731c742,744
<          COMPLEX(DP) :: ei1(-dfftp%nr1:dfftp%nr1,nat)
<          COMPLEX(DP) :: ei2(-dfftp%nr2:dfftp%nr2,nat)
<          COMPLEX(DP) :: ei3(-dfftp%nr3:dfftp%nr3,nat)
---
>             COMPLEX(DP) :: ei1(-nr1:nr1,nat)
>          COMPLEX(DP) :: ei2(-nr2:nr2,nat)
>          COMPLEX(DP) :: ei3(-nr3:nr3,nat)
761a775,781
> 
>    INTERFACE n_atom_wfc
>       FUNCTION n_atom_wfc_x()
>          INTEGER n_atom_wfc_x
>       END FUNCTION
>    END INTERFACE
> 
771c791
<       SUBROUTINE set_evtot_x( c0, ctot, lambda, descla, iupdwn_tot, nupdwn_tot )
---
>       SUBROUTINE set_evtot_x( c0, ctot, lambda, iupdwn_tot, nupdwn_tot )
773d792
<          USE descriptors,      ONLY: la_descriptor
778d796
<          TYPE(la_descriptor), INTENT(IN) :: descla(:)
796c814
<          nfi, tfirst, tlast, b1, b2, b3, fion, c0_bgrp, cm_bgrp, phi_bgrp, enthal, enb, enbi, fccc, ccc, dt2bye, stress )
---
>          nfi, tfirst, tlast, b1, b2, b3, fion, enthal, enb, enbi, fccc, ccc, dt2bye, stress )
803d820
<          COMPLEX(DP)             :: c0_bgrp(:,:), cm_bgrp(:,:), phi_bgrp(:,:)
823c840
<       SUBROUTINE nlfh_x( stress, bec, dbec, lambda, descla )
---
>       SUBROUTINE nlfh_x( stress, bec, dbec, lambda )
825d841
<          USE descriptors,       ONLY: la_descriptor
830d845
<          TYPE(la_descriptor), INTENT(IN) :: descla(:)
834,846d848
<    INTERFACE nlfl_bgrp
<       SUBROUTINE nlfl_bgrp_x( bec_bgrp, becdr_bgrp, lambda, descla, fion )
<          USE kinds,             ONLY: DP
<          USE descriptors,       ONLY: la_descriptor
<          IMPLICIT NONE
<          REAL(DP) :: bec_bgrp(:,:), becdr_bgrp(:,:,:)
<          REAL(DP), INTENT(IN) :: lambda(:,:,:)
<          TYPE(la_descriptor), INTENT(IN) :: descla(:)
<          REAL(DP), INTENT(INOUT) :: fion(:,:)
<       END SUBROUTINE
<    END INTERFACE
< 
< 
848c850
<       SUBROUTINE print_lambda_x( lambda, descla, n, nshow, ccc, iunit )
---
>       SUBROUTINE print_lambda_x( lambda, n, nshow, ccc, iunit )
850d851
<          USE descriptors,       ONLY: la_descriptor
853d853
<          TYPE(la_descriptor), INTENT(IN) :: descla(:)
873,1027d872
<    END INTERFACE
< 
<    INTERFACE c_bgrp_expand
<     SUBROUTINE c_bgrp_expand_x( c_bgrp )
<       USE kinds,              ONLY: DP
<       IMPLICIT NONE
<       COMPLEX(DP) :: c_bgrp(:,:)
<     END SUBROUTINE c_bgrp_expand_x
<    END INTERFACE
<    INTERFACE c_bgrp_pack
<     SUBROUTINE c_bgrp_pack_x( c_bgrp )
<       USE kinds,              ONLY: DP
<       IMPLICIT NONE
<       COMPLEX(DP) :: c_bgrp(:,:)
<     END SUBROUTINE c_bgrp_pack_x
<    END INTERFACE
< 
<    INTERFACE vofrho
<       SUBROUTINE vofrho_x( nfi, rhor, drhor, rhog, drhog, rhos, rhoc, tfirst, tlast,           &
<      &     ei1, ei2, ei3, irb, eigrb, sfac, tau0, fion )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          LOGICAL     :: tlast, tfirst
<          INTEGER     :: nfi
<          REAL(DP)    :: rhor(:,:), drhor(:,:,:,:), rhos(:,:), fion(:,:)
<          REAL(DP)    :: rhoc(:), tau0(:,:)
<          ! COMPLEX(DP) ei1(-nr1:nr1,nat), ei2(-nr2:nr2,nat), ei3(-nr3:nr3,nat)
<          COMPLEX(DP) :: ei1(:,:), ei2(:,:), ei3(:,:)
<          COMPLEX(DP) :: eigrb(:,:)
<          COMPLEX(DP) :: rhog(:,:), drhog(:,:,:,:)
<          COMPLEX(DP) :: sfac(:,:)
<          INTEGER     :: irb(:,:)
<       END SUBROUTINE vofrho_x
<    END INTERFACE
< 
<    INTERFACE enkin
<       FUNCTION enkin_x( c, f, n )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN) :: n
<          COMPLEX(DP), INTENT(IN) :: c( :, : )
<          REAL(DP),    INTENT(IN) :: f( : )
<          REAL(DP) :: enkin_x
<       END FUNCTION enkin_x
<    END INTERFACE 
< 
<    INTERFACE newinit
<       SUBROUTINE newinit_x( h, iverbosity )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          REAL(DP),    INTENT(IN) :: h( 3, 3 )
<          INTEGER,     INTENT(IN) :: iverbosity
<       END SUBROUTINE newinit_x
<    END INTERFACE
< 
<    INTERFACE prefor
<       SUBROUTINE prefor_x( eigr, betae )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          COMPLEX(DP), INTENT(IN) :: eigr( :, : ) 
<          COMPLEX(DP), INTENT(OUT) :: betae( :, : )
<       END SUBROUTINE prefor_x
<    END INTERFACE
< 
<    INTERFACE denlcc
<       SUBROUTINE denlcc_x( nnr, nspin, vxcr, sfac, drhocg, dcc )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN) :: nnr, nspin
<          REAL(DP),    INTENT(IN) :: vxcr( :, : )
<          COMPLEX(DP), INTENT(IN) :: sfac( :, : ) 
<          REAL(DP),    INTENT(IN) :: drhocg( :, : ) 
<          REAL(DP), INTENT(OUT) ::  dcc( :, : )
<       END SUBROUTINE denlcc_x
<    END INTERFACE
< 
<    INTERFACE dotcsc
<       SUBROUTINE dotcsc_x( eigr, cp, ngw, n )
<          USE kinds, ONLY: dp
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN) :: ngw, n
<          COMPLEX(DP), INTENT(IN) :: eigr(:,:), cp(:,:)
<       END SUBROUTINE dotcsc_x
<    END INTERFACE
< 
<    INTERFACE nlsm1
<       SUBROUTINE nlsm1_x ( n, nspmn, nspmx, eigr, c, becp )
<          USE kinds,      ONLY : DP
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN)  :: n, nspmn, nspmx
<          COMPLEX(DP), INTENT(IN)  :: eigr( :, : ), c( :, : )
<          REAL(DP),    INTENT(OUT) :: becp( :, : )
<       END SUBROUTINE nlsm1_x 
<    END INTERFACE
< 
<    INTERFACE nlsm2_bgrp
<       SUBROUTINE  nlsm2_bgrp_x( ngw, nkb, eigr, c_bgrp, becdr_bgrp, nbspx_bgrp, nbsp_bgrp )
<          USE kinds,      ONLY : DP
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN)  :: ngw, nkb, nbspx_bgrp, nbsp_bgrp
<          COMPLEX(DP), INTENT(IN)  :: eigr( :, : ), c_bgrp( :, : )
<          REAL(DP),    INTENT(OUT) :: becdr_bgrp( :, :, : )
<       END SUBROUTINE nlsm2_bgrp_x
<    END INTERFACE
< 
<    INTERFACE calbec_bgrp
<       SUBROUTINE calbec_bgrp_x ( nspmn, nspmx, eigr, c_bgrp, bec_bgrp )
<          USE kinds,      ONLY : DP
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN)  :: nspmn, nspmx
<          COMPLEX(DP), INTENT(IN)  :: eigr( :, : ), c_bgrp( :, : )
<          REAL(DP),    INTENT(OUT) :: bec_bgrp( :, : )
<       END SUBROUTINE calbec_bgrp_x 
<    END INTERFACE
< 
<    INTERFACE ennl
<       SUBROUTINE ennl_x( ennl_val, rhovan, bec_bgrp )
<          USE kinds,              ONLY: DP
<          IMPLICIT NONE
<          REAL(DP), INTENT(OUT) :: ennl_val
<          REAL(DP), INTENT(OUT) :: rhovan( :, :, : )
<          REAL(DP), INTENT(IN)  :: bec_bgrp( :, : )
<       END SUBROUTINE ennl_x
<    END INTERFACE
< 
<    INTERFACE calrhovan
<       SUBROUTINE calrhovan_x( rhovan, bec, iwf )
<          USE kinds,              ONLY: DP
<          IMPLICIT NONE
<          REAL(DP), INTENT(OUT) :: rhovan( :, :, : )
<          REAL(DP), INTENT(IN)  :: bec( :, : )
<          INTEGER,  INTENT(IN)  :: iwf
<       END SUBROUTINE calrhovan_x
<    END INTERFACE
< 
<    INTERFACE calbec
<       SUBROUTINE calbec_x( nspmn, nspmx, eigr, c, bec )
<          USE kinds,              ONLY: DP
<          IMPLICIT NONE
<          INTEGER,     INTENT(IN)  ::  nspmn, nspmx
<          REAL(DP),    INTENT(OUT) ::  bec( :, : )
<          COMPLEX(DP), INTENT(IN)  ::  c( :, : ), eigr( :, : )
<       END SUBROUTINE calbec_x
<    END INTERFACE
< 
<    INTERFACE caldbec_bgrp
<       SUBROUTINE caldbec_bgrp_x( eigr, c_bgrp, dbec, descla )
<          USE kinds,              ONLY: DP
<          USE descriptors,        ONLY: la_descriptor
<          IMPLICIT NONE
<          COMPLEX(DP), INTENT(IN)  ::  c_bgrp( :, : ), eigr( :, : )
<          REAL(DP),    INTENT(OUT) ::  dbec( :, :, :, : )
<          TYPE(la_descriptor), INTENT(IN) :: descla( : )
<       END SUBROUTINE caldbec_bgrp_x
<    END INTERFACE
1029,1039d873
<    INTERFACE dennl
<       SUBROUTINE dennl_x( bec_bgrp, dbec, drhovan, denl, descla )
<          USE kinds,              ONLY: DP
<          USE descriptors,        ONLY: la_descriptor
<          IMPLICIT NONE
<          REAL(DP),    INTENT(IN)  ::  dbec( :, :, :, : )
<          REAL(DP),    INTENT(IN)  ::  bec_bgrp( :, : )
<          REAL(DP),    INTENT(OUT) ::  drhovan( :, :, :, :, : )
<          REAL(DP),    INTENT(OUT) ::  denl( 3, 3 )
<          TYPE(la_descriptor), INTENT(IN) :: descla( : )
<       END SUBROUTINE dennl_x
1041,1121d874
< 
<    INTERFACE nlfq_bgrp
<       SUBROUTINE nlfq_bgrp_x( c_bgrp, eigr, bec_bgrp, becdr_bgrp, fion )
<          USE kinds,              ONLY: DP
<          IMPLICIT NONE
<          COMPLEX(DP), INTENT(IN)  ::  c_bgrp( :, : ), eigr( :, : )
<          REAL(DP),    INTENT(IN)  ::  bec_bgrp( :, : )
<          REAL(DP),    INTENT(OUT) ::  becdr_bgrp( :, :, : )
<          REAL(DP),    INTENT(OUT) ::  fion( :, : )
<       END SUBROUTINE nlfq_bgrp_x
<    END INTERFACE
< 
<    INTERFACE collect_bec
<       SUBROUTINE collect_bec_x( bec_repl, bec_dist, desc, nspin )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(OUT) :: bec_repl(:,:)
<          REAL(DP), INTENT(IN)  :: bec_dist(:,:)
<          TYPE(la_descriptor), INTENT(IN)  :: desc(:)
<          INTEGER,  INTENT(IN)  :: nspin
<       END SUBROUTINE collect_bec_x
<    END INTERFACE
< 
<    INTERFACE distribute_lambda
<       SUBROUTINE distribute_lambda_x( lambda_repl, lambda_dist, desc )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(IN)  :: lambda_repl(:,:)
<          REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
<          TYPE(la_descriptor), INTENT(IN)  :: desc
<       END SUBROUTINE distribute_lambda_x
<    END INTERFACE
< 
<    PUBLIC :: collect_lambda
<    INTERFACE collect_lambda
<       SUBROUTINE collect_lambda_x( lambda_repl, lambda_dist, desc )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(OUT) :: lambda_repl(:,:)
<          REAL(DP), INTENT(IN)  :: lambda_dist(:,:)
<          TYPE(la_descriptor), INTENT(IN)  :: desc
<       END SUBROUTINE collect_lambda_x
<    END INTERFACE
< 
<    PUBLIC :: setval_lambda
<    INTERFACE setval_lambda
<       SUBROUTINE setval_lambda_x( lambda_dist, i, j, val, desc )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
<          INTEGER,  INTENT(IN)  :: i, j
<          REAL(DP), INTENT(IN)  :: val
<          TYPE(la_descriptor), INTENT(IN)  :: desc
<       END SUBROUTINE setval_lambda_x
<    END INTERFACE
< 
< 
<    PUBLIC :: distribute_zmat
<    INTERFACE distribute_zmat
<       SUBROUTINE distribute_zmat_x( zmat_repl, zmat_dist, desc )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(IN)  :: zmat_repl(:,:)
<          REAL(DP), INTENT(OUT) :: zmat_dist(:,:)
<          TYPE(la_descriptor), INTENT(IN)  :: desc
<       END SUBROUTINE distribute_zmat_x
<    END INTERFACE
< 
<    PUBLIC :: collect_zmat
<    INTERFACE collect_zmat
<       SUBROUTINE collect_zmat_x( zmat_repl, zmat_dist, desc )
<          USE kinds,       ONLY : DP
<          USE descriptors, ONLY : la_descriptor
<          REAL(DP), INTENT(OUT) :: zmat_repl(:,:)
<          REAL(DP), INTENT(IN)  :: zmat_dist(:,:)
<          TYPE(la_descriptor), INTENT(IN)  :: desc
<       END SUBROUTINE collect_zmat_x
<    END INTERFACE
< 
< 
< !=----------------------------------------------------------------------------=!
Only in ../../../ffn2_tsvdw_master/CPV: cp_interfaces.F90
Only in ../../../ffn2_tsvdw_master/CPV: cp_interfaces.mod
Only in ../../../ffn2_tsvdw_master/CPV: cp_interfaces.o
diff ./cplib.f90 ../../../ffn2_tsvdw_master/CPV/cplib.f90
2c2
< ! Copyright (C) 2002-2010 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2007 Quantum ESPRESSO group
6a7,34
> !
> !
> !-----------------------------------------------------------------------
>       SUBROUTINE atomic_wfc( eigr, n_atomic_wfc, wfc )
> !-----------------------------------------------------------------------
> !
> ! Compute atomic wavefunctions in G-space
> !
>       USE kinds,              ONLY: DP
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart, g, gx
>       USE ions_base,          ONLY: nsp, na, nat
>       USE cell_base,          ONLY: tpiba
>       USE atom,               ONLY: rgrid
>       USE uspp_param,         ONLY: upf
> !
>       IMPLICIT NONE
>       INTEGER,     INTENT(in) :: n_atomic_wfc
>       COMPLEX(DP), INTENT(in) :: eigr( ngw, nat )
>       COMPLEX(DP), INTENT(out):: wfc( ngw, n_atomic_wfc )
> !
>       INTEGER :: natwfc, ndm, is, ia, ir, nb, l, m, lm, i, lmax_wfc, isa
>       REAL(DP), ALLOCATABLE ::  ylm(:,:), q(:), jl(:), vchi(:), chiq(:)
> !
> ! calculate max angular momentum required in wavefunctions
> !
>       IF( .NOT. ALLOCATED( rgrid ) ) &
>          CALL errore( ' atomic_wfc ', ' rgrid not allocated ', 1 )
8,27c36,91
< !=----------------------------------------------------------------------------=!
<         SUBROUTINE ecutoffs_setup( ecutwfc_, ecutrho_, ecfixed_, qcutz_, &
<                                    q2sigma_, refg_ )
< !------------------------------------------------------------------------------! 
<           USE kinds,           ONLY: DP
<           USE constants,       ONLY: eps8
<           USE gvecw,           ONLY: ecutwfc
<           USE gvecw,           ONLY: ecfixed, qcutz, q2sigma
<           USE gvect,           ONLY: ecutrho
<           USE gvecs,           ONLY: ecuts, dual, doublegrid
<           USE pseudopotential, only: tpstab
<           USE io_global,       only: stdout, ionode
<           USE uspp,            only: okvan
<           use betax,           only: mmx, refg
< 
<           IMPLICIT NONE
<           REAL(DP), INTENT(IN) ::  ecutwfc_, ecutrho_, ecfixed_, qcutz_, &
<                                    q2sigma_, refg_
< 
<           ecutwfc = ecutwfc_
---
>       lmax_wfc=-1
>       DO is = 1,nsp
>          lmax_wfc = MAX ( lmax_wfc, MAXVAL (upf(is)%lchi(1:upf(is)%nwfc) ) )
>       ENDDO
>       !
>       ALLOCATE(ylm(ngw,(lmax_wfc+1)**2))
>       !
>       CALL ylmr2 ((lmax_wfc+1)**2, ngw, gx, g, ylm)
>       ndm = MAXVAL(rgrid(1:nsp)%mesh)
>       !
>       ALLOCATE(jl(ndm), vchi(ndm))
>       ALLOCATE(q(ngw), chiq(ngw))
> !
>       DO i=1,ngw
>          q(i) = SQRT(g(i))*tpiba
>       END DO
> !
>       natwfc=0
>       isa   = 0
>       DO is=1,nsp
>          !
>          !   radial fourier transform of the chi functions
>          !   NOTA BENE: chi is r times the radial part of the atomic wavefunction
>          !
>          DO nb = 1,upf(is)%nwfc
>             l = upf(is)%lchi(nb)
>             DO i=1,ngw
>                CALL sph_bes (rgrid(is)%mesh, rgrid(is)%r, q(i), l, jl)
>                DO ir=1,rgrid(is)%mesh
>                   vchi(ir) = upf(is)%chi(ir,nb)*rgrid(is)%r(ir)*jl(ir)
>                ENDDO
>                CALL simpson_cp90(rgrid(is)%mesh,vchi,rgrid(is)%rab,chiq(i))
>             ENDDO
>             !
>             !   multiply by angular part and structure factor
>             !   NOTA BENE: the factor i^l MUST be present!!!
>             !
>             DO m = 1,2*l+1
>                lm = l**2 + m
>                DO ia = 1 + isa, na(is) + isa
>                   natwfc = natwfc + 1
>                   wfc(:,natwfc) = (0.d0,1.d0)**l * eigr(:,ia)* ylm(:,lm)*chiq(:)
>                ENDDO
>             ENDDO
>          ENDDO
>          isa = isa + na(is)
>       ENDDO
> !
>       IF (natwfc.NE.n_atomic_wfc)                                       &
>      &     CALL errore('atomic_wfc','unexpected error',natwfc)
> !
>       DEALLOCATE(q, chiq, vchi, jl, ylm)
> !
>       RETURN
>       END SUBROUTINE atomic_wfc
> !
29,40c93,125
<           IF ( ecutrho_ <= 0.D0 ) THEN
<              !
<              dual = 4.D0
<              !
<           ELSE
<              !
<              dual = ecutrho_ / ecutwfc
<              !
<              IF ( dual <= 1.D0 ) &
<                 CALL errore( ' ecutoffs_setup ', ' invalid dual? ', 1 )
<              !
<           END IF
---
> !-----------------------------------------------------------------------
> FUNCTION n_atom_wfc_x( )
> !----------------------------------------------------------------------------
>   !
>   ! ... Find max number of bands needed
>   !
>   USE ions_base,        ONLY : na, nsp
>   USE kinds,            ONLY : DP
>   USE uspp_param,       ONLY : upf
>   !
>   IMPLICIT NONE
>   !
>   INTEGER  :: n_atom_wfc_x
>   INTEGER  :: is, n
>   !
>   n_atom_wfc_x = 0
>   !
>   DO is = 1, nsp
>      !
>      DO n = 1, upf(is)%nwfc
>         !
>         IF ( upf(is)%oc(n) >= 0.D0 ) THEN
>            !
>            n_atom_wfc_x = n_atom_wfc_x + na(is) * ( 2*upf(is)%lchi(n) + 1 )
>            !
>         END IF
>         !
>      END DO
>      !
>   END DO
>   !
>   RETURN
> END FUNCTION
42,66c127
<           doublegrid = ( dual > 4.D0 )
<           IF ( doublegrid .AND. .NOT. okvan ) &
<              CALL errore( 'setup', 'No USPP: set ecutrho=4*ecutwfc', 1 )
<           ecutrho = dual * ecutwfc
<           !
<           IF ( doublegrid ) THEN
<              !
<              ecuts = 4.D0 * ecutwfc
<              !
<           ELSE
<              !
<              ecuts = ecutrho
<              !
<           END IF
<           !
<           ecfixed = ecfixed_
<           qcutz   = qcutz_
<           q2sigma = q2sigma_
< 
<           IF( refg_ < 0.0001d0 ) THEN
<              tpstab = .FALSE.
<              refg   = 0.05d0
<           ELSE
<              refg   = refg_
<           END IF
---
> !
68c129,163
<           CALL set_interpolation_table_size( mmx, refg, ecutrho )
---
> !-----------------------------------------------------------------------
>    FUNCTION cscnorm( bec, nkbx, cp, ngwx, i, n )
> !-----------------------------------------------------------------------
> !     requires in input the updated bec(i)
> !
>       USE ions_base,          ONLY: na
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart
>       USE cvan,               ONLY: ish, nvb
>       USE uspp_param,         ONLY: nh
>       USE uspp,               ONLY: qq
>       USE mp,                 ONLY: mp_sum
>       USE mp_global,          ONLY: intra_image_comm
>       USE kinds,              ONLY: DP
> !
>       IMPLICIT NONE
>       !
>       INTEGER, INTENT(IN) :: i, n
>       INTEGER, INTENT(IN) :: ngwx, nkbx
>       REAL(DP)    :: bec( nkbx, n )
>       COMPLEX(DP) :: cp( ngwx, n )
>       !
>       REAL(DP) :: cscnorm
>       !
>       INTEGER ig, is, iv, jv, ia, inl, jnl
>       REAL(DP) rsum
>       REAL(DP), ALLOCATABLE:: temp(:)
> !
> !
>       ALLOCATE(temp(ngw))
>       DO ig=1,ngw
>          temp(ig)=DBLE(CONJG(cp(ig,i))*cp(ig,i))
>       END DO
>       rsum=2.d0*SUM(temp)
>       IF (gstart == 2) rsum=rsum-temp(1)
70,71c165
<           RETURN
<         END SUBROUTINE ecutoffs_setup
---
>       CALL mp_sum( rsum, intra_image_comm )
72a167,208
>       DEALLOCATE(temp)
> !
>       DO is=1,nvb
>          DO iv=1,nh(is)
>             DO jv=1,nh(is)
>                IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN 
>                   DO ia=1,na(is)
>                      inl=ish(is)+(iv-1)*na(is)+ia
>                      jnl=ish(is)+(jv-1)*na(is)+ia
>                      rsum = rsum +                                        &
>      &                    qq(iv,jv,is)*bec(inl,i)*bec(jnl,i)
>                   END DO
>                ENDIF
>             END DO
>          END DO
>       END DO
> !
>       cscnorm=SQRT(rsum)
> !
>       RETURN
>       END FUNCTION cscnorm
> !
> !
> !-----------------------------------------------------------------------
>       SUBROUTINE denlcc( nnr, nspin, vxcr, sfac, drhocg, dcc )
> !-----------------------------------------------------------------------
> !
> ! derivative of non linear core correction exchange energy wrt cell 
> ! parameters h 
> ! Output in dcc
> !
>       USE kinds,              ONLY: DP
>       USE ions_base,          ONLY: nsp
>       USE reciprocal_vectors, ONLY: gstart, gx, ngs, g, ngm
>       USE recvecs_indexes,    ONLY: np
>       USE cell_base,          ONLY: omega, ainv, tpiba2
>       USE mp,                 ONLY: mp_sum
>       USE mp_global,          ONLY: intra_image_comm
>       USE uspp_param,         ONLY: upf
>       USE grid_dimensions,    ONLY: nr1, nr2, nr3, nr1x, nr2x, nr3x
>       USE cp_interfaces,      ONLY: fwfft
>       USE fft_base,           ONLY: dfftp
74,89c210
<         SUBROUTINE set_interpolation_table_size( mmx, refg, gmax )
<           USE control_flags,   only: thdyn
<           USE kinds,           only: DP
<           IMPLICIT NONE
<           INTEGER, INTENT(OUT) :: mmx
<           REAL(DP), INTENT(IN) :: refg
<           REAL(DP), INTENT(IN) :: gmax
<           IF( thdyn ) THEN
<              !  ... a larger table is used when cell is moving to allow 
<              !  ... large volume fluctuation
<              mmx  = NINT( 2.0d0 * gmax / refg )
<           ELSE
<              mmx  = NINT( 1.2d0 * gmax / refg )
<           END IF
<           RETURN
<         END SUBROUTINE set_interpolation_table_size
---
>       IMPLICIT NONE
90a212
>       ! input
92c214,217
<         SUBROUTINE gcutoffs_setup( alat, tk_inp, nk_inp, kpoints_inp )
---
>       INTEGER, INTENT(IN)   :: nnr, nspin
>       REAL(DP)              :: vxcr( nnr, nspin )
>       COMPLEX(DP)           :: sfac( ngs, nsp )
>       REAL(DP)              :: drhocg( ngm, nsp )
94,95c219
< !  (describe briefly what this routine does...)
< !  ----------------------------------------------
---
>       ! output
97,102c221
<           USE kinds, ONLY: DP
<           USE gvecw, ONLY: ecutwfc,  gcutw
<           USE gvect, ONLY: ecutrho,  gcutm
<           USE gvecs, ONLY: ecuts, gcutms
<           USE gvecw, ONLY: ekcut, gkcut
<           USE constants, ONLY: eps8, pi
---
>       REAL(DP), INTENT(OUT) ::  dcc(3,3)
104c223
<           IMPLICIT NONE
---
>       ! local
106,110c225,256
< ! ...     declare subroutine arguments
<           REAL(DP), INTENT(IN) :: alat
<           LOGICAL, INTENT(IN) :: tk_inp
<           INTEGER, INTENT(IN) :: nk_inp
<           REAL(DP), INTENT(IN) :: kpoints_inp(3,*)
---
>       INTEGER     :: i, j, ig, is
>       COMPLEX(DP) :: srhoc
>       REAL(DP)    :: vxcc
>       !
>       COMPLEX(DP), ALLOCATABLE :: vxc( : )
> !
>       dcc = 0.0d0
>       !
>       ALLOCATE( vxc( nnr ) )
>       !
>       vxc(:) = vxcr(:,1)
>       !
>       IF( nspin > 1 ) vxc(:) = vxc(:) + vxcr(:,2)
>       !
>       CALL fwfft( 'Dense', vxc, dfftp )
>       !
>       DO i=1,3
>          DO j=1,3
>             DO ig = gstart, ngs
>                srhoc = 0.0d0
>                DO is = 1, nsp
>                  IF( upf(is)%nlcc ) srhoc = srhoc + sfac( ig, is ) * drhocg( ig, is )
>                ENDDO
>                vxcc = DBLE( CONJG( vxc( np( ig ) ) ) * srhoc ) / SQRT( g( ig ) * tpiba2 )
>                dcc(i,j) = dcc(i,j) + vxcc * &
>      &                      2.d0 * tpiba2 * gx(i,ig) *                  &
>      &                    (gx(1,ig)*ainv(j,1) +                         &
>      &                     gx(2,ig)*ainv(j,2) +                         &
>      &                     gx(3,ig)*ainv(j,3) )
>             ENDDO
>          ENDDO
>       ENDDO
112,115c258
< ! ...     declare other variables
<           INTEGER   :: i
<           REAL(DP) :: kcut, ksq
<           REAL(DP) :: tpiba
---
>       DEALLOCATE( vxc )
117,118c260
< !  end of declarations
< !  ----------------------------------------------
---
>       dcc = dcc * omega
120c262
< ! ...   Set Values for the cutoff
---
>       CALL mp_sum( dcc( 1:3, 1:3 ), intra_image_comm )
121a264,265
>       RETURN
>       END SUBROUTINE denlcc
123,125d266
<           IF( alat < eps8 ) THEN
<             CALL errore(' cut-off setup ', ' alat too small ', 0)
<           END IF
127d267
<           tpiba = 2.0d0 * pi / alat 
129c269,298
<           ! ...  Constant cutoff simulation parameters
---
> !-----------------------------------------------------------------------
>       SUBROUTINE dotcsc( eigr, cp, ngw, n )
> !-----------------------------------------------------------------------
> !
>       USE kinds,              ONLY: DP
>       USE ions_base,          ONLY: na, nsp, nat
>       USE io_global,          ONLY: stdout
>       USE reciprocal_vectors, ONLY: gstart
>       USE cvan,               ONLY: ish, nvb
>       USE uspp,               ONLY: nkb, qq
>       USE uspp_param,         ONLY: nh
>       USE mp,                 ONLY: mp_sum
>       USE mp_global,          ONLY: intra_image_comm
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: ngw, n
>       COMPLEX(DP) ::  eigr(ngw,nat), cp(ngw,n)
> ! local variables
>       REAL(DP) rsum, csc(n) ! automatic array
>       COMPLEX(DP) temp(ngw) ! automatic array
>  
>       REAL(DP), ALLOCATABLE::  becp(:,:)
>       INTEGER i,kmax,nnn,k,ig,is,ia,iv,jv,inl,jnl
> !
>       ALLOCATE(becp(nkb,n))
> !
> !     < beta | phi > is real. only the i lowest:
> !
>       nnn = MIN( 12, n )
131,141c300,306
<           gcutw = ecutwfc / tpiba**2  ! wave function cut-off
<           gcutm = ecutrho / tpiba**2  ! potential cut-off
<           gcutms= ecuts   / tpiba**2  ! smooth mesh cut-off
< 
<           kcut = 0.0_DP
<           IF ( tk_inp ) THEN
< ! ...       augment plane wave cutoff to include all k+G's
<             DO i = 1, nk_inp
< ! ...         calculate modulus
<               ksq = kpoints_inp( 1, i ) ** 2 + kpoints_inp( 2, i ) ** 2 + kpoints_inp( 3, i ) ** 2
<               IF ( ksq > kcut ) kcut = ksq
---
>       DO i = nnn, 1, -1
>          kmax = i
>          CALL nlsm1(i,1,nvb,eigr,cp,becp)
> !
>          DO k=1,kmax
>             DO ig=1,ngw
>                temp(ig)=CONJG(cp(ig,k))*cp(ig,i)
143,154c308,310
<           END IF
< 
<           gkcut = ( sqrt( kcut ) + sqrt( gcutw ) ) ** 2
< 
<           ekcut = gkcut * tpiba ** 2
< 
<           RETURN
<         END SUBROUTINE gcutoffs_setup
< 
< !  ----------------------------------------------
< 
<       SUBROUTINE cutoffs_print_info()
---
>             csc(k)=2.d0*DBLE(SUM(temp))
>             IF (gstart == 2) csc(k)=csc(k)-DBLE(temp(1))
>          END DO
156c312
<         !  Print out information about different cut-offs
---
>          CALL mp_sum( csc( 1:kmax ), intra_image_comm )
158,164c314,339
<         USE gvecw, ONLY: ecutwfc,  gcutw
<         USE gvect, ONLY: ecutrho,  gcutm
<         USE gvecw, ONLY: ecfixed, qcutz, q2sigma
<         USE gvecw, ONLY: ekcut, gkcut
<         USE gvecs, ONLY: ecuts, gcutms
<         use betax, only: mmx, refg
<         USE io_global, ONLY: stdout
---
>          DO k=1,kmax
>             rsum=0.d0
>             DO is=1,nvb
>                DO iv=1,nh(is)
>                   DO jv=1,nh(is)
>                      DO ia=1,na(is)
>                         inl=ish(is)+(iv-1)*na(is)+ia
>                         jnl=ish(is)+(jv-1)*na(is)+ia
>                         rsum = rsum +                                    &
>      &                   qq(iv,jv,is)*becp(inl,i)*becp(jnl,k)
>                      END DO
>                   END DO
>                END DO
>             END DO
>             csc(k)=csc(k)+rsum
>          END DO
> !
>          WRITE( stdout,'("dotcsc =",12f18.15)') (csc(k),k=1,i)
> !
>       END DO
>       WRITE( stdout,*)
> !
>       DEALLOCATE(becp)
> !
>       RETURN
>       END SUBROUTINE dotcsc
166,170d340
<         WRITE( stdout, 100 ) ecutwfc, ecutrho, ecuts, sqrt(gcutw), &
<                              sqrt(gcutm), sqrt(gcutms)
<         IF( qcutz > 0.0d0 ) THEN
<           WRITE( stdout, 150 ) qcutz, q2sigma, ecfixed
<         END IF
172c342,360
<         WRITE( stdout,200) refg, mmx
---
> !-----------------------------------------------------------------------
>    SUBROUTINE dotcsv( csv, eigr, c, v, ngw )
> !-----------------------------------------------------------------------
> !
>       USE kinds,              ONLY: DP
>       USE ions_base,          ONLY: na, nsp, nat
>       USE io_global,          ONLY: stdout
>       USE reciprocal_vectors, ONLY: gstart
>       USE cvan,               ONLY: ish, nvb
>       USE uspp,               ONLY: nkb, qq
>       USE uspp_param,         ONLY: nh
>       USE mp,                 ONLY: mp_sum
>       USE mp_global,          ONLY: intra_image_comm
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: ngw
>       COMPLEX(DP) ::  eigr(ngw,nat), c(ngw), v(ngw)
>       REAL(DP), INTENT(OUT) ::  csv
174,222c362,380
< 100     FORMAT(/,3X,'Energy Cut-offs',/ &
<                 ,3X,'---------------',/ &
<                 ,3X,'Ecutwfc = ',F6.1,' Ry,   ', 3X,'Ecutrho = ',F6.1,' Ry,   ', 3X,'Ecuts = ',F6.1,' Ry',/ &
<                 ,3X,'Gcutwfc = ',F6.1,'     , ', 3X,'Gcutrho = ',F6.1,'       ', 3X,'Gcuts = ',F6.1)
< 150     FORMAT(  3X,'modified kinetic energy functional, with parameters:',/,   &
<                  3X,'ecutz = ',f8.4,'  ecsig = ', f7.4,'  ecfix = ',f6.2)
< 200     FORMAT(  3X,'NOTA BENE: refg, mmx = ', f10.6,I6 )
< 
<         RETURN
<       END SUBROUTINE cutoffs_print_info
< 
< !  ----------------------------------------------
< 
<       SUBROUTINE orthogonalize_info( )
<         USE control_flags, ONLY: ortho_eps, ortho_max
<         USE io_global, ONLY: stdout
<         IMPLICIT NONE
<            WRITE(stdout, 585)
<            WRITE(stdout, 511) ortho_eps, ortho_max
<   511   FORMAT(   3X,'Orthog. with lagrange multipliers : eps = ',E10.2, ',  max = ',I3)
<   585   FORMAT(   3X,'Eigenvalues calculated without the kinetic term contribution')
<         RETURN
<       END SUBROUTINE orthogonalize_info
< 
< 
< !  ----------------------------------------------
< 
< 
<       SUBROUTINE electrons_print_info( )
< 
<           USE kinds, ONLY: DP
<           USE electrons_base, ONLY: nbnd, nspin, nel, nelt, nupdwn, iupdwn, &
<                                     f, qbac
<           USE io_global, ONLY: stdout
<           USE ions_base, ONLY: zv, nsp, na
< 
<           IMPLICIT NONE
<           INTEGER :: i,is
< 
<           IF( nspin == 1) THEN
<             WRITE(stdout,6) nelt, nbnd
<             WRITE(stdout,7) ( f( i ), i = 1, nbnd )
<           ELSE
<             WRITE(stdout,8) nelt
<             WRITE(stdout,9) nel(1)
<             WRITE(stdout,7) ( f( i ), i = 1, nupdwn(1))
<             WRITE(stdout,10) nel(2)
<             WRITE(stdout,7) ( f( i ), i = iupdwn(2), ( iupdwn(2) + nupdwn(2) - 1 ) )
<           END IF
---
>       ! local variables
>       COMPLEX(DP) temp(ngw) ! automatic array
>  
>       REAL(DP), ALLOCATABLE ::  bec(:), bev(:)
>       INTEGER ig,is,ia,iv,jv,inl,jnl
> !
>       ALLOCATE(bec(nkb))
>       ALLOCATE(bev(nkb))
> !
> !     < beta | c > is real. only the i lowest:
> !
>       CALL nlsm1(1,1,nvb,eigr,c,bec)
>       CALL nlsm1(1,1,nvb,eigr,v,bev)
> !
>       DO ig=1,ngw
>          temp(ig)=CONJG(c(ig))*v(ig)
>       END DO
>       csv = 2.0d0 * DBLE(SUM(temp))
>       IF (gstart == 2) csv = csv - DBLE(temp(1))
224,229c382
<          qbac=0.
<          do is=1,nsp
<            qbac=qbac+na(is)*zv(is)
<          end do
<          qbac=qbac-nelt
<          if(qbac.ne.0) write(stdout,11) qbac
---
>       CALL mp_sum( csv, intra_image_comm )
230a384,400
>       DO is=1,nvb
>          DO iv=1,nh(is)
>             DO jv=1,nh(is)
>                DO ia=1,na(is)
>                   inl=ish(is)+(iv-1)*na(is)+ia
>                   jnl=ish(is)+(jv-1)*na(is)+ia
>                   csv = csv + qq(iv,jv,is)*bec(inl)*bev(jnl)
>                END DO
>             END DO
>          END DO
>       END DO
>       !
>       DEALLOCATE(bec)
>       DEALLOCATE(bev)
>       !
>       RETURN
>    END SUBROUTINE dotcsv
232,334d401
< 6         FORMAT(/,3X,'Electronic states',/  &
<                   ,3X,'-----------------',/  &
<                   ,3X,'Number of Electron = ',I5,', of States = ',I5,/ &
<                   ,3X,'Occupation numbers :')
< 7         FORMAT(2X,10F5.2)
< 8         FORMAT(/,3X,'Electronic states',/  &
<                   ,3X,'-----------------',/  &
<                   ,3X,'Local Spin Density calculation',/ &
<                   ,3X,'Number of Electron = ',I5)
< 9         FORMAT(  3X,'Spins up   = ', I5, ', occupations: ')
< 10        FORMAT(  3X,'Spins down = ', I5, ', occupations: ')
< 11        FORMAT(/,3X,'WARNING: system charge = ',F12.6)
<           RETURN
<       END SUBROUTINE electrons_print_info
< 
< 
< !  ----------------------------------------------
< 
< 
<       SUBROUTINE exch_corr_print_info()
< 
<         USE funct, ONLY: get_iexch, get_icorr, get_igcx, get_igcc, write_dft_name
<         USE io_global, ONLY: stdout
< 
<         IMPLICIT NONE
< 
<         CHARACTER(LEN = 60) :: exch_info
<         CHARACTER(LEN = 60) :: corr_info
<         CHARACTER(LEN = 60) :: exgc_info
<         CHARACTER(LEN = 60) :: cogc_info
< 
<         WRITE(stdout,800)
< 
<           ! ...     iexch => Exchange functional form
<           ! ...     icorr => Correlation functional form
<           ! ...     igcx  => Gradient Correction to the Exchange potential
<           ! ...     igcc  => Gradient Correction to the Correlation potential
< 
<           SELECT CASE ( get_iexch() )
<             CASE (0)
<               exch_info = 'NONE'
<             CASE (1)
<               exch_info = 'SLATER'
<             CASE (2)
<               exch_info = 'SLATER (alpha=1)'
<             CASE DEFAULT
<               exch_info = 'UNKNOWN'
<           END SELECT
<           SELECT CASE ( get_icorr() )
<             CASE (0)
<               corr_info = 'NONE'
<             CASE (1)
<               corr_info = 'PERDEW AND ZUNGER'
<             CASE (2)
<               corr_info = 'VOSKO, WILK AND NUSAIR'
<             CASE (3)
<               corr_info = 'LEE, YANG, AND PARR'
<             CASE (4)
<               corr_info = 'PERDEW AND WANG'
<             CASE (9)
<               corr_info = 'PADE APPROXIMATION'
<             CASE DEFAULT
<               corr_info = 'UNKNOWN'
<           END SELECT
<           SELECT CASE ( get_igcx() )
<             CASE (0)
<               exgc_info = 'NONE'
<             CASE (1)
<               exgc_info = 'BECKE'
<             CASE (2)
<               exgc_info = 'PERDEW'
<             CASE (3)
<               exgc_info = 'PERDEW BURKE ERNZERHOF'
<             CASE (7)
<               exgc_info = 'META-TPSS'
<             CASE DEFAULT
<               exgc_info = 'UNKNOWN'
<           END SELECT
<           SELECT CASE ( get_igcc() )
<             CASE (0)
<               cogc_info = 'NONE'
<             CASE (1)
<               cogc_info = 'PERDEW'
<             CASE (2)
<               cogc_info = 'LEE, YANG AND PARR'
<             CASE (3)
<               cogc_info = 'PERDEW AND WANG'
<             CASE (4)
<               cogc_info = 'PERDEW BURKE ERNZERHOF'
<             CASE (6)
<               cogc_info = 'META-TPSS'
<             CASE DEFAULT
<               cogc_info = 'UNKNOWN'
<           END SELECT
< 
<           WRITE(stdout,910)
<           WRITE(stdout,fmt='(5X,"Exchange functional: ",A)') exch_info
<           WRITE(stdout,fmt='(5X,"Correlation functional: ",A)') corr_info
<           IF( ( get_igcx() > 0 ) .OR. ( get_igcc() > 0 ) ) THEN
<             WRITE(stdout,810)
<             WRITE(stdout,fmt='(5X,"Exchange functional: ",A)') exgc_info
<             WRITE(stdout,fmt='(5X,"Correlation functional: ",A)') cogc_info
<           END IF
336c403,417
<         call write_dft_name
---
> !
> !-----------------------------------------------------------------------
>    FUNCTION enkin( c, ngwx, f, n )
> !-----------------------------------------------------------------------
>       !
>       ! calculation of kinetic energy term
>       !
>       USE kinds,              ONLY: DP
>       USE constants,          ONLY: pi, fpi
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart
>       USE gvecw,              ONLY: ggp
>       USE mp,                 ONLY: mp_sum
>       USE mp_global,          ONLY: intra_image_comm
>       USE cell_base,          ONLY: tpiba2
338,344c419
< 800 FORMAT(//,3X,'Exchange and correlations functionals',/ &
<              ,3X,'-------------------------------------')
< 810 FORMAT(   3X,'Using Generalized Gradient Corrections with')
< 910 FORMAT(   3X,'Using Local Density Approximation with')
< 
<         RETURN
<       END SUBROUTINE exch_corr_print_info
---
>       IMPLICIT NONE
345a421
>       REAL(DP)                :: enkin
346a423
>       ! input
348c425,429
< !  ----------------------------------------------
---
>       INTEGER,     INTENT(IN) :: ngwx, n
>       COMPLEX(DP), INTENT(IN) :: c( ngwx, n )
>       REAL(DP),    INTENT(IN) :: f( n )
>       !
>       ! local
350,395c431,437
< 
< 
<        SUBROUTINE ions_print_info( )
<             
<          !  Print info about input parameter for ion dynamic
< 
<          USE io_global,     ONLY: ionode, stdout
<          USE control_flags, ONLY: tranp, amprp, tnosep, tolp, tfor, tsdp, tzerop, &
<                                   tv0rd, taurdr, nv0rd, nbeg, tcp, tcap
<          USE ions_base,     ONLY: tau_srt, if_pos, ind_srt, nsp, na, &
<                                   amass, nat, fricp, greasp, rcmax
<          USE ions_nose,     ONLY: tempw, ndega
<          USE constants,     ONLY: amu_au
< 
<          IMPLICIT NONE
<               
<          integer is, ia, k, ic, isa
<          LOGICAL :: ismb( 3 ) 
<                 
<          WRITE( stdout, 50 ) 
< 
<          IF( .NOT. tfor ) THEN
<            WRITE( stdout, 518 )
<          ELSE
<            WRITE( stdout, 520 )
<            IF( tsdp ) THEN
<              WRITE( stdout, 521 )
<            ELSE
<              WRITE( stdout, 522 )
<            END IF
<            WRITE( stdout, 523 ) ndega
<            WRITE( stdout, 524 ) fricp, greasp
<            IF( tzerop ) then
<              IF( tv0rd ) THEN
<                WRITE( stdout, 850 ) nv0rd
<              ELSE
<                WRITE( stdout, 635 )
<              ENDIF 
<            ENDIF
<          END IF 
<               
<          DO is = 1, nsp
<            IF( tranp(is) ) THEN
<              WRITE( stdout,510)
<              WRITE( stdout,512) is, amprp(is)
<            END IF
---
>       INTEGER  :: ig, i
>       REAL(DP) :: sk(n)  ! automatic array
>       !
>       DO i=1,n
>          sk(i)=0.0d0
>          DO ig=gstart,ngw
>             sk(i)=sk(i)+DBLE(CONJG(c(ig,i))*c(ig,i))*ggp(ig)
396a439
>       END DO
398,416c441
<          WRITE(stdout,660) 
<          isa = 0
<          DO IS = 1, nsp
<            WRITE(stdout,1000) is, na(is), amass(is)*amu_au, amass(is), rcmax(is)
<            DO IA = 1, na(is)
<              isa = isa + 1
<              WRITE(stdout,1010) ( tau_srt(k,isa), K = 1,3 )
<            END DO
<          END DO    
< 
<          IF ( ( nbeg > -1 ) .AND. ( .NOT. taurdr ) ) THEN
<             WRITE(stdout,661)
<          ELSE
<             WRITE(stdout,662)
<          ENDIF
< 
<          IF( tfor ) THEN
< 
<             IF( ANY( ( if_pos( 1:3, 1:nat ) == 0 )  ) ) THEN
---
>       CALL mp_sum( sk(1:n), intra_image_comm )
418,419c443,446
<               WRITE(stdout,1020)
<               WRITE(stdout,1022)
---
>       enkin=0.0d0
>       DO i=1,n
>          enkin=enkin+f(i)*sk(i)
>       END DO
421,429c448,449
<               DO isa = 1, nat
<                 ia = ind_srt( isa )
<                 ismb( 1 ) = ( if_pos(1,ia) /= 0 )
<                 ismb( 2 ) = ( if_pos(2,ia) /= 0 )
<                 ismb( 3 ) = ( if_pos(3,ia) /= 0 )
<                 IF( .NOT. ALL( ismb ) ) THEN
<                   WRITE( stdout, 1023 ) isa, ( ismb(k), K = 1, 3 )
<                 END IF
<               END DO
---
>       ! ... reciprocal-space vectors are in units of alat/(2 pi) so a
>       ! ... multiplicative factor (2 pi/alat)**2 is required
431c451,562
<             ELSE
---
>       enkin = enkin * tpiba2
> !
>       RETURN
>    END FUNCTION enkin
> !
> !
> !-----------------------------------------------------------------------
>       SUBROUTINE gausin(eigr,cm)
> !-----------------------------------------------------------------------
> !
> ! initialize wavefunctions with gaussians - edit to fit your system
> !
>       USE kinds,              ONLY: DP
>       USE ions_base,          ONLY: na, nsp, nat
>       USE electrons_base,     ONLY: n => nbsp
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gx, g
> !
>       IMPLICIT NONE
> !
>       COMPLEX(DP) eigr(ngw,nat), cm(ngw,n)
>       REAL(DP)    sigma, auxf
>       INTEGER nband, is, ia, ig, isa
> !
>       sigma=12.0d0
>       nband=0
> !!!      do is=1,nsp
>       isa = 0
>       is=1
>          DO ia=1,na(is)
> ! s-like gaussians
>             nband=nband+1
>             DO ig=1,ngw
>                auxf=EXP(-g(ig)/sigma**2)
>                cm(ig,nband)=auxf*eigr(ig,ia+isa)
>             END DO
> ! px-like gaussians
>             nband=nband+1
>             DO ig=1,ngw
>                auxf=EXP(-g(ig)/sigma**2)
>                cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(1,ig)
>             END DO
> ! py-like gaussians
>             nband=nband+1
>             DO ig=1,ngw
>                auxf=EXP(-g(ig)/sigma**2)
>                cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(2,ig)
>             END DO
> ! pz-like gaussians
>             nband=nband+1
>             DO ig=1,ngw
>                auxf=EXP(-g(ig)/sigma**2)
>                cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(3,ig)
>             END DO
>          END DO
>       isa = isa + na(is)
>       is=2
>          DO ia=1,na(is)
> ! s-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)
> !            end do
> ! px-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(1,ig)
> !            end do
> ! py-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(2,ig)
> !            end do
> ! pz-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(3,ig)
> !            end do
> ! dxy-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(1,ig)*gx(2,ig)
> !            end do
> ! dxz-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(1,ig)*gx(3,ig)
> !            end do
> ! dxy-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*gx(2,ig)*gx(3,ig)
> !            end do
> ! dx2-y2-like gaussians
> !            nband=nband+1
> !            do ig=1,ngw
> !               auxf=exp(-g(ig)/sigma**2)
> !               cm(ig,nband)=auxf*eigr(ig,ia+isa)*                        &
> !     &              (gx(1,ig)**2-gx(2,ig)**2)
> !            end do
>          END DO
> !!!      end do
>       RETURN
>       END SUBROUTINE gausin
> !            
433c564,589
<               WRITE(stdout,1021)
---
> !-------------------------------------------------------------------------
>       SUBROUTINE gracsc( bec, nkbx, betae, cp, ngwx, i, csc, n )
> !-----------------------------------------------------------------------
> !     requires in input the updated bec(k) for k<i
> !     on output: bec(i) is recalculated
> !
>       USE ions_base,      ONLY: na
>       USE cvan,           ONLY :nvb, ish
>       USE uspp,           ONLY : nkb, nhsavb=>nkbus, qq
>       USE uspp_param,     ONLY:  nh
>       USE electrons_base, ONLY: ispin
>       USE gvecw,          ONLY: ngw
>       USE mp,             ONLY: mp_sum
>       USE mp_global,      ONLY: intra_image_comm
>       USE kinds,          ONLY: DP
>       USE reciprocal_vectors, ONLY: gstart
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: i, nkbx, ngwx, n
>       COMPLEX(DP) :: betae( ngwx, nkb )
>       REAL(DP)    :: bec( nkbx, n ), cp( 2, ngwx, n )
>       REAL(DP)    :: csc( n )
>       INTEGER     :: k, kmax,ig, is, iv, jv, ia, inl, jnl
>       REAL(DP)    :: rsum
>       REAL(DP), ALLOCATABLE :: temp(:) 
435,436c591,596
<             END IF
<          END IF
---
>       !
>       !     calculate csc(k)=<cp(i)|cp(k)>,  k<i
>       !
>       kmax = i - 1
>       !
> !$omp parallel default(shared), private( temp, k, ig )
438,463c598
<          IF( tfor ) THEN
<            if( ( tcp .or. tcap .or. tnosep ) .and. tsdp ) then
<              call errore(' ions_print_info', &
<                ' Temperature control not allowed with steepest descent',1)
<            endif
<            IF(.not. tcp .and. .not. tcap .and. .not. tnosep ) THEN
<               WRITE( stdout,550)
<            ELSE IF( tcp .and. tcap ) then
<              call errore(' ions_print_info', ' Velocity rescaling not' &
<                          //' compatible with random velocity initialization',1)
<            ELSE IF( tcp .and. tnosep ) then
<              call errore(' ions_print_info', ' Velocity rescaling and' &
<                          //' Nose thermostat are incompatible',1)
<            ELSE IF(tcap .and. tnosep ) then
<              call errore(' ions_print_info', ' Nose thermostat not' &
<                          //' compatible with random velocity initialization',1)
<            ELSE IF(tcp) THEN
<              WRITE( stdout,555) tempw,tolp
<            ELSE IF(tcap) THEN
<              WRITE( stdout,560) tempw,tolp
<            ELSE IF(tnosep) THEN
<              WRITE( stdout,595)
<            ELSE
<              WRITE( stdout,550)
<            END IF
<          END IF
---
>       ALLOCATE( temp( ngw ) )
465,466c600,611
<    50 FORMAT(//,3X,'Ions Simulation Parameters',/ &
<                ,3X,'--------------------------')
---
> !$omp do
>       DO k = 1, kmax
>          csc(k) = 0.0d0
>          IF ( ispin(i) .EQ. ispin(k) ) THEN
>             DO ig = 1, ngw
>                temp(ig) = cp(1,ig,k) * cp(1,ig,i) + cp(2,ig,k) * cp(2,ig,i)
>             END DO
>             csc(k) = 2.0d0 * SUM(temp)
>             IF (gstart == 2) csc(k) = csc(k) - temp(1)
>          ENDIF
>       END DO
> !$omp end do
468,503c613
<   510 FORMAT(   3X,'Initial random displacement of ionic coordinates',/, & 
<                 3X,' specie  amplitude')
<   512 FORMAT(   3X,I7,2X,F9.6)
< 
<   518 FORMAT(   3X,'Ions are not allowed to move')
<   520 FORMAT(   3X,'Ions are allowed to move')
<   521 FORMAT(   3X,'Ions dynamics with steepest descent')
<   522 FORMAT(   3X,'Ions dynamics with newton equations')
<   523 format(   3X,'the temperature is computed for ',i5,' degrees of freedom')
<   524 format(   3X,'ion dynamics with fricp = ',f7.4,' and greasp = ',f7.4)
<   550 FORMAT(   3X,'Ionic temperature is not controlled')
<   555 FORMAT(   3X,'Ionic temperature control via ', &
<                    'rescaling of velocities :',/ &
<                ,3X,'temperature required = ',F10.5,'K, ', &
<                    'tolerance = ',F10.5,'K')
<   560 FORMAT(   3X,'Ionic temperature control via ', &
<                    'canonical velocities rescaling :',/ &
<                ,3X,'temperature required = ',F10.5,'K, ', &
<                    'tolerance = ',F10.5,'K')
<   595 FORMAT(   3X,'Ionic temperature control via nose thermostat')
<   635 FORMAT(   3X,'Zero initial momentum for ions')
< 
<   660 FORMAT(   3X,'Ionic position (from input)', /, &
<                 3X,'sorted by specie, and converted to real a.u. coordinates')
<   661 FORMAT(   3X,'Ionic position will be re-read from restart file')
<   662 FORMAT(   3X,'Ionic position read from input file')
< 
<   850 FORMAT(   3X,'Initial ion velocities read from unit : ',I4)
< 
<  1000 FORMAT(3X,'Species ',I3,' atoms = ',I4,' mass = ',F12.2, ' (a.u.), ', &
<                & F12.2, ' (amu)', ' rcmax = ', F6.2, ' (a.u.)' )
<  1010 FORMAT(3X,3(1X,F12.6))
<  1020 FORMAT(/,3X,'NOT all atoms are allowed to move ')
<  1021 FORMAT(/,3X,'All atoms are allowed to move')
<  1022 FORMAT(  3X,' indx  ..x.. ..y.. ..z..')
<  1023 FORMAT(  3X,I4,3(1X,L5))
---
>       DEALLOCATE( temp )
504a615
> !$omp end parallel
505a617
>       CALL mp_sum( csc( 1:kmax ), intra_image_comm )
507,508c619,630
<          RETURN
<        END SUBROUTINE ions_print_info
---
>       ALLOCATE( temp( ngw ) )
>       !
>       !     calculate bec(i)=<cp(i)|beta>
>       !
>       DO inl=1,nhsavb
>          DO ig=1,ngw
>             temp(ig)=cp(1,ig,i)* DBLE(betae(ig,inl))+             &
>      &               cp(2,ig,i)*AIMAG(betae(ig,inl))
>          END DO
>          bec(inl,i)=2.d0*SUM(temp)
>          IF (gstart == 2) bec(inl,i)= bec(inl,i)-temp(1)
>       END DO
509a632,664
>       CALL mp_sum( bec( 1:nhsavb, i ), intra_image_comm )
> !
> !     calculate csc(k)=<cp(i)|S|cp(k)>,  k<i
> !
>       DO k=1,kmax
>          IF (ispin(i).EQ.ispin(k)) THEN
>             rsum=0.d0
>             DO is=1,nvb
>                DO iv=1,nh(is)
>                   DO jv=1,nh(is)
>                      IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN 
>                         DO ia=1,na(is)
>                            inl=ish(is)+(iv-1)*na(is)+ia
>                            jnl=ish(is)+(jv-1)*na(is)+ia
>                            rsum = rsum + qq(iv,jv,is)*bec(inl,i)*bec(jnl,k)
>                         END DO
>                      ENDIF
>                   END DO
>                END DO
>             END DO
>             csc(k)=csc(k)+rsum
>          ENDIF
>       END DO
> !
> !     orthogonalized cp(i) : |cp(i)>=|cp(i)>-\sum_k<i csc(k)|cp(k)>
> !
> !     corresponing bec:  bec(i)=<cp(i)|beta>-csc(k)<cp(k)|beta>
> !
>       DO k=1,kmax
>           DO inl=1,nkbx
>             bec(inl,i)=bec(inl,i)-csc(k)*bec(inl,k)
>          END DO
>       END DO
511c666,669
< !  ----------------------------------------------
---
>       DEALLOCATE( temp )
> !
>       RETURN
>       END SUBROUTINE gracsc
513d670
<         subroutine cell_print_info( )
515,519c672,674
<           USE constants, ONLY: au_gpa
<           USE control_flags, ONLY: thdyn, tsdc, tzeroc, tbeg, nbeg, tpre
<           USE control_flags, ONLY: tnoseh
<           USE io_global, ONLY: stdout
<           USE cell_base, ONLY: press, frich, greash, wmass
---
> !-------------------------------------------------------------------------
>       SUBROUTINE smooth_csv( c, v, ngwx, csv, n )
> !-----------------------------------------------------------------------
521c676,687
<           IMPLICIT NONE
---
>       USE gvecw,              ONLY: ngw
>       USE kinds,              ONLY: DP
>       USE reciprocal_vectors, ONLY: gstart
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: ngwx, n
>       REAL(DP)    :: c( 2, ngwx )
>       REAL(DP)    :: v( 2, ngwx, n )
>       REAL(DP)    :: csv( n )
>       INTEGER     :: k, ig
>       REAL(DP), ALLOCATABLE :: temp(:) 
523,530c689,692
<           WRITE(stdout,545 )
<           IF ( tpre ) WRITE( stdout, 600 )
<           IF ( tbeg ) THEN
<             WRITE(stdout,546)
<           ELSE
<             WRITE(stdout,547)
<             IF( nbeg > -1 ) WRITE( stdout, 548 )
<           END IF
---
>       !
>       !     calculate csv(k)=<c|v(k)>
>       !
>       ALLOCATE( temp( ngw ) )
532,554c694,700
<           IF( .NOT. thdyn ) THEN
<             WRITE( stdout,525)
<             WRITE( stdout,606)
<           ELSE
<             IF( tsdc ) THEN
<               WRITE( stdout,526)
<             ELSE
<               IF( frich /= 0.0d0 ) THEN
<                 WRITE( stdout,602) frich, greash
<               ELSE
<                 WRITE( stdout,527)
<               END IF
<               IF( tnoseh ) then
<                 WRITE( stdout,604) 
<               ELSE
<                 WRITE( stdout,565)
<               END IF
<               IF( tzeroc ) THEN
<                 WRITE( stdout,563)
<               ENDIF
<             END IF
<             WRITE( stdout,530) press * au_gpa, wmass
<           END IF
---
>       DO k = 1, n
>          DO ig = 1, ngw
>             temp(ig) = v(1,ig,k) * c(1,ig) + v(2,ig,k) * c(2,ig)
>          END DO
>          csv(k) = 2.0d0 * SUM(temp)
>          IF (gstart == 2) csv(k) = csv(k) - temp(1)
>       END DO
555a702,705
>       DEALLOCATE( temp )
> !
>       RETURN
>       END SUBROUTINE smooth_csv
557,600d706
<  545     FORMAT(//,3X,'Cell Dynamics Parameters (from STDIN)',/ &
<                   ,3X,'-------------------------------------')
<  546     FORMAT(   3X,'Simulation cell read from STDIN')
<  547     FORMAT(   3X,'Starting cell generated from CELLDM')
<  548     FORMAT(   3X,'Cell parameters will be re-read from restart file')
<  525     FORMAT(   3X,'Constant VOLUME Molecular dynamics')
<  606     format(   3X,'cell parameters are not allowed to move')
<  526     FORMAT(   3X,'Volume dynamics with steepest descent')
<  527     FORMAT(   3X,'Volume dynamics with newton equations')
<  530     FORMAT(   3X,'Constant PRESSURE Molecular dynamics:',/ &
<                   ,3X,'External pressure (GPa) = ',F11.2,/ &
<                   ,3X,'Volume mass             = ',F11.2)
<  563     FORMAT(   3X,'Zero initial momentum for cell variables')
<  565     FORMAT(   3X,'Volume dynamics: the temperature is not controlled')
<  604     format(   3X,'cell parameters dynamics with nose` temp. control' )
< 
<  600  format( 3X, 'internal stress tensor calculated')
<  602  format( 3X, 'cell parameters dynamics with frich = ',f7.4,            &
<      &        3X, 'and greash = ',f7.4 )
< 
<         return
<       end subroutine cell_print_info
< 
< 
< !----------------------------------------------
< SUBROUTINE gmeshinfo( )
< !----------------------------------------------
<    !
<    !   Print out the number of g vectors for the different mesh
<    !
<    USE kinds,     ONLY: DP
<    USE mp_global, ONLY: nproc_bgrp, intra_bgrp_comm
<    USE io_global, ONLY: ionode, ionode_id, stdout
<    USE mp,        ONLY: mp_max, mp_gather
<    use smallbox_gvec,     only: ngb
<    USE gvecw,     only: ngw_g, ngw, ngwx
<    USE gvecs,     only: ngms_g, ngms, ngsx
<    USE gvect,     only: ngm, ngm_g, ngmx
< 
<    IMPLICIT NONE
< 
<    INTEGER :: ip, ng_snd(3), ng_rcv( 3, nproc_bgrp )
<    INTEGER :: ierr, min_val, max_val, i
<    REAL(DP) :: avg_val
602,696c708,710
<    IF(ionode) THEN
<       WRITE( stdout,*)
<       WRITE( stdout,*) '  Reciprocal Space Mesh'
<       WRITE( stdout,*) '  ---------------------'
<    END IF
< 
<    ng_snd(1) = ngm_g
<    ng_snd(2) = ngm
<    ng_snd(3) = ngmx
<    CALL mp_gather(ng_snd, ng_rcv, ionode_id, intra_bgrp_comm)
<    !
<    IF(ionode) THEN
<       min_val = MINVAL( ng_rcv(2,:) )
<       max_val = MAXVAL( ng_rcv(2,:) )
<       avg_val = REAL(SUM( ng_rcv(2,:) ))/nproc_bgrp
<       WRITE( stdout,1000)
<       WRITE( stdout,1011) ng_snd(1), min_val, max_val, avg_val
<    END IF
<    !
<    ng_snd(1) = ngms_g
<    ng_snd(2) = ngms
<    ng_snd(3) = ngsx
<    CALL mp_gather(ng_snd, ng_rcv, ionode_id, intra_bgrp_comm)
<    !
<    ierr = 0
<    !
<    IF(ionode) THEN
<       WRITE( stdout,1001)
<       min_val = MINVAL( ng_rcv(2,:) )
<       max_val = MAXVAL( ng_rcv(2,:) )
<       avg_val = REAL(SUM( ng_rcv(2,:) ))/nproc_bgrp
<       WRITE( stdout,1011) ng_snd(1), min_val, max_val, avg_val
<       IF( min_val < 1 ) ierr = ip
<    END IF
<    !
<    CALL mp_max( ierr, intra_bgrp_comm )
<    !
<    IF( ierr > 0 ) &
<       CALL errore( " gmeshinfo ", " Wow! some processors have no G-vectors ", ierr )
<    !
<    ng_snd(1) = ngw_g
<    ng_snd(2) = ngw
<    ng_snd(3) = ngwx
<    CALL mp_gather(ng_snd, ng_rcv, ionode_id, intra_bgrp_comm)
<    !
<    IF(ionode) THEN
<       WRITE( stdout,1002)
<       min_val = MINVAL( ng_rcv(2,:) )
<       max_val = MAXVAL( ng_rcv(2,:) )
<       avg_val = REAL(SUM( ng_rcv(2,:) ))/nproc_bgrp
<       WRITE( stdout,1011) ng_snd(1), min_val, max_val, avg_val
<       IF( min_val < 1 ) ierr = ip
<    END IF
<    !
<    CALL mp_max( ierr, intra_bgrp_comm )
<    !
<    IF( ierr > 0 ) &
<       CALL errore( " gmeshinfo ", " Wow! some processors have no G-vectors ", ierr )
<    !
<    IF(ionode .AND. ngb > 0 ) THEN
<       WRITE( stdout,1050)
<       WRITE( stdout,1060) ngb
<    END IF
< 
<    1000    FORMAT(3X,'Large Mesh',/, &
<            '     Global(ngm_g)    MinLocal       MaxLocal      Average') 
<    1001    FORMAT(3X,'Smooth Mesh',/, &
<            '     Global(ngms_g)   MinLocal       MaxLocal      Average') 
<    1002    FORMAT(3X,'Wave function Mesh',/, &
<            '     Global(ngw_g)    MinLocal       MaxLocal      Average') 
<    1011    FORMAT(  3I15, F15.2 )
<    1050    FORMAT(/,3X,'Small box Mesh')
<    1060    FORMAT( 3X, 'ngb = ', I12, ' not distributed to processors' )
< 
<    RETURN
< 
< END SUBROUTINE gmeshinfo
< 
< !----------------------------------------------
< SUBROUTINE constraint_info()
< !----------------------------------------------
<    USE kinds,              ONLY: DP
<    USE constraints_module, ONLY: nconstr, constr_tol, &
<                                  constr_type, constr, constr_target
<    USE io_global,          ONLY: ionode, stdout
<    USE control_flags,      ONLY: lconstrain
<    !
<    IMPLICIT NONE
<    !
<    INTEGER :: ic
<    !
<    IF( lconstrain .AND. ionode ) THEN
<       !
<       WRITE( stdout, 10 ) 
<       WRITE( stdout, 20 ) nconstr, constr_tol
---
> !-------------------------------------------------------------------------
>       SUBROUTINE grabec( becc, nkbx, betae, c, ngwx )
> !-----------------------------------------------------------------------
698,710c712
<       DO ic = 1, nconstr
<          !
<          IF( constr_type( ic ) == 3 ) THEN
<             !
<             ! distance
<             !
<             WRITE( stdout, 30 ) ic
<             WRITE( stdout, 40 ) NINT( constr(1,ic) ), &
<                                 NINT( constr(2,ic) ), constr_target(ic)
<             !
<          END IF
<          !
<       END DO
---
>       !     on output: bec(i) is recalculated
712,744c714,737
<    END IF
<    !
< 10 FORMAT( 3X, "Using constrained dynamics")
< 20 FORMAT( 3X, "number of constrain and tolerance: ", I5, D10.2)
< 30 FORMAT( 3X, "constrain ", I5, " type distance ")
< 40 FORMAT( 3X, "  atoms ", I5, I5, " target dist ", F10.5)
<    !
< END SUBROUTINE constraint_info
< 
< 
< SUBROUTINE new_atomind_constraints()
<    !
<    USE kinds,              ONLY: DP
<    USE constraints_module, ONLY: constr
<    USE ions_base,          ONLY: ind_bck
<    !
<    IMPLICIT NONE
<    !
<    INTEGER  :: ic, ia
<    INTEGER  :: iaa
<    REAL(DP) :: aa
<    !
<    !  Substitute the atom index given in the input file
<    !  with the new atom index, after the sort in the
<    !  atomic coordinates.
<    !
<    DO ic = 1, SIZE( constr, 2 )
<       DO ia = 1, SIZE( constr, 1 )
<          IF( constr( ia, ic ) > 0.0d0 ) THEN
<             iaa = NINT( constr( ia, ic ) )
<             aa  = DBLE( ind_bck( iaa ) )
<             constr( ia, ic ) = aa
<          END IF
---
>       USE uspp,           ONLY : nkb, nhsavb=>nkbus
>       USE gvecw,          ONLY: ngw
>       USE kinds,          ONLY: DP
>       USE reciprocal_vectors, ONLY: gstart
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: nkbx, ngwx
>       COMPLEX(DP) :: betae( ngwx, nkb )
>       REAL(DP)    :: becc( nkbx ), c( 2, ngwx )
>       INTEGER     :: ig, inl
>       REAL(DP), ALLOCATABLE :: temp(:) 
>       !
>       ALLOCATE( temp( ngw ) )
>       !
>       !     calculate becc=<c|beta>
>       !
>       DO inl=1,nhsavb
>          DO ig=1,ngw
>             temp(ig)=c(1,ig)* DBLE(betae(ig,inl))+             &
>      &               c(2,ig)*AIMAG(betae(ig,inl))
>          END DO
>          becc(inl)=2.d0*SUM(temp)
>          IF (gstart == 2) becc(inl)= becc(inl)-temp(1)
746,819d738
<    END DO
<    !
<    RETURN
<    !
< END SUBROUTINE new_atomind_constraints
< 
< 
< SUBROUTINE compute_stress_x( stress, detot, h, omega )
<    USE kinds, ONLY : DP
<    IMPLICIT NONE
<    REAL(DP), INTENT(OUT) :: stress(3,3)
<    REAL(DP), INTENT(IN)  :: detot(3,3), h(3,3), omega
<    integer :: i, j
<    do i=1,3 
<       do j=1,3
<          stress(i,j)=-1.d0/omega*(detot(i,1)*h(j,1)+              &
<      &                      detot(i,2)*h(j,2)+detot(i,3)*h(j,3))
<       enddo
<    enddo
<    return
< END SUBROUTINE compute_stress_x
< !-----------------------------------------------------------------------
< subroutine formf( tfirst, eself )
<   !-----------------------------------------------------------------------
< 
<   !computes (a) the self-energy eself of the ionic pseudocharges;
<   !         (b) the form factors of: (i) pseudopotential (vps),
<   !             (ii) ionic pseudocharge (rhops)
<   !         also calculated the derivative of vps with respect to
<   !         g^2 (dvps)
<   ! 
<   USE kinds,           ONLY : DP
<   use mp,              ONLY : mp_sum
<   use control_flags,   ONLY : iprint, tpre, iverbosity
<   use io_global,       ONLY : stdout
<   use mp_global,       ONLY : intra_bgrp_comm
<   use gvecs,           ONLY : ngms
<   use cell_base,       ONLY : omega, tpiba2, tpiba
<   use ions_base,       ONLY : rcmax, zv, nsp, na
<   use local_pseudo,    ONLY : vps, vps0, rhops, dvps, drhops
<   use atom,            ONLY : rgrid
<   use uspp_param,      ONLY : upf, oldvan
<   use pseudo_base,     ONLY : compute_rhops, formfn, formfa, compute_eself
<   use pseudopotential, ONLY : tpstab, vps_sp, dvps_sp
<   use splines,         ONLY : spline
<   use gvect,           ONLY : gstart, gg
<   use constants,       ONLY : autoev
<   !
<   implicit none
<   logical      :: tfirst
<   real(DP)    :: eself, DeltaV0
<   !
<   real(DP)    :: vpsum, rhopsum
<   integer      :: is, ig
<   REAL(DP)    :: cost1, xg
< 
<   call start_clock( 'formf' )
<   !
<   IF( .NOT. ALLOCATED( rgrid ) ) &
<      CALL errore( ' formf ', ' rgrid not allocated ', 1 )
<   IF( .NOT. ALLOCATED( upf ) ) &
<      CALL errore( ' formf ', ' upf not allocated ', 1 )
<   !
<   ! calculation of gaussian selfinteraction
<   !
<   eself = compute_eself( na, zv, rcmax, nsp )
< 
<   if( tfirst .or. ( iverbosity > 3 ) )then
<      WRITE( stdout, 1200 ) eself
<   endif
<   !
<   1200 format(/,3x,'formf: eself=',f12.5)
<   !
<   do is = 1, nsp
821,838c740
<      IF( tpstab ) THEN
<         !
<         !  Use interpolation table, with cubic spline
<         !
<         cost1 = 1.0d0/omega
<         !
<         IF( gstart == 2 ) THEN
<            vps (1,is) =  vps_sp(is)%y(1) * cost1
<            dvps(1,is) = dvps_sp(is)%y(1) * cost1
<         END IF
<         !
<         DO ig = gstart, ngms
<            xg = SQRT( gg(ig) ) * tpiba
<            vps (ig,is) = spline(  vps_sp(is), xg ) * cost1
<            dvps(ig,is) = spline( dvps_sp(is), xg ) * cost1
<         END DO
<         !
<      ELSE
---
>       DEALLOCATE( temp )
840,848c742,743
<         call formfn( rgrid(is)%r, rgrid(is)%rab, &
<                      upf(is)%vloc(1:rgrid(is)%mesh), zv(is), rcmax(is), gg, &
<                      omega, tpiba2, rgrid(is)%mesh, ngms, oldvan(is), tpre, &
<                      vps(:,is), vps0(is), dvps(:,is) )
< 
< ! obsolete BHS form
< ! call formfa( vps(:,is), dvps(:,is), rc1(is), rc2(is), wrc1(is), wrc2(is), &
< !              rcl(:,is,lloc(is)), al(:,is,lloc(is)), bl(:,is,lloc(is)),    &
< !              zv(is), rcmax(is), g, omega, tpiba2, ngms, gstart, tpre )
---
>       RETURN
>       END SUBROUTINE grabec
850,855d744
<      END IF
<      !
<      !     fourier transform of local pp and gaussian nuclear charge
<      !
<      call compute_rhops( rhops(:,is), drhops(:,is), zv(is), rcmax(is), gg, &
<                          omega, tpiba2, ngms, tpre )
857,891c746,747
<      if( tfirst .or. ( iverbosity > 3 ) )then
<         vpsum = SUM( vps( 1:ngms, is ) )
<         rhopsum = SUM( rhops( 1:ngms, is ) )
<         call mp_sum( vpsum, intra_bgrp_comm )
<         call mp_sum( rhopsum, intra_bgrp_comm )
<         WRITE( stdout,1250) vps(1,is),rhops(1,is)
<         WRITE( stdout,1300) vpsum,rhopsum
<      endif
<      !
<   end do
<   ! 
<   ! ... DeltaV0 is the shift to be applied to eigenvalues
<   ! ... in order to align them to other plane wave codes
<   !
<   DeltaV0 = 0.0_dp
<   DO is = 1, nsp
<      !
<      ! ...  na(is)/omega is the structure factor at G=0
<      !
<      DeltaV0 = DeltaV0 + na(is) / omega * vps0(is)
<   END DO
<   !
<   IF ( tfirst .or. ( iverbosity > 3 ) ) THEN
<       write(6,'("   Delta V(G=0): ",f10.6,"Ry, ",f11.6,"eV")') &
<          deltaV0, deltaV0*autoev
<   END IF
<   !
<   call stop_clock( 'formf' )
<   !
<   1250 format(3x,'formf:     vps(g=0)=',f12.7,'     rhops(g=0)=',f12.7)
<   1300 format(3x,'formf: sum_g vps(g)=',f12.7,' sum_g rhops(g)=',f12.7)
<   !
<   return
< end subroutine formf
< !
---
> !-------------------------------------------------------------------------
>       SUBROUTINE bec_csv( becc, becv, nkbx, csv, n )
893,919c749,765
< SUBROUTINE newnlinit()
<   !-----------------------------------------------------------------------
<   !
<   ! ... this routine calculates arrays beta, qq, qgb, rhocb
<   ! ... and derivatives w.r.t. cell parameters dbeta
<   ! ... See also comments in nlinit
<   !
<   use control_flags,    ONLY : tpre
<   use pseudopotential,  ONLY : tpstab
<   use cp_interfaces,    ONLY : interpolate_beta, interpolate_qradb, compute_qradx, compute_betagx, &
<                                exact_beta, check_tables, exact_qradb, build_pstab, build_cctab
<   use betax,            only : mmx, refg
<   use kinds,            only : dp
<   use io_global,        only : ionode, stdout
<   !
<   IMPLICIT NONE
<   !
<   LOGICAL  :: recompute_table
<   REAL(DP) :: gmax
<   ! 
<   ! ... initialization for vanderbilt species
<   !
<   IF( tpstab ) THEN
< 
<      recompute_table = tpre .AND. check_tables( gmax )
<      !
<      IF ( recompute_table ) THEN
---
> !     requires in input the updated becc and becv(k)
> !     on output: csv is updated
> !
>       USE ions_base,      ONLY: na
>       USE cvan,           ONLY :nvb, ish
>       USE uspp,           ONLY : nkb, nhsavb=>nkbus, qq
>       USE uspp_param,     ONLY:  nh
>       USE kinds,          ONLY: DP
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: nkbx, n
>       REAL(DP)    :: becc( nkbx )
>       REAL(DP)    :: becv( nkbx, n )
>       REAL(DP)    :: csv( n )
>       INTEGER     :: k, is, iv, jv, ia, inl, jnl
>       REAL(DP)    :: rsum
921,923c767,788
<         IF( ionode ) &
<            WRITE( stdout, * ) "newnliinit: recomputing the pseudopotentials tables" 
<         !"!
---
> !     calculate csv(k) = csv(k) + <c| SUM_nm |beta(n)><beta(m)|v(k)>,  k<i
> !
>       DO k=1,n
>             rsum=0.d0
>             DO is=1,nvb
>                DO iv=1,nh(is)
>                   DO jv=1,nh(is)
>                      IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN 
>                         DO ia=1,na(is)
>                            inl=ish(is)+(iv-1)*na(is)+ia
>                            jnl=ish(is)+(jv-1)*na(is)+ia
>                            rsum = rsum + qq(iv,jv,is)*becc(inl)*becv(jnl,k)
>                         END DO
>                      ENDIF
>                   END DO
>                END DO
>             END DO
>             csv(k)=csv(k)+rsum
>       END DO
> !
>       RETURN
>       END SUBROUTINE bec_csv
925d789
<         CALL set_interpolation_table_size( mmx, refg, gmax )
927d790
<         CALL compute_qradx( tpre )
929c792,812
<         call compute_betagx( tpre )
---
> !-------------------------------------------------------------------------
>       SUBROUTINE gram( betae, bec, nkbx, cp, ngwx, n )
> !-----------------------------------------------------------------------
> !     gram-schmidt orthogonalization of the set of wavefunctions cp
> !
>       USE uspp,           ONLY : nkb, nhsavb=> nkbus
>       USE gvecw,          ONLY : ngw
>       USE kinds,          ONLY : DP
> !
>       IMPLICIT NONE
> !
>       INTEGER, INTENT(IN) :: nkbx, ngwx, n
>       REAL(DP)      :: bec( nkbx, n )
>       COMPLEX(DP)   :: cp( ngwx, n ), betae( ngwx, nkb )
> !
>       REAL(DP) :: anorm, cscnorm
>       REAL(DP), ALLOCATABLE :: csc( : )
>       INTEGER :: i,k
>       EXTERNAL cscnorm
> !
>       CALL start_clock( 'gram' )
931,933c814,833
<         call build_pstab()
<         !
<         call build_cctab()
---
>       ALLOCATE( csc( n ) )
> !
>       DO i = 1, n
>          !
>          CALL gracsc( bec, nkbx, betae, cp, ngwx, i, csc, n )
>          !
>          ! calculate orthogonalized cp(i) : |cp(i)>=|cp(i)>-\sum_k<i csc(k)|cp(k)>
>          !
>          DO k = 1, i - 1
>             CALL daxpy( 2*ngw, -csc(k), cp(1,k), 1, cp(1,i), 1 )
>          END DO
>          anorm = cscnorm( bec, nkbx, cp, ngwx, i, n )
>          CALL dscal( 2*ngw, 1.0d0/anorm, cp(1,i), 1 )
>          !
>          !         these are the final bec's
>          !
>          CALL dscal( nkbx, 1.0d0/anorm, bec(1,i), 1 )
>       END DO
> !
>       DEALLOCATE( csc )
935,959c835,838
<      END IF
<      !
<      !     initialization that is common to all species
<      !
<      CALL interpolate_beta( tpre )
<      !
<      CALL interpolate_qradb( tpre )
<      !
<   ELSE
<      !
<      ! ... this is mainly for testing
<      !
<      CALL exact_beta( tpre )
<      !
<      CALL exact_qradb( tpre )
<      !
<   END IF
<   !
<   ! ... non-linear core-correction   ( rhocb(ig,is) )
<   !
<   CALL core_charge_ftr( tpre )
<   !
<   RETURN
<   !
< END SUBROUTINE newnlinit
---
>       CALL stop_clock( 'gram' )
> !
>       RETURN
>       END SUBROUTINE gram
962,1025c841,856
< subroutine nlfh_x( stress, bec_bgrp, dbec, lambda, descla )
<   !-----------------------------------------------------------------------
<   !
<   !     contribution to the internal stress tensor due to the constraints
<   !
<   USE kinds,             ONLY : DP
<   use uspp,              ONLY : nkb, qq
<   use uspp_param,        ONLY : nh, nhm, nvb, ish
<   use ions_base,         ONLY : na
<   use electrons_base,    ONLY : nbspx, nbsp, nudx, nspin, nupdwn, iupdwn, ibgrp_g2l
<   use cell_base,         ONLY : omega, h
<   use constants,         ONLY : pi, fpi, au_gpa
<   use io_global,         ONLY : stdout
<   use control_flags,     ONLY : iverbosity
<   USE descriptors,       ONLY : la_descriptor
<   USE mp,                ONLY : mp_sum
<   USE mp_global,         ONLY : intra_bgrp_comm, inter_bgrp_comm
< 
< !
<   implicit none
< 
<   TYPE(la_descriptor), INTENT(IN) :: descla(:)
<   REAL(DP), INTENT(INOUT) :: stress(3,3) 
<   REAL(DP), INTENT(IN)    :: bec_bgrp( :, : ), dbec( :, :, :, : )
<   REAL(DP), INTENT(IN)    :: lambda( :, :, : )
< !
<   INTEGER  :: i, j, ii, jj, inl, iv, jv, ia, is, iss, nss, istart
<   INTEGER  :: jnl, ir, ic, nr, nc, ibgrp_i, nrcx
<   REAL(DP) :: fpre(3,3), TT, T1, T2
<   !
<   REAL(DP), ALLOCATABLE :: tmpbec(:,:), tmpdh(:,:), temp(:,:), bec(:,:,:)
<   !
<   nrcx = MAXVAL( descla( : )%nrcx )
<   !
<   ALLOCATE( bec( nkb, nrcx, nspin ) )
<   !
<   DO iss = 1, nspin
<      IF( descla( iss )%active_node > 0 ) THEN
<         nss = nupdwn( iss )
<         istart = iupdwn( iss )
<         ic = descla( iss )%ic
<         nc = descla( iss )%nc
<         DO i=1,nc
<            ibgrp_i = ibgrp_g2l( i+istart-1+ic-1 )
<            IF( ibgrp_i > 0 ) THEN
<               bec( :, i, iss ) = bec_bgrp( :, ibgrp_i )
<            ELSE
<               bec( :, i, iss ) = 0.0d0
<            END IF
<         END DO
<      ELSE
<         bec(:,:,iss)   = 0.0d0
<      END IF
<   END DO
< 
<   CALL mp_sum( bec, inter_bgrp_comm )
<   !
<   IF( ( descla( 1 )%active_node > 0 ) .OR. ( descla( 2 )%active_node > 0 ) ) THEN
<      ALLOCATE ( tmpbec(nhm,nrcx), tmpdh(nrcx,nhm), temp(nrcx,nrcx) )
<   END IF
<   !
<   fpre = 0.d0
<   !
<   do ii=1,3
---
>       SUBROUTINE initbox ( tau0, taub, irb, ainv, a1, a2, a3 )
> !-----------------------------------------------------------------------
> !
> !     sets the indexes irb and positions taub for the small boxes 
> !     around atoms
> !
>       USE kinds,                    ONLY: DP
>       USE ions_base,                ONLY: nsp, na, nat
>       USE grid_dimensions,          ONLY: nr1, nr2, nr3
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx
>       USE control_flags,            ONLY: iprsta
>       USE io_global,                ONLY: stdout
>       USE mp_global,                ONLY: nproc_image, me_image
>       USE fft_base,                 ONLY: dfftb, dfftp, fft_dlay_descriptor
>       USE fft_types,                ONLY: fft_box_set
>       USE cvan,                     ONLY: nvb
1027c858,940
<      do jj=1,3
---
>       IMPLICIT NONE
> ! input
>       REAL(DP), INTENT(in)  :: tau0(3,nat)
> ! output
>       INTEGER,  INTENT(out) :: irb(3,nat)
>       REAL(DP), INTENT(out) :: taub(3,nat)
> ! input
>       REAL(DP), INTENT(in)  :: ainv(3,3)
>       REAL(DP), INTENT(in)  :: a1(3)
>       REAL(DP), INTENT(in)  :: a2(3)
>       REAL(DP), INTENT(in)  :: a3(3)
> ! local
>       REAL(DP) :: x(3), xmod
>       INTEGER  :: nr(3), nrb(3), xint, is, ia, i, isa
> !
>       IF ( nr1b < 1) CALL errore &
>          ('initbox', 'incorrect value for box grid dimensions', 1)
>       IF ( nr2b < 1) CALL errore &
>          ('initbox', 'incorrect value for box grid dimensions', 2)
>       IF ( nr3b < 1) CALL errore &
>          ('initbox', 'incorrect value for box grid dimensions', 3)
> 
>       nr (1)=nr1
>       nr (2)=nr2
>       nr (3)=nr3
>       nrb(1)=nr1b
>       nrb(2)=nr2b
>       nrb(3)=nr3b
> !
>       isa = 0
>       DO is=1,nsp
>          DO ia=1,na(is)
>            isa = isa + 1
> !
>             DO i=1,3
> !
> ! bring atomic positions to crystal axis
> !
>                x(i) = ainv(i,1)*tau0(1,isa) +                         &
>      &                ainv(i,2)*tau0(2,isa) +                         &
>      &                ainv(i,3)*tau0(3,isa)
> !
> ! bring x in the range between 0 and 1
> !
>                x(i) = MOD(x(i),1.d0)
>                IF (x(i).LT.0.d0) x(i)=x(i)+1.d0
> !
> ! case of nrb(i) even
> !
>                IF (MOD(nrb(i),2).EQ.0) THEN
> !
> ! find irb = index of the grid point at the corner of the small box
> !           (the indices of the small box run from irb to irb+nrb-1)
> !
>                   xint=INT(x(i)*nr(i))
>                   irb (i,isa)=xint+1-nrb(i)/2+1
>                   IF(irb(i,isa).LT.1) irb(i,isa)=irb(i,isa)+nr(i)
> !
> ! x(i) are the atomic positions in crystal coordinates, where the
> ! "crystal lattice" is the small box lattice and the origin is at
> ! the corner of the small box. Used to calculate phases exp(iG*taub)
> !
>                   xmod=x(i)*nr(i)-xint
>                   x(i)=(xmod+nrb(i)/2-1)/nr(i)
>                ELSE
> !
> ! case of nrb(i) odd - see above for comments
> !
>                   xint=NINT(x(i)*nr(i))
>                   irb (i,isa)=xint+1-(nrb(i)-1)/2
>                   IF(irb(i,isa).LT.1) irb(i,isa)=irb(i,isa)+nr(i)
>                   xmod=x(i)*nr(i)-xint
>                   x(i)=(xmod+(nrb(i)-1)/2)/nr(i)
>                END IF
>             END DO
> !
> ! bring back taub in cartesian coordinates
> !
>             DO i=1,3
>                taub(i,isa)= x(1)*a1(i) + x(2)*a2(i) + x(3)*a3(i)
>             END DO
>          END DO
>       END DO
1029c942,943
<         do is=1,nvb
---
>       CALL fft_box_set( dfftb, nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, &
>                         nat, irb, me_image+1, nproc_image, dfftp%npp, dfftp%ipp )
1031c945,955
<            do ia=1,na(is)
---
>       IF( iprsta > 2 ) THEN
>            isa = 1
>            DO is=1,nsp
>               WRITE( stdout, '( /, 2x, "species= ", i2 )' ) is
>               DO ia=1,na(is)
>                  WRITE( stdout,2000) ia, (irb(i,isa),i=1,3)
> 2000             FORMAT(2x, 'atom= ', i3, ' irb1= ', i3, ' irb2= ', i3, ' irb3= ', i3)
>                  isa = isa + 1
>                END DO
>             END DO
>       ENDIF
1033,1088c957,1572
<               do iss = 1, nspin
<                  !
<                  istart = iupdwn( iss )
<                  nss    = nupdwn( iss )
<                  !
<                  IF( descla( iss )%active_node > 0 ) THEN
< 
<                     nr = descla( iss )%nr
<                     nc = descla( iss )%nc
<                     ir = descla( iss )%ir
<                     ic = descla( iss )%ic
< 
<                     tmpbec = 0.d0
<                     tmpdh  = 0.d0
< !
<                     do iv=1,nh(is)
<                        do jv=1,nh(is)
<                           inl=ish(is)+(jv-1)*na(is)+ia
<                           if(abs(qq(iv,jv,is)).gt.1.e-5) then
<                              do i = 1, nc
<                                 tmpbec(iv,i) = tmpbec(iv,i) +  qq(iv,jv,is) * bec( inl, i, iss  )
<                              end do
<                           endif
<                        end do
<                     end do
< 
<                     do iv=1,nh(is)
<                        inl=ish(is)+(iv-1)*na(is)+ia
<                        do i = 1, nr
<                           tmpdh(i,iv) = dbec( inl, i + (iss-1)*nrcx, ii, jj )
<                        end do
<                     end do
< 
<                     if(nh(is).gt.0)then
< 
<                        CALL dgemm &
<                        ( 'N', 'N', nr, nc, nh(is), 1.0d0, tmpdh, nrcx, tmpbec, nhm, 0.0d0, temp, nrcx )
< 
<                        do j = 1, nc
<                           do i = 1, nr
<                              fpre(ii,jj) = fpre(ii,jj) + 2D0 * temp( i, j ) * lambda(i,j,iss)
<                           end do
<                        end do
<                     endif
< 
<                  END IF
<                  !
<               end do
<               !
<            end do
<            !
<         end do
<         !
<      end do
<      !
<   end do
---
> #ifdef __PARA
>       ! 
>       ! for processor that do not call fft on the box
>       ! artificially start the clock
>       ! 
>       CALL start_clock( 'fftb' )
>       CALL stop_clock( 'fftb' )
>       !
> #endif
> !
>       RETURN
>    END SUBROUTINE initbox
> !
> !-------------------------------------------------------------------------
>    SUBROUTINE newd(vr,irb,eigrb,rhovan,fion)
> !-----------------------------------------------------------------------
> !
> !     this routine calculates array deeq:
> !         deeq_i,lm = \int V_eff(r) q_i,lm(r) dr
> !     and the corresponding term in forces
> !         fion_i = \int V_eff(r) \sum_lm rho_lm (dq_i,lm(r)/dR_i) dr
> !     where
> !         rho_lm = \sum_j f_j <psi_j|beta_l><beta_m|psi_j>
> !
>       USE kinds,                    ONLY: dp
>       USE uspp_param,               ONLY: nh, nhm
>       USE uspp,                     ONLY: deeq
>       USE cvan,                     ONLY: nvb
>       USE ions_base,                ONLY: nat, nsp, na
>       USE constants,                ONLY: pi, fpi
>       USE grid_dimensions,          ONLY: nr3, nnr => nnrx
>       USE gvecb,                    ONLY: ngb, npb, nmb, gxb
>       USE small_box,                ONLY: omegab, tpibab
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, &
>                                           nr1bx, nr2bx, nr3bx, nnrb => nnrbx
>       USE qgb_mod,                  ONLY: qgb
>       USE electrons_base,           ONLY: nspin
>       USE control_flags,            ONLY: iprint, thdyn, tfor, tprnfor
>       USE mp,                       ONLY: mp_sum
>       USE mp_global,                ONLY: intra_image_comm
>       USE cp_interfaces,            ONLY: invfft
>       USE fft_base,                 ONLY: dfftb
> !
>       IMPLICIT NONE
> ! input
>       INTEGER irb(3,nat)
>       REAL(DP) rhovan(nhm*(nhm+1)/2,nat,nspin)
>       COMPLEX(DP) eigrb(ngb,nat)
>       REAL(DP)  vr(nnr,nspin)
> ! output
>       REAL(DP)  fion(3,nat)
> ! local
>       INTEGER isup,isdw,iss, iv,ijv,jv, ik, nfft, isa, ia, is, ig
>       REAL(DP)  fvan(3,nat,nvb), fac, fac1, fac2, boxdotgrid
>       COMPLEX(DP) ci, facg1, facg2
>       COMPLEX(DP), ALLOCATABLE :: qv(:)
>       EXTERNAL boxdotgrid
> !
>       IF ( nr1b==0 .OR. nr2b==0 .OR. nr3b==0 ) RETURN
>       CALL start_clock( 'newd' )
>       ci=(0.d0,1.d0)
>       fac=omegab/DBLE(nr1b*nr2b*nr3b)
>       deeq (:,:,:,:) = 0.d0
>       fvan (:,:,:) = 0.d0
> 
>       ALLOCATE( qv( nnrb ) )
> !
> ! calculation of deeq_i,lm = \int V_eff(r) q_i,lm(r) dr
> !
>       isa=1
>       DO is=1,nvb
> #ifdef __PARA
>          DO ia=1,na(is)
>             nfft=1
>             IF ( dfftb%np3( isa ) <= 0 ) go to 15
> #else
>          DO ia=1,na(is),2
>             nfft=2
> #endif
>             IF( ia .EQ. na(is) ) nfft=1
> !
> ! two ffts at the same time, on two atoms (if possible: nfft=2)
> !
>             DO iv=1,nh(is)
>                DO jv=iv,nh(is)
>                   ijv = (jv-1)*jv/2 + iv
>                   qv(:) = (0.d0, 0.d0)
>                   IF (nfft.EQ.2) THEN
>                      DO ig=1,ngb
>                         qv(npb(ig))= eigrb(ig,isa  )*qgb(ig,ijv,is)   &
>      &                          + ci*eigrb(ig,isa+1)*qgb(ig,ijv,is)
>                         qv(nmb(ig))= CONJG(                             &
>      &                               eigrb(ig,isa  )*qgb(ig,ijv,is))  &
>      &                          + ci*CONJG(                             &
>      &                               eigrb(ig,isa+1)*qgb(ig,ijv,is))
>                      END DO
>                   ELSE
>                      DO ig=1,ngb
>                         qv(npb(ig)) = eigrb(ig,isa)*qgb(ig,ijv,is)
>                         qv(nmb(ig)) = CONJG(                            &
>      &                                eigrb(ig,isa)*qgb(ig,ijv,is))
>                      END DO
>                   END IF
> !
>                   CALL invfft('Box',qv,dfftb,isa)
> !
>                   DO iss=1,nspin
>                      deeq(iv,jv,isa,iss) = fac *                        &
>      &                    boxdotgrid(irb(1,isa),1,qv,vr(1,iss))
>                      IF (iv.NE.jv)                                      &
>      &                    deeq(jv,iv,isa,iss)=deeq(iv,jv,isa,iss)
> !
>                      IF (nfft.EQ.2) THEN
>                         deeq(iv,jv,isa+1,iss) = fac*                    &
>      &                       boxdotgrid(irb(1,isa+1),2,qv,vr(1,iss))
>                         IF (iv.NE.jv)                                   &
>      &                       deeq(jv,iv,isa+1,iss)=deeq(iv,jv,isa+1,iss)
>                      END IF
>                   END DO
>                END DO
>             END DO
>   15        isa=isa+nfft
>          END DO
>       END DO
> 
>       CALL mp_sum( deeq, intra_image_comm )
> 
>       IF (.NOT.( tfor .OR. thdyn .OR. tprnfor ) ) go to 10
> !
> ! calculation of fion_i = \int V_eff(r) \sum_lm rho_lm (dq_i,lm(r)/dR_i) dr
> !
>       isa=1
>       IF(nspin.EQ.1) THEN
> !     =================================================================
> !     case nspin=1: two ffts at the same time, on two atoms (if possible)
> !     -----------------------------------------------------------------
>          iss=1
>          isa=1
>          DO is=1,nvb
> #ifdef __PARA
>             DO ia=1,na(is)
>                nfft=1
>                IF ( dfftb%np3( isa ) <= 0 ) go to 20
> #else
>             DO ia=1,na(is),2
>                nfft=2
> #endif
>                IF( ia.EQ.na(is)) nfft=1
>                DO ik=1,3
>                   qv(:) = (0.d0, 0.d0)
>                   DO iv=1,nh(is)
>                      DO jv=iv,nh(is)
>                         ijv = (jv-1)*jv/2 + iv
>                         IF(iv.NE.jv) THEN
>                            fac1=2.d0*fac*tpibab*rhovan(ijv,isa,iss)
>                            IF (nfft.EQ.2) fac2=2.d0*fac*tpibab*         &
>      &                                           rhovan(ijv,isa+1,iss)
>                         ELSE
>                            fac1=     fac*tpibab*rhovan(ijv,isa,iss)
>                            IF (nfft.EQ.2) fac2=     fac*tpibab*        &
>      &                                           rhovan(ijv,isa+1,iss)
>                         ENDIF
>                         IF (nfft.EQ.2) THEN
>                            DO ig=1,ngb
>                               facg1 = CMPLX(0.d0,-gxb(ik,ig),kind=DP) * &
>      &                                   qgb(ig,ijv,is) * fac1
>                               facg2 = CMPLX(0.d0,-gxb(ik,ig),kind=DP) * &
>      &                                   qgb(ig,ijv,is) * fac2
>                               qv(npb(ig)) = qv(npb(ig))                 &
>      &                                    +    eigrb(ig,isa  )*facg1    &
>      &                                    + ci*eigrb(ig,isa+1)*facg2
>                               qv(nmb(ig)) = qv(nmb(ig))                 &
>      &                                +   CONJG(eigrb(ig,isa  )*facg1)&
>      &                                +ci*CONJG(eigrb(ig,isa+1)*facg2)
>                            END DO
>                         ELSE
>                            DO ig=1,ngb
>                               facg1 = CMPLX(0.d0,-gxb(ik,ig),kind=DP) * &
>      &                                   qgb(ig,ijv,is)*fac1
>                               qv(npb(ig)) = qv(npb(ig))                 &
>      &                                    +    eigrb(ig,isa)*facg1
>                               qv(nmb(ig)) = qv(nmb(ig))                 &
>      &                               +  CONJG( eigrb(ig,isa)*facg1)
>                            END DO
>                         END IF
>                      END DO
>                   END DO
> !
>                   CALL invfft('Box',qv,dfftb,isa)
> !
>                   fvan(ik,ia,is) =                                      &
>      &                    boxdotgrid(irb(1,isa),1,qv,vr(1,iss))
> !
>                   IF (nfft.EQ.2) fvan(ik,ia+1,is) =                     &
>      &                    boxdotgrid(irb(1,isa+1),2,qv,vr(1,iss))
>                END DO
>  20            isa = isa+nfft
>             END DO
>          END DO
>       ELSE
> !     =================================================================
> !     case nspin=2: up and down spin fft's combined into a single fft
> !     -----------------------------------------------------------------
>          isup=1
>          isdw=2
>          isa=1
>          DO is=1,nvb
>             DO ia=1,na(is)
> #ifdef __PARA
>                IF ( dfftb%np3( isa ) <= 0 ) go to 25
> #endif
>                DO ik=1,3
>                   qv(:) = (0.d0, 0.d0)
> !
>                   DO iv=1,nh(is)
>                      DO jv=iv,nh(is)
>                         ijv = (jv-1)*jv/2 + iv
>                         IF(iv.NE.jv) THEN
>                            fac1=2.d0*fac*tpibab*rhovan(ijv,isa,isup)
>                            fac2=2.d0*fac*tpibab*rhovan(ijv,isa,isdw)
>                         ELSE
>                            fac1=     fac*tpibab*rhovan(ijv,isa,isup)
>                            fac2=     fac*tpibab*rhovan(ijv,isa,isdw)
>                         END IF
>                         DO ig=1,ngb
>                            facg1 = fac1 * CMPLX(0.d0,-gxb(ik,ig),kind=DP) * &
>      &                                qgb(ig,ijv,is) * eigrb(ig,isa)
>                            facg2 = fac2 * CMPLX(0.d0,-gxb(ik,ig),kind=DP) * &
>      &                                qgb(ig,ijv,is) * eigrb(ig,isa)
>                            qv(npb(ig)) = qv(npb(ig))                    &
>      &                                    + facg1 + ci*facg2
>                            qv(nmb(ig)) = qv(nmb(ig))                    &
>      &                                    +CONJG(facg1)+ci*CONJG(facg2)
>                         END DO
>                      END DO
>                   END DO
> !
>                   CALL invfft('Box',qv,dfftb,isa)
> !
>                   fvan(ik,ia,is) =                                      &
>      &                    boxdotgrid(irb(1,isa),isup,qv,vr(1,isup)) + &
>      &                    boxdotgrid(irb(1,isa),isdw,qv,vr(1,isdw))
>                END DO
> 25             isa = isa+1
>             END DO
>          END DO
>       END IF
> 
>       CALL mp_sum( fvan, intra_image_comm )
> 
>       isa = 0
>       DO is = 1, nvb
>         DO ia = 1, na(is)
>           isa = isa + 1
>           fion(:,isa) = fion(:,isa) - fvan(:,ia,is)
>         END DO
>       END DO
> 
>   10  CONTINUE
>       DEALLOCATE( qv )
> !
>       CALL stop_clock( 'newd' )
> !
>       RETURN
>       END SUBROUTINE newd
> 
> 
> !-------------------------------------------------------------------------
>       SUBROUTINE nlfl(bec,becdr,lambda,fion)
> !-----------------------------------------------------------------------
> !     contribution to fion due to the orthonormality constraint
> ! 
> !
>       USE kinds,             ONLY: DP
>       USE io_global,         ONLY: stdout
>       USE ions_base,         ONLY: na, nsp, nat
>       USE uspp,              ONLY: nhsa=>nkb, qq
>       USE uspp_param,        ONLY: nhm, nh
>       USE cvan,              ONLY: ish, nvb
>       USE electrons_base,    ONLY: nbspx, nbsp, nudx, nspin, iupdwn, nupdwn
>       USE constants,         ONLY: pi, fpi
>       USE cp_main_variables, ONLY: nlam, nlax, descla, la_proc
>       USE descriptors,       ONLY: nlar_ , nlac_ , ilar_ , ilac_ 
>       USE mp,                ONLY: mp_sum
>       USE mp_global,         ONLY: intra_image_comm
> !
>       IMPLICIT NONE
>       REAL(DP) bec(nhsa,nbsp), becdr(nhsa,nspin*nlax,3), lambda(nlam,nlam,nspin)
>       REAL(DP) fion(3,nat)
> !
>       INTEGER :: k, is, ia, iv, jv, i, j, inl, isa, iss, nss, istart, ir, ic, nr, nc
>       REAL(DP), ALLOCATABLE :: temp(:,:), tmpbec(:,:),tmpdr(:,:) 
>       REAL(DP), ALLOCATABLE :: fion_tmp(:,:)
>       !
>       CALL start_clock( 'nlfl' )
>       !
>       ALLOCATE( fion_tmp( 3, nat ) )
>       !
>       fion_tmp = 0.0d0
>       !
> 
>       ALLOCATE( temp( nlax, nlax ), tmpbec( nhm, nlax ), tmpdr( nlax, nhm ) )
> 
>       DO k=1,3
>          isa = 0
>          DO is=1,nvb
>             DO ia=1,na(is)
>                isa = isa + 1
>                !
>                DO iss = 1, nspin
>                   !
>                   nss = nupdwn( iss )
>                   istart = iupdwn( iss )
>                   !
>                   tmpbec = 0.d0
>                   tmpdr  = 0.d0
> !
>                   IF( la_proc ) THEN
>                      ! tmpbec distributed by columns
>                      ic = descla( ilac_ , iss )
>                      nc = descla( nlac_ , iss )
>                      DO iv=1,nh(is)
>                         DO jv=1,nh(is)
>                            inl=ish(is)+(jv-1)*na(is)+ia
>                            IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN
>                               DO i=1,nc
>                                  tmpbec(iv,i)=tmpbec(iv,i) + qq(iv,jv,is)*bec(inl,i+istart-1+ic-1)
>                               END DO
>                            ENDIF
>                         END DO
>                      END DO
>                      ! tmpdr distributed by rows
>                      ir = descla( ilar_ , iss )
>                      nr = descla( nlar_ , iss )
>                      DO iv=1,nh(is)
>                         inl=ish(is)+(iv-1)*na(is)+ia
>                         DO i=1,nr
>                            tmpdr(i,iv)=becdr(inl,i+(iss-1)*nlax,k)
>                         END DO
>                      END DO
>                   END IF
> !
>                   IF(nh(is).GT.0)THEN
>                      !
>                      IF( la_proc ) THEN
>                         ir = descla( ilar_ , iss )
>                         ic = descla( ilac_ , iss )
>                         nr = descla( nlar_ , iss )
>                         nc = descla( nlac_ , iss )
>                         CALL dgemm( 'N', 'N', nr, nc, nh(is), 1.0d0, tmpdr, nlax, tmpbec, nhm, 0.0d0, temp, nlax )
>                         DO j = 1, nc
>                            DO i = 1, nr
>                               fion_tmp(k,isa) = fion_tmp(k,isa) + 2D0 * temp( i, j ) * lambda( i, j, iss )
>                            END DO
>                         END DO
>                      END IF
> !
>                   ENDIF
> 
>                END DO
> !
>             END DO
>          END DO
>       END DO
>       !
>       DEALLOCATE( temp, tmpbec, tmpdr )
>       !
>       CALL mp_sum( fion_tmp, intra_image_comm )
>       !
>       fion = fion + fion_tmp
>       !
>       DEALLOCATE( fion_tmp )
>       !
>       CALL stop_clock( 'nlfl' )
>       !
>       RETURN
> 
>       END SUBROUTINE nlfl
> 
> 
> 
> 
> 
> !
> !-----------------------------------------------------------------------
>       SUBROUTINE pbc(rin,a1,a2,a3,ainv,rout)
> !-----------------------------------------------------------------------
> !
> !     brings atoms inside the unit cell
> !
>       USE kinds,  ONLY: DP
> 
>       IMPLICIT NONE
> ! input
>       REAL(DP) rin(3), a1(3),a2(3),a3(3), ainv(3,3)
> ! output
>       REAL(DP) rout(3)
> ! local
>       REAL(DP) x,y,z
> !
> ! bring atomic positions to crystal axis
> !
>       x = ainv(1,1)*rin(1)+ainv(1,2)*rin(2)+ainv(1,3)*rin(3)
>       y = ainv(2,1)*rin(1)+ainv(2,2)*rin(2)+ainv(2,3)*rin(3)
>       z = ainv(3,1)*rin(1)+ainv(3,2)*rin(2)+ainv(3,3)*rin(3)
> !
> ! bring x,y,z in the range between -0.5 and 0.5
> !
>       x = x - NINT(x)
>       y = y - NINT(y)
>       z = z - NINT(z)
> !
> ! bring atomic positions back in cartesian axis
> !
>       rout(1) = x*a1(1)+y*a2(1)+z*a3(1)
>       rout(2) = x*a1(2)+y*a2(2)+z*a3(2)
>       rout(3) = x*a1(3)+y*a2(3)+z*a3(3)
> !
>       RETURN
>       END SUBROUTINE pbc
> 
> !
> !-------------------------------------------------------------------------
>       SUBROUTINE prefor(eigr,betae)
> !-----------------------------------------------------------------------
> !
> !     input :        eigr =  e^-ig.r_i
> !     output:        betae_i,i(g) = (-i)**l beta_i,i(g) e^-ig.r_i 
> !
>       USE kinds,      ONLY : DP
>       USE ions_base,  ONLY : nsp, na, nat
>       USE gvecw,      ONLY : ngw
>       USE cvan,       ONLY : ish
>       USE uspp,       ONLY : nkb, beta, nhtol
>       USE uspp_param, ONLY : nh
> !
>       IMPLICIT NONE
>       COMPLEX(DP) :: eigr( ngw, nat )
>       COMPLEX(DP) :: betae( ngw, nkb )
> !
>       INTEGER     :: is, iv, ia, inl, ig, isa
>       COMPLEX(DP) :: ci
> !
>       CALL start_clock( 'prefor' )
>       isa = 0
>       DO is=1,nsp
>          DO iv=1,nh(is)
>             ci=(0.0d0,-1.0d0)**nhtol(iv,is)
>             DO ia=1,na(is)
>                inl=ish(is)+(iv-1)*na(is)+ia
>                DO ig=1,ngw
>                   betae(ig,inl)=ci*beta(ig,iv,is)*eigr(ig,ia+isa)
>                END DO
>             END DO
>          END DO
>          isa = isa + na(is)
>       END DO
>       CALL stop_clock( 'prefor' )
> !
>       RETURN
>       END SUBROUTINE prefor
> !
> !-----------------------------------------------------------------------
>    SUBROUTINE projwfc( c, nx, eigr, betae, n, ei  )
> !-----------------------------------------------------------------------
>       !
>       ! Projection on atomic wavefunctions
>       !
>       USE kinds,              ONLY: DP
>       USE constants,          ONLY: autoev
>       USE io_global,          ONLY: stdout
>       USE mp_global,          ONLY: intra_image_comm
>       USE mp,                 ONLY: mp_sum
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart
>       USE ions_base,          ONLY: nsp, na, nat
>       USE uspp,               ONLY: nhsa => nkb
>       USE uspp_param,         ONLY: upf
> !
>       IMPLICIT NONE
>       INTEGER,     INTENT(IN) :: nx, n
>       COMPLEX(DP), INTENT(IN) :: c( ngw, nx ), eigr(ngw,nat), betae(ngw,nhsa)
>       REAL(DP),    INTENT(IN) :: ei( nx )
> !
>       COMPLEX(DP), ALLOCATABLE :: wfc(:,:), swfc(:,:), becwfc(:,:)
>       REAL(DP),    ALLOCATABLE :: overlap(:,:), e(:), z(:,:)
>       REAL(DP),    ALLOCATABLE :: proj(:,:), temp(:)
>       REAL(DP)                 :: somma
> 
>       INTEGER :: n_atomic_wfc
>       INTEGER :: is, ia, nb, l, m, k, i
>       !
>       ! calculate number of atomic states
>       !
>       n_atomic_wfc = 0
>       !
>       DO is=1,nsp
>          DO nb = 1,upf(is)%nwfc
>             l = upf(is)%lchi(nb)
>             n_atomic_wfc = n_atomic_wfc + (2*l+1)*na(is)
>          END DO
>       END DO
>       IF ( n_atomic_wfc .EQ. 0 ) RETURN
>       !
>       ALLOCATE( wfc( ngw, n_atomic_wfc ) )
>       !
>       ! calculate wfc = atomic states
>       !
>       CALL atomic_wfc( eigr, n_atomic_wfc, wfc )
>       !
>       ! calculate bec = <beta|wfc>
>       !
>       ALLOCATE( becwfc( nhsa, n_atomic_wfc ) )
>       !
>       CALL nlsm1( n_atomic_wfc, 1, nsp, eigr, wfc, becwfc )
>       !
>       ! calculate swfc = S|wfc>
>       !
>       ALLOCATE( swfc( ngw, n_atomic_wfc ) )
>       !
>       CALL s_wfc( n_atomic_wfc, becwfc, betae, wfc, swfc )
>       !
>       ! calculate overlap(i,j) = <wfc_i|S|wfc_j> 
>       !
>       ALLOCATE( overlap( n_atomic_wfc, n_atomic_wfc ) )
> 
>       CALL dgemm &
>            ( 'T', 'N', n_atomic_wfc, n_atomic_wfc, 2*ngw, 1.0d0, wfc, 2*ngw, &
>              swfc, 2*ngw, 0.0d0, overlap, n_atomic_wfc )
> 
>       CALL mp_sum( overlap, intra_image_comm )
> 
>       overlap = overlap * 2.d0
>       IF (gstart == 2) THEN
>          DO l=1,n_atomic_wfc
>             DO m=1,n_atomic_wfc
>                overlap(m,l)=overlap(m,l)-DBLE(wfc(1,m))*DBLE(swfc(1,l))
>             END DO
>          END DO
>       END IF
>       !
>       ! calculate (overlap)^(-1/2)(i,j). An orthonormal set of vectors |wfc_i>
>       ! is obtained by introducing |wfc_j>=(overlap)^(-1/2)(i,j)*S|wfc_i>
>       !
>       ALLOCATE(z(n_atomic_wfc,n_atomic_wfc))
>       ALLOCATE(e(n_atomic_wfc))
>       !
>       CALL rdiag( n_atomic_wfc, overlap, n_atomic_wfc, e, z )
>       !
>       overlap=0.d0
>       !
>       DO l=1,n_atomic_wfc
>          DO m=1,n_atomic_wfc
>             DO k=1,n_atomic_wfc
>                overlap(l,m)=overlap(l,m)+z(m,k)*z(l,k)/SQRT(e(k))
>             END DO
>          END DO
>       END DO
>       !
>       DEALLOCATE(e)
>       DEALLOCATE(z)
>       !
>       ! calculate |wfc_j>=(overlap)^(-1/2)(i,j)*S|wfc_i>   (note the S matrix!)
>       !
>       wfc=0.d0
>       DO m=1,n_atomic_wfc
>          DO l=1,n_atomic_wfc
>             wfc(:,m)=wfc(:,m)+overlap(l,m)*swfc(:,l)
>          END DO
>       END DO
>       DEALLOCATE(overlap)
>       DEALLOCATE(swfc)
>       DEALLOCATE(becwfc)
>       !
>       ! calculate proj = <c|S|wfc> 
>       !
>       ALLOCATE(proj(n,n_atomic_wfc))
> 
>       ALLOCATE(temp(ngw))
> 
>       DO m=1,n
>          DO l=1,n_atomic_wfc
>             temp(:)=DBLE(CONJG(c(:,m))*wfc(:,l))
>             proj(m,l)=2.d0*SUM(temp)
>             IF (gstart == 2) proj(m,l)=proj(m,l)-temp(1)
>          END DO
>       END DO
> 
>       DEALLOCATE(temp)
> 
>       CALL mp_sum( proj, intra_image_comm )
> 
>       i=0
>       WRITE( stdout,  90 ) 
>       WRITE( stdout, 100 )
>       DO is=1,nsp
>          DO nb = 1,upf(is)%nwfc
>             l=upf(is)%lchi(nb)
>             DO m = -l,l
>                DO ia=1,na(is)
>                   i=i+1
>                END DO
>                WRITE( stdout, 110 ) i-na(is)+1, i, na(is), is, nb, l, m
>             END DO
>          END DO
>       END DO
> 
>       WRITE( stdout,*)
>       DO m=1,n
>          somma=0.d0
>          DO l=1,n_atomic_wfc
>             somma=somma+proj(m,l)**2
>          END DO
>          WRITE( stdout, 120 ) m, somma, ei(m)*autoev
>          WRITE( stdout, 130 ) (ABS(proj(m,l)),l=1,n_atomic_wfc)
>       END DO
1090c1574,1578
<   CALL mp_sum( fpre, intra_bgrp_comm )
---
>   90  FORMAT( 3X,'Projection on atomic states')
>  100  FORMAT( 3X,'atomic state    atom   specie  wfc  l  m')
>  110  FORMAT( 3X, I4, ' - ', I4, 4X, I4, 6X, I3,   I5, I4,I3)
>  120  FORMAT( 3X,'state # ',i4,'    sum c^2 = ',f7.4, ' eV = ', F7.2 )
>  130  FORMAT( 3X, 10f7.4)
1092,1113d1579
<   do i=1,3
<      do j=1,3
<         stress(i,j)=stress(i,j)+ &
<                     (fpre(i,1)*h(j,1)+fpre(i,2)*h(j,2)+fpre(i,3)*h(j,3))/omega
<      enddo
<   enddo
< 
<   IF( ( descla( 1 )%active_node > 0 ) .OR. ( descla( 2 )%active_node > 0 ) ) THEN
<      DEALLOCATE ( tmpbec, tmpdh, temp )
<   END IF
< 
<   DEALLOCATE( bec )
< 
< 
<   IF( iverbosity > 2 ) THEN
<      WRITE( stdout,*) 
<      WRITE( stdout,*) "constraints contribution to stress"
<      WRITE( stdout,5555) ((-fpre(i,j),j=1,3),i=1,3)
<      fpre = MATMUL( fpre, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
<      WRITE( stdout,5555) ((fpre(i,j),j=1,3),i=1,3)
<      WRITE( stdout,*) 
<   END IF
1114a1581,1584
>       DEALLOCATE(proj)
>       DEALLOCATE(wfc)
>       RETURN
>       END SUBROUTINE projwfc
1116,1118c1586,1617
< 5555  FORMAT(1x,f12.5,1x,f12.5,1x,f12.5/                                &
<      &       1x,f12.5,1x,f12.5,1x,f12.5/                                &
<      &       1x,f12.5,1x,f12.5,1x,f12.5//)
---
> !
> !-----------------------------------------------------------------------
>       SUBROUTINE rdiag ( n, h, ldh, e, v )
> !-----------------------------------------------------------------------
> !
> !   calculates all the eigenvalues and eigenvectors of a complex
> !   hermitean matrix H . On output, the matrix H is destroyed
> !
>       USE kinds,            ONLY: DP
>       USE dspev_module,     ONLY: dspev_drv
>       !
>       IMPLICIT NONE
>       !
>       INTEGER,  INTENT(in)   :: n, ldh
>       REAL(DP), INTENT(inout):: h(ldh,n)
>       REAL(DP), INTENT(out)  :: e(n)
>       REAL(DP), INTENT(out)  :: v(ldh,n)
> !
>       INTEGER :: i, j, k
>       REAL(DP), ALLOCATABLE :: ap( : )
> !
>       ALLOCATE( ap( n * ( n + 1 ) / 2 ) )
> 
>       K = 0
>       DO J = 1, n
>          DO I = J, n
>             K = K + 1
>             ap( k ) = h( i, j )
>          END DO
>       END DO
> 
>       CALL dspev_drv( 'V', 'L', n, ap, e, v, ldh )
1120,1121c1619,1622
<   return
< end subroutine nlfh_x
---
>       DEALLOCATE( ap )
> !
>       RETURN
>       END SUBROUTINE rdiag
1122a1624,1682
> !
> !
> !-------------------------------------------------------------------------
>       SUBROUTINE s_wfc(n_atomic_wfc1,becwfc,betae,wfc,swfc) !#@@@ Changed n_atomic_wfc to n_atomic_wfc1
> !-----------------------------------------------------------------------
> !
> !     input: wfc, becwfc=<wfc|beta>, betae=|beta>
> !     output: swfc=S|wfc>
> !
>       USE kinds, ONLY: DP
>       USE ions_base, ONLY: na
>       USE cvan, ONLY: nvb, ish
>       USE uspp, ONLY: nhsa => nkb, nhsavb=>nkbus, qq
>       USE uspp_param, ONLY: nh
>       USE gvecw, ONLY: ngw
>       USE constants, ONLY: pi, fpi
>       IMPLICIT NONE
> ! input
>       INTEGER, INTENT(in)         :: n_atomic_wfc1
>       COMPLEX(DP), INTENT(in) :: betae(ngw,nhsa),                   &
>      &                               wfc(ngw,n_atomic_wfc1)
>       REAL(DP), INTENT(in)    :: becwfc(nhsa,n_atomic_wfc1)
> ! output
>       COMPLEX(DP), INTENT(out):: swfc(ngw,n_atomic_wfc1)
> ! local
>       INTEGER is, iv, jv, ia, inl, jnl, i
>       REAL(DP) qtemp(nhsavb,n_atomic_wfc1)
> !
>       swfc = wfc
> !
>       IF (nvb.GT.0) THEN
>          qtemp=0.d0
>          DO is=1,nvb
>             DO iv=1,nh(is)
>                DO jv=1,nh(is)
>                   IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN
>                      DO ia=1,na(is)
>                         inl=ish(is)+(iv-1)*na(is)+ia
>                         jnl=ish(is)+(jv-1)*na(is)+ia
>                         DO i=1,n_atomic_wfc1
>                            qtemp(inl,i) = qtemp(inl,i) +                &
>      &                                    qq(iv,jv,is)*becwfc(jnl,i)
>                         END DO
>                      END DO
>                   ENDIF
>                END DO
>             END DO
>          END DO
> !
>          CALL dgemm &
>               ('N','N',2*ngw,n_atomic_wfc1,nhsavb,1.0d0,betae,2*ngw,&
>                qtemp,nhsavb,1.0d0,swfc,2*ngw)
> !
>       END IF
> !
> !      swfc=swfc+wfc
> !
>       RETURN
>       END SUBROUTINE s_wfc
1125,1159c1685,1832
< subroutine nlinit
<   !-----------------------------------------------------------------------
<   !
<   !     this routine allocates and initalizes arrays beta, qq, qgb,
<   !     rhocb, and derivatives w.r.t. cell parameters dbeta
<   !
<   !       beta(ig,l,is) = 4pi/sqrt(omega) y^r(l,q^)
<   !                               int_0^inf dr r^2 j_l(qr) betar(l,is,r)
<   !
<   !       Note that beta(g)_lm,is = (-i)^l*beta(ig,l,is) (?)
<   !
<   !       qq_ij=int_0^r q_ij(r)=omega*qg(g=0)
<   !
<   !     beta and qradb are first calculated on a fixed linear grid in |G|
<   !     (betax, qradx) then calculated on the box grid by interpolation
<   !     (this is done in routine newnlinit)
<   !
<       use kinds,           ONLY : dp
<       use control_flags,   ONLY : iprint, tpre
<       use io_global,       ONLY : stdout, ionode
<       use gvecw,           ONLY : ngw
<       use core,            ONLY : rhocb, allocate_core
<       use constants,       ONLY : pi, fpi
<       use ions_base,       ONLY : na, nsp
<       use uspp,            ONLY : aainit, beta, qq, dvan, nhtol, nhtolm, indv,&
<                                   dbeta
<       use uspp_param,      ONLY : upf, lmaxq, nbetam, lmaxkb, nhm, nh, ish, nvb
<       use atom,            ONLY : rgrid
<       use qgb_mod,         ONLY : qgb, dqgb
<       use smallbox_gvec,   ONLY : ngb
<       use gvect,           ONLY : ngm
<       use cp_interfaces,   ONLY : pseudopotential_indexes, compute_dvan, &
<                                   compute_betagx, compute_qradx, build_pstab, build_cctab
<       USE fft_base,        ONLY : dfftp
<       use pseudopotential, ONLY : tpstab
---
>       SUBROUTINE spinsq (c,bec,rhor)
> !-----------------------------------------------------------------------
> !
> !     estimate of <S^2>=s(s+1) in two different ways.
> !     1) using as many-body wavefunction a single Slater determinant
> !        constructed with Kohn-Sham orbitals:
> !
> !        <S^2> = (Nup-Ndw)/2 * (Nup-Ndw)/2+1) + Ndw - 
> !                \sum_up\sum_dw < psi_up | psi_dw >
> !
> !        where Nup, Ndw = number of up and down states, the sum is over 
> !        occupied states. Not suitable for fractionary occupancy.
> !        In the ultrasoft scheme (c is the smooth part of \psi): 
> !
> !        < psi_up | psi_dw > = \sum_G c*_up(G) c_dw(G) +
> !                              \int Q_ij <c_up|beta_i><beta_j|c_dw>
> !
> !        This is the usual formula, unsuitable for fractionary occupancy.
> !     2) using the "LSD model" of Wang, Becke, Smith, JCP 102, 3477 (1995):
> !
> !        <S^2> = (Nup-Ndw)/2 * (Nup-Ndw)/2+1) + Ndw -
> !                \int max(rhoup(r),rhodw(r)) dr
> !
> !     Requires on input: c=psi, bec=<c|beta>, rhoup(r), rhodw(r)
> !     Assumes real psi, with only half G vectors.
> !
>       USE electrons_base, ONLY: nx => nbspx, n => nbsp, iupdwn, nupdwn, f, nel, nspin
>       USE io_global, ONLY: stdout
>       USE mp_global, ONLY: intra_image_comm
>       USE mp, ONLY: mp_sum
>       USE gvecw, ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart
>       USE grid_dimensions, ONLY: nr1, nr2, nr3, &
>             nnr => nnrx
>       USE cell_base, ONLY: omega
>       USE cvan, ONLY: nvb, ish
>       USE uspp, ONLY: nhsa => nkb, nhsavb=>nkbus, qq
>       USE uspp_param, ONLY: nh
>       USE ions_base, ONLY: na
> !
>       IMPLICIT NONE
> ! input
>       REAL(8) bec(nhsa,n), rhor(nnr,nspin)
>       COMPLEX(8) c(ngw,nx)
> ! local variables
>       INTEGER nup, ndw, ir, i, j, jj, ig, ia, is, iv, jv, inl, jnl
>       REAL(8) spin0, spin1, spin2, fup, fdw
>       REAL(8), ALLOCATABLE:: overlap(:,:), temp(:)
>       LOGICAL frac
> !
> !
>       IF (nspin.EQ.1) RETURN
> !
> ! find spin-up and spin-down states
> !
>       fup = 0.0d0
>       DO i=iupdwn(1),nupdwn(1)
>          fup = fup + f(i)
>       END DO
>       nup = NINT(fup)
>       ndw = nel(1)+nel(2) - nup
> !
> ! paranoid checks
> !
>       frac= ABS(fup-nup).GT.1.0d-6
>       fup = 0.0d0
>       DO i=1,nup
>          fup = fup + f(i)
>       END DO
>       frac=frac.OR.ABS(fup-nup).GT.1.0d-6
>       fdw = 0.0d0
>       DO j=iupdwn(2),iupdwn(2)-1+ndw
>          fdw = fdw + f(j)
>       END DO
>       frac=frac.OR.ABS(fdw-ndw).GT.1.0d-6
> !
>       spin0 = ABS(fup-fdw)/2.d0 * ( ABS(fup-fdw)/2.d0 + 1.d0 ) + fdw
> !
> !     Becke's formula for spin polarization
> !
>       spin1 = 0.0d0
>       DO ir=1,nnr
>          spin1 = spin1 - MIN(rhor(ir,1),rhor(ir,2))
>       END DO
>       CALL mp_sum( spin1, intra_image_comm )
>       spin1 = spin0 + omega/(nr1*nr2*nr3)*spin1
>       IF (frac) THEN
>          WRITE( stdout,'(/'' Spin contamination: s(s+1)='',f5.2,'' (Becke) '',&
>      &                             f5.2,'' (expected)'')')              &
>      &          spin1, ABS(fup-fdw)/2.d0*(ABS(fup-fdw)/2.d0+1.d0)
>          RETURN
>       END IF
> !
> !     Slater formula, smooth contribution to  < psi_up | psi_dw >
> !
>       ALLOCATE (overlap(nup,ndw))
>       ALLOCATE (temp(ngw))
>       DO j=1,ndw
>          jj=j+iupdwn(2)-1
>          DO i=1,nup
>             overlap(i,j)=0.d0
>             DO ig=1,ngw
>                temp(ig)=DBLE(CONJG(c(ig,i))*c(ig,jj))
>             END DO
>             overlap(i,j) = 2.d0*SUM(temp)
>             IF (gstart == 2) overlap(i,j) = overlap(i,j) - temp(1)
>          END DO
>       END DO
>       DEALLOCATE (temp)
>       CALL mp_sum( overlap, intra_image_comm )
>       DO j=1,ndw
>          jj=j+iupdwn(2)-1
>          DO i=1,nup
> !
> !     vanderbilt contribution to  < psi_up | psi_dw >
> !
>             DO is=1,nvb
>                DO iv=1,nh(is)
>                   DO jv=1,nh(is)
>                      IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN 
>                         DO ia=1,na(is)
>                            inl=ish(is)+(iv-1)*na(is)+ia
>                            jnl=ish(is)+(jv-1)*na(is)+ia
>                            overlap(i,j) = overlap(i,j) +                &
>      &                          qq(iv,jv,is)*bec(inl,i)*bec(jnl,jj)
>                         END DO
>                      ENDIF
>                   END DO
>                END DO
>             END DO
>          END DO
>       END DO
> !
>       spin2 = spin0
>       DO j=1,ndw
>          DO i=1,nup
>             spin2 = spin2 - overlap(i,j)**2
>          END DO
>       END DO
> !
>       DEALLOCATE (overlap)
> !
>       WRITE( stdout,'(/" Spin contamination: s(s+1)=",f5.2," (Slater) ",  &
>      &          f5.2," (Becke) ",f5.2," (expected)")')              &
>      &     spin2,spin1, ABS(fup-fdw)/2.d0*(ABS(fup-fdw)/2.d0+1.d0)
> !
>       RETURN
>       END SUBROUTINE spinsq
1162c1835,2297
<       implicit none
---
> !-----------------------------------------------------------------------
>       SUBROUTINE vofrho( nfi, rhor, rhog, rhos, rhoc, tfirst, tlast,           &
>      &     ei1, ei2, ei3, irb, eigrb, sfac, tau0, fion )
> !-----------------------------------------------------------------------
> !     computes: the one-particle potential v in real space,
> !               the total energy etot,
> !               the forces fion acting on the ions,
> !               the derivative of total energy to cell parameters h
> !     rhor input : electronic charge on dense real space grid
> !                  (plus core charge if present)
> !     rhog input : electronic charge in g space (up to density cutoff)
> !     rhos input : electronic charge on smooth real space grid
> !     rhor output: total potential on dense real space grid
> !     rhos output: total potential on smooth real space grid
> !
>       USE kinds,              ONLY: dp
>       USE control_flags,      ONLY: iprint, iprsta, thdyn, tpre, tfor, &
>                                     tprnfor, iesr, textfor
>       USE io_global,          ONLY: stdout
>       USE ions_base,          ONLY: nsp, na, nat, rcmax, compute_eextfor
>       USE gvecs
>       USE gvecp,              ONLY: ng => ngm
>       USE cell_base,          ONLY: omega, r_to_s
>       USE cell_base,          ONLY: a1, a2, a3, tpiba2, h, ainv
>       USE reciprocal_vectors, ONLY: gstart, g, gx
>       USE recvecs_indexes,    ONLY: np, nm
>       USE grid_dimensions,    ONLY: nr1, nr2, nr3, &
>                                     nr1x, nr2x, nr3x, nnr => nnrx
>       USE smooth_grid_dimensions, ONLY: nr1s, nr2s, nr3s, &
>                                         nr1sx, nr2sx, nr3sx, nnrsx
>       USE electrons_base,   ONLY: nspin
>       USE constants,        ONLY: pi, fpi, au_gpa
>       USE energies,         ONLY: etot, eself, enl, ekin, epseu, esr, eht, exc, eextfor 
>       USE local_pseudo,     ONLY: vps, dvps, rhops
>       USE core,             ONLY: nlcc_any
>       USE gvecb
>       USE dener,            ONLY: detot, dekin, dps, dh, dsr, dxc, denl, &
>                                   detot6, dekin6, dps6, dh6, dsr6, dxc6, denl6
>       USE cp_main_variables, ONLY: drhog, drhor
>       USE mp,               ONLY: mp_sum
>       USE mp_global,        ONLY: intra_image_comm
>       USE funct,            ONLY: dft_is_meta
>       USE pres_ai_mod,      ONLY: abivol, abisur, v_vol, P_ext, volclu,  &
>                                   Surf_t, surfclu
>       USE cp_interfaces,    ONLY: fwfft, invfft, self_vofhar
>       USE sic_module,       ONLY: self_interaction, sic_epsilon, sic_alpha
>       USE energies,         ONLY: self_exc, self_ehte
>       USE cp_interfaces,    ONLY: pseudo_stress, compute_gagb, stress_hartree, &
>                                   add_drhoph, stress_local, force_loc
>       USE fft_base,         ONLY: dfftp, dffts
> !#@@@@
>       USE ldaU,             ONLY: e_hubbard
> !#@@@@
> !==============================================================================
> !Charles Swartz
>       USE input_parameters, ONLY : ts_vdw
>       USE tsvdw_module,            ONLY : tsvdw_calculate
>       USE tsvdw_module,            ONLY : EtsvdW,UtsvdW1,FtsvdW
> !==============================================================================
>       IMPLICIT NONE
> !
>       LOGICAL :: tlast, tfirst
>       INTEGER :: nfi
>       REAL(DP)  rhor(nnr,nspin), rhos(nnrsx,nspin), fion(3,nat)
>       REAL(DP)  rhoc(nnr), tau0(3,nat)
>       COMPLEX(DP) ei1(-nr1:nr1,nat), ei2(-nr2:nr2,nat),     &
>      &                ei3(-nr3:nr3,nat), eigrb(ngb,nat),        &
>      &                rhog(ng,nspin), sfac(ngs,nsp)
>       !
>       INTEGER irb(3,nat)
>       !
>       INTEGER iss, isup, isdw, ig, ir, i, j, k, ij, is, ia
>       REAL(DP) vave, ebac, wz, eh, ehpre
>       COMPLEX(DP)  fp, fm, ci, drhop, zpseu, zh
>       COMPLEX(DP), ALLOCATABLE :: rhotmp(:), vtemp(:)
>       ! COMPLEX(DP), ALLOCATABLE :: drhotmp(:,:,:)
>       COMPLEX(DP), ALLOCATABLE :: drhot(:,:)
>       COMPLEX(DP), ALLOCATABLE :: v(:), vs(:)
>       REAL(DP), ALLOCATABLE    :: gagb(:,:)
>       !
>       REAL(DP), ALLOCATABLE :: fion1( :, : )
>       REAL(DP), ALLOCATABLE :: stmp( :, : )
>       !
>       COMPLEX(DP), ALLOCATABLE :: self_vloc(:)
>       COMPLEX(DP)              :: self_rhoeg
>       REAL(DP)                 :: self_ehtet, fpibg
>       LOGICAL                  :: ttsic
>       REAL(DP)                 :: detmp( 3, 3 ), desr( 6 ), deps( 6 )
>       REAL(DP)                 :: detmp2( 3, 3 )
>       REAL(DP)                 :: ht( 3, 3 )
>       REAL(DP)                 :: deht( 6 )
>       COMPLEX(DP)              :: screen_coul( 1 )
> !
>       INTEGER, DIMENSION(6), PARAMETER :: alpha = (/ 1,2,3,2,3,3 /)
>       INTEGER, DIMENSION(6), PARAMETER :: beta  = (/ 1,1,1,2,2,3 /)
> 
>       ! ...  dalbe(:) = delta( alpha(:), beta(:) )
>       REAL(DP),  DIMENSION(6), PARAMETER :: dalbe = &
>          (/ 1.0_DP, 0.0_DP, 0.0_DP, 1.0_DP, 0.0_DP, 1.0_DP /)
> 
> !==============================================================================
> !Charles Swartz
>       !
>       !     TS-vdW calculation (RAD)
>       !
>       IF (ts_vdw.EQV..TRUE.) THEN
>         IF (nfi.GT.1) THEN 
>           CALL start_clock( 'ts_vdw' )
>           CALL tsvdw_calculate(tau0)
>           CALL stop_clock( 'ts_vdw' )
>         END IF
>       END IF
> !==============================================================================
> 
> 
>       CALL start_clock( 'vofrho' )
> 
>       ci = ( 0.0d0, 1.0d0 )
>       !
>       !     wz = factor for g.neq.0 because of c*(g)=c(-g)
>       !
>       wz = 2.0d0
>       !
>       ht = TRANSPOSE( h )
>       !
>       ALLOCATE( v( nnr ) )
>       ALLOCATE( vs( nnrsx ) )
>       ALLOCATE( vtemp( ng ) )
>       ALLOCATE( rhotmp( ng ) )
>       !
>       IF ( tpre ) THEN
>          ALLOCATE( drhot( ng, 6 ) )
>          ALLOCATE( gagb( 6, ng ) )
>          CALL compute_gagb( gagb, gx, ng, tpiba2 )
>       END IF
> !
> !     ab-initio pressure and surface tension contributions to the potential
> !
>       if (abivol.or.abisur) call vol_clu(rhor,rhog,sfac,nfi)
>       !
>       ttsic = ( ABS( self_interaction ) /= 0 )
>       !
>       IF( ttsic ) ALLOCATE( self_vloc( ng ) )
>       !
>       !     first routine in which fion is calculated: annihilation
>       !
>       fion  = 0.d0
>       !
>       !     forces on ions, ionic term in real space
>       !
>       IF( tprnfor .OR. tfor .OR. tfirst .OR. tpre ) THEN
>          !
>          ALLOCATE( stmp( 3, nat ) )
>          !
>          CALL r_to_s( tau0, stmp, na, nsp, ainv )
>          !
>          CALL vofesr( iesr, esr, dsr6, fion, stmp, tpre, h )
>          !
>          call mp_sum( fion, intra_image_comm )
>          !
>          DEALLOCATE( stmp )
>          !
>       END IF
> !
>       rhotmp( 1:ng ) = rhog( 1:ng, 1 )
>       !
> 
>       IF( tpre ) THEN
>          DO ij = 1, 6
>             i = alpha( ij )
>             j = beta( ij )
>             drhot( :, ij ) = 0.0d0
>             DO k = 1, 3
>                drhot( :, ij ) = drhot( :, ij ) +  drhog( :, 1, i, k ) * ht( k, j )
>             END DO
>          END DO
>       END IF
>       !
>       IF( nspin == 2 ) THEN
>          rhotmp( 1:ng ) = rhotmp( 1:ng ) + rhog( 1:ng, 2 )
>          IF(tpre)THEN
>             DO ij = 1, 6
>                i = alpha( ij )
>                j = beta( ij )
>                DO k = 1, 3
>                   drhot( :, ij ) = drhot( :, ij ) +  drhog( :, 2, i, k ) * ht( k, j )
>                END DO
>             END DO
>          ENDIF
>       END IF
>       !
>       !     calculation local potential energy
>       !
>       zpseu = 0.0d0
>       !
> !$omp parallel default(shared), private(ig,is)
> !$omp do
>       DO ig = 1, SIZE(vtemp)
>          vtemp(ig)=(0.d0,0.d0)
>       END DO
>       DO is=1,nsp
> !$omp do
>          DO ig=1,ngs
>             vtemp(ig)=vtemp(ig)+CONJG(rhotmp(ig))*sfac(ig,is)*vps(ig,is)
>          END DO
>       END DO
> !$omp do reduction(+:zpseu)
>       DO ig=1,ngs
>          zpseu = zpseu + vtemp(ig)
>       END DO
> !$omp end parallel
> 
>       epseu = wz * DBLE(zpseu)
>       !
>       IF (gstart == 2) epseu = epseu - DBLE( vtemp(1) )
>       !
>       CALL mp_sum( epseu, intra_image_comm )
> 
>       epseu = epseu * omega
> 
> !
>       IF( tpre ) THEN
>          !
>          CALL stress_local( dps6, epseu, gagb, sfac, rhotmp, drhot, omega )
>          !
>       END IF
>       !
>       !     
>       !     calculation hartree energy
>       !    
>       !
>       self_ehtet = 0.d0  
>       !
>       IF( ttsic ) self_vloc = 0.d0 
> 
>       zh = 0.0d0
> 
> !$omp parallel default(shared), private(ig,is)
> 
>       DO is=1,nsp
> !$omp do
>          DO ig=1,ngs
>             rhotmp(ig)=rhotmp(ig)+sfac(ig,is)*rhops(ig,is)
>          END DO
>       END DO
>       !
> !$omp do
>       DO ig = gstart, ng
>          vtemp(ig) = CONJG( rhotmp( ig ) ) * rhotmp( ig ) / g( ig )
>       END DO
> 
> !$omp do reduction(+:zh)
>       DO ig = gstart, ng
>          zh = zh + vtemp(ig)
>       END DO
> 
> !$omp end parallel
> 
>       eh = DBLE( zh ) * wz * 0.5d0 * fpi / tpiba2
> !
>       CALL mp_sum( eh, intra_image_comm )
>       !
>       IF ( ttsic ) THEN
>          !
>          CALL self_vofhar( .false., self_ehte, self_vloc, rhog, omega, h )
>          !
>          eh = eh - self_ehte / omega
>          !
>       END IF
>       !
>       IF(tpre) THEN
>          !
>          CALL add_drhoph( drhot, sfac, gagb )
>          !
>          CALL stress_hartree(dh6, eh*omega, sfac, rhotmp, drhot, gagb, omega )
>          !
>       END IF
>       !
>       IF(tpre) THEN
>          DEALLOCATE( drhot )
>       END IF
>       !    
>       !     forces on ions, ionic term in reciprocal space
>       !     
>       ALLOCATE( fion1( 3, nat ) )
>       !
>       fion1 = 0.d0
>       !
>       IF( tprnfor .OR. tfor .OR. tpre) THEN
>           vtemp( 1:ng ) = rhog( 1:ng, 1 )
>           IF( nspin == 2 ) THEN
>              vtemp( 1:ng ) = vtemp(1:ng) + rhog( 1:ng, 2 )
>           END IF
>           CALL force_loc( .false., vtemp, fion1, rhops, vps, ei1, ei2, ei3, sfac, omega, screen_coul )
>       END IF
>       !
>       !     calculation hartree + local pseudo potential
>       !
>       !
>       IF (gstart == 2) vtemp(1)=(0.d0,0.d0)
> 
> !$omp parallel default(shared), private(ig,is)
> !$omp do
>       DO ig=gstart,ng
>          vtemp(ig)=rhotmp(ig)*fpi/(tpiba2*g(ig))
>       END DO
> !
>       DO is=1,nsp
> !$omp do
>          DO ig=1,ngs
>             vtemp(ig)=vtemp(ig)+sfac(ig,is)*vps(ig,is)
>          END DO
>       END DO
> !$omp end parallel
> !
> !     vtemp = v_loc(g) + v_h(g)
> !
> !     ===================================================================
> !      calculation exchange and correlation energy and potential
> !     -------------------------------------------------------------------
>       IF ( nlcc_any ) CALL add_cc( rhoc, rhog, rhor )
> !
>       CALL exch_corr_h( nspin, rhog, rhor, rhoc, sfac, exc, dxc, self_exc )
> 
> !==============================================================================
> !Charles Swartz
>       !
>       !     Add TS-vdW wavefunction forces to rhor here... (RAD)
>       !
>       IF (ts_vdw.EQV..TRUE.) THEN
>         IF (nspin.EQ.1) THEN
>           DO ir=1,nnr
>             rhor(ir,1)=rhor(ir,1)+UtsvdW1(ir) !RAD: Change this line for spin-unpolarized calculations...
>           END DO
>         END IF
>       END IF
> !==============================================================================
> 
> !
> !     rhor contains the xc potential in r-space
> !
> !     ===================================================================
> !     fourier transform of xc potential to g-space (dense grid)
> !     -------------------------------------------------------------------
> !
>       IF( nspin == 1 ) THEN
>          iss = 1
>          if (abivol.or.abisur) then
> !$omp parallel do
>             do ir=1,nnr
>                v(ir)=CMPLX( rhor( ir, iss ) + v_vol( ir ), 0.d0 ,kind=DP)
>             end do           
>          else
> !$omp parallel do
>             do ir=1,nnr
>                v(ir)=CMPLX( rhor( ir, iss ), 0.d0 ,kind=DP)
>             end do
>          end if
>          !
>          !     v_xc(r) --> v_xc(g)
>          !
>          CALL fwfft( 'Dense', v, dfftp )
> !
> !$omp parallel do
>          DO ig = 1, ng
>             rhog( ig, iss ) = vtemp(ig) + v( np( ig ) )
>          END DO
>          !
>          !     v_tot(g) = (v_tot(g) - v_xc(g)) +v_xc(g)
>          !     rhog contains the total potential in g-space
>          !
>       ELSE
>          isup=1
>          isdw=2
>          if (abivol.or.abisur) then
> !$omp parallel do
>             do ir=1,nnr
>                v(ir)=CMPLX ( rhor(ir,isup)+v_vol(ir), &
>                              rhor(ir,isdw)+v_vol(ir),kind=DP)
>             end do
>          else
> !$omp parallel do
>             do ir=1,nnr
>                v(ir)=CMPLX (rhor(ir,isup),rhor(ir,isdw),kind=DP)
>             end do
>          end if
>          CALL fwfft('Dense',v, dfftp )
> !$omp parallel do private(fp,fm)
>          DO ig=1,ng
>             fp=v(np(ig))+v(nm(ig))
>             fm=v(np(ig))-v(nm(ig))
>             IF( ttsic ) THEN
>              rhog(ig,isup)=vtemp(ig)-self_vloc(ig) + &
>                            0.5d0*CMPLX( DBLE(fp),AIMAG(fm),kind=DP)
>              rhog(ig,isdw)=vtemp(ig)+self_vloc(ig) + &
>                            0.5d0*CMPLX(AIMAG(fp),-DBLE(fm),kind=DP)
>             ELSE
>              rhog(ig,isup)=vtemp(ig)+0.5d0*CMPLX( DBLE(fp),AIMAG(fm),kind=DP)
>              rhog(ig,isdw)=vtemp(ig)+0.5d0*CMPLX(AIMAG(fp),-DBLE(fm),kind=DP)
>             ENDIF
>          END DO
>       ENDIF
> 
> !
> !     rhog contains now the total (local+Hartree+xc) potential in g-space
> !
>       IF( tprnfor .OR. tfor ) THEN
> 
>          IF ( nlcc_any ) CALL force_cc( irb, eigrb, rhor, fion1 )
> 
>          CALL mp_sum( fion1, intra_image_comm )
>          !
>          !    add g-space ionic and core correction contributions to fion
>          !
>          fion = fion + fion1
> !==============================================================================
> !Charles Swartz
>          !
>          !     Add TS-vdW ion forces to fion here... (RAD)
>          !
>          IF (ts_vdw.EQV..TRUE.) THEN
>            fion=fion+FtsvdW
>          END IF
> !==============================================================================
> 
>       END IF
> 
>       DEALLOCATE( fion1 )
> !
>       IF( ttsic ) DEALLOCATE( self_vloc )
> !
> !     ===================================================================
> !     fourier transform of total potential to r-space (dense grid)
> !     -------------------------------------------------------------------
>       v(:) = (0.d0, 0.d0)
>       IF(nspin.EQ.1) THEN
>          iss=1
> !$omp parallel do
>          DO ig=1,ng
>             v(np(ig))=rhog(ig,iss)
>             v(nm(ig))=CONJG(rhog(ig,iss))
>          END DO
> !
> !     v(g) --> v(r)
> !
>          CALL invfft('Dense',v, dfftp )
> !
> !$omp parallel do
>          DO ir=1,nnr
>             rhor(ir,iss)=DBLE(v(ir))
>          END DO
> !
> !     calculation of average potential
> !
>          vave=SUM(rhor(:,iss))/DBLE(nr1*nr2*nr3)
>       ELSE
>          isup=1
>          isdw=2
> !$omp parallel do
>          DO ig=1,ng
>             v(np(ig))=rhog(ig,isup)+ci*rhog(ig,isdw)
>             v(nm(ig))=CONJG(rhog(ig,isup)) +ci*CONJG(rhog(ig,isdw))
>          END DO
1164,1168c2299,2309
<       integer  is, il, l, ir, iv, jv, lm, ind, ltmp, i0
<       real(dp), allocatable:: fint(:), jl(:),  jltmp(:), djl(:),    &
<      &              dfint(:)
<       real(dp) xg, xrg, fac
< 
---
>          CALL invfft('Dense',v, dfftp )
> !$omp parallel do
>          DO ir=1,nnr
>             rhor(ir,isup)= DBLE(v(ir))
>             rhor(ir,isdw)=AIMAG(v(ir))
>          END DO
>          !
>          !     calculation of average potential
>          !
>          vave=(SUM(rhor(:,isup))+SUM(rhor(:,isdw))) / 2.0d0 / DBLE( nr1 * nr2 * nr3 )
>       ENDIF
1170,1175c2311
<       IF( ionode ) THEN
<         WRITE( stdout, 100 )
<  100    FORMAT( //, &
<                 3X,'Pseudopotentials initialization',/, &
<                 3X,'-------------------------------' )
<       END IF
---
>       CALL mp_sum( vave, intra_image_comm )
1177,1180d2312
<       IF( .NOT. ALLOCATED( rgrid ) ) &
<          CALL errore( ' nlinit ', ' rgrid not allocated ', 1 )
<       IF( .NOT. ALLOCATED( upf ) ) &
<          CALL errore( ' nlinit ', ' upf not allocated ', 1 )
1182c2314
<       !   initialize indexes
---
>       !     fourier transform of total potential to r-space (smooth grid)
1184c2316
<       CALL pseudopotential_indexes( )
---
>       vs (:) = (0.d0, 0.d0)
1186c2318,2356
<       !   initialize array ap
---
>       IF(nspin.EQ.1)THEN
>          !
>          iss=1
> !$omp parallel do
>          DO ig=1,ngs
>             vs(nms(ig))=CONJG(rhog(ig,iss))
>             vs(nps(ig))=rhog(ig,iss)
>          END DO
>          !
>          CALL invfft('Smooth',vs, dffts )
>          !
> !$omp parallel do
>          DO ir=1,nnrsx
>             rhos(ir,iss)=DBLE(vs(ir))
>          END DO
>          !
>       ELSE
>          !
>          isup=1
>          isdw=2
> !$omp parallel do
>          DO ig=1,ngs
>             vs(nps(ig))=rhog(ig,isup)+ci*rhog(ig,isdw)
>             vs(nms(ig))=CONJG(rhog(ig,isup)) +ci*CONJG(rhog(ig,isdw))
>          END DO 
>          !
>          CALL invfft('Smooth',vs, dffts )
>          !
> !$omp parallel do
>          DO ir=1,nnrsx
>             rhos(ir,isup)= DBLE(vs(ir))
>             rhos(ir,isdw)=AIMAG(vs(ir))
>          END DO
>          !
>       ENDIF
> 
>       IF( dft_is_meta() ) CALL vofrho_meta( v, vs )  !METAGGA
> 
>       ebac = 0.0d0
1188c2358
<       call aainit( lmaxkb + 1 )
---
>       eht = eh * omega + esr - eself
1190c2360,2361
<       CALL allocate_core( dfftp%nnr, ngm, ngb, nsp )
---
>       eextfor = 0.0_DP
>       IF( textfor ) eextfor = compute_eextfor( tau0 )
1191a2363
>       !     etot is the total energy ; ekin, enl were calculated in rhoofr
1193,1199c2365,2372
<       allocate( beta( ngw, nhm, nsp ) )
<       allocate( qgb( ngb, nhm*(nhm+1)/2, nsp ) )
<       allocate( qq( nhm, nhm, nsp ) )
<       qq  (:,:,:) =0.d0
<       IF (tpre) THEN
<          allocate( dqgb( ngb, nhm*(nhm+1)/2, nsp, 3, 3 ) )
<          allocate( dbeta( ngw, nhm, nsp, 3, 3 ) )
---
>       etot = ekin + eht + epseu + enl + exc + ebac +e_hubbard + eextfor
> !==============================================================================
> !Charles Swartz
>       !  
>       !     Add TS-vdW energy to etot here... (RAD)
>       !  
>       IF (ts_vdw.EQV..TRUE.) THEN
>         etot=etot+EtsvdW
1200a2374
> !==============================================================================
1202c2376,2377
<       !     initialization for vanderbilt species
---
>       if (abivol) etot = etot + P_ext*volclu
>       if (abisur) etot = etot + Surf_t*surfclu
1204,1217c2379
<       CALL compute_qradx( tpre )
<       !    
<       !     initialization that is common to all species
<       !   
<       WRITE( stdout, fmt="(//,3X,'Common initialization' )" )
< 
<       do is = 1, nsp
<          WRITE( stdout, fmt="(/,3X,'Specie: ',I5)" ) is
<          !     fac converts ry to hartree
<          fac=0.5d0
<          do iv = 1, nh(is)
<             WRITE( stdout,901) iv, indv(iv,is), nhtol(iv,is)
<          end do
<  901     format(2x,i2,'  indv= ',i2,'   ang. mom= ',i2)
---
>       IF( tpre ) THEN
1219,1223c2381
<          WRITE( stdout,*)
<          WRITE( stdout,'(20x,a)') '    dion '
<          do iv = 1, upf(is)%nbeta
<             WRITE( stdout,'(8f9.4)') ( fac*upf(is)%dion(iv,jv), jv = 1, upf(is)%nbeta )
<          end do
---
>          detot6 = dekin6 + dh6 + dps6 + dsr6
1225,1227c2383,2394
<       end do
<       !
<       !   calculation of array  betagx(ig,iv,is)
---
>          call mp_sum( detot6, intra_image_comm )
>          !
>          DO k = 1, 6
>             detmp( alpha(k), beta(k) ) = detot6(k)
>             detmp( beta(k), alpha(k) ) = detmp( alpha(k), beta(k) )
>          END DO
>          !
>          detot = MATMUL( detmp(:,:), TRANSPOSE( ainv(:,:) ) )
>          !
>          detot = detot + denl + dxc
>          !
>       END IF
1229d2395
<       call compute_betagx( tpre )
1231c2397
<       !   calculate array  dvan(iv,jv,is)
---
>       CALL stop_clock( 'vofrho' )
1233d2398
<       call compute_dvan()
1235,1237c2400
<       IF( tpstab ) THEN
< 
<          call build_pstab()
---
>       IF ( tpre ) THEN
1239c2402
<          call build_cctab()
---
>          DEALLOCATE( gagb )
1241,1328c2404,2455
<       END IF
<       !
<       ! newnlinit stores qgb and qq, calculates arrays  beta  rhocb
<       ! and derivatives wrt cell dbeta
<       !
<       call newnlinit()
< 
<       return
< end subroutine nlinit
< 
< !-------------------------------------------------------------------------
< subroutine qvan2b(ngy,iv,jv,is,ylm,qg,qradb)
<   !--------------------------------------------------------------------------
<   !
<   !     q(g,l,k) = sum_lm (-i)^l ap(lm,l,k) yr_lm(g^) qrad(g,l,l,k)
<   !
<   USE kinds,         ONLY : DP
<   use control_flags, ONLY : iprint, tpre
<   use uspp,          ONLY : nlx, lpx, lpl, ap, indv, nhtolm
<   use smallbox_gvec,         ONLY : ngb
<   use uspp_param,    ONLY : lmaxq, nbetam
<   use ions_base,     ONLY : nsp
< ! 
<   implicit none
<   !
<   integer,     intent(in)  :: ngy, iv, jv, is
<   real(DP),    intent(in)  :: ylm( ngb, lmaxq*lmaxq )
<   real(DP),    intent(in)  :: qradb( ngb, nbetam*(nbetam+1)/2, lmaxq, nsp )
<   complex(DP), intent(out) :: qg( ngb )
< !
<   integer      :: ivs, jvs, ijvs, ivl, jvl, i, ii, ij, l, lp, ig
<   complex(DP) :: sig
<   ! 
<   !       iv  = 1..8     s_1 p_x1 p_z1 p_y1 s_2 p_x2 p_z2 p_y2
<   !       ivs = 1..4     s_1 s_2 p_1 p_2
<   !       ivl = 1..4     s p_x p_z p_y
<   ! 
<   ivs=indv(iv,is)
<   jvs=indv(jv,is)
<   if (ivs >= jvs) then
<      ijvs = ivs*(ivs-1)/2 + jvs
<   else
<      ijvs = jvs*(jvs-1)/2 + ivs
<   end if
<   ! ijvs is the packed index for (ivs,jvs)
<   ivl=nhtolm(iv,is)
<   jvl=nhtolm(jv,is)
<   if (ivl > nlx .OR. jvl > nlx) &
<        call errore (' qvan2b ', ' wrong dimensions', MAX(ivl,jvl))
<   !
<   qg(:) = (0.d0, 0.d0)
<   !
<   !     lpx = max number of allowed y_lm
<   !     lp  = composite lm to indentify them
<   !
<   do i=1,lpx(ivl,jvl)
<      lp=lpl(ivl,jvl,i)
<      if (lp > lmaxq*lmaxq) call errore(' qvan2b ',' lp out of bounds ',lp)
<      !
<      !     extraction of angular momentum l from lp:  
<      !     l = int ( sqrt( DBLE(l-1) + epsilon) ) + 1
<      !
<      if (lp == 1) then
<         l=1         
<      else if ((lp >= 2) .and. (lp <= 4)) then
<         l=2
<      else if ((lp >= 5) .and. (lp <= 9)) then
<         l=3
<      else if ((lp >= 10).and.(lp <= 16)) then
<         l=4
<      else if ((lp >= 17).and.(lp <= 25)) then
<         l=5
<      else if ((lp >= 26).and.(lp <= 36)) then 
<         l=6
<      else if ((lp >= 37).and.(lp <= 49)) then 
<         l=7
<      else
<         call errore(' qvan2b ',' not implemented ',lp)
<      endif
<      !     
<      !       sig= (-i)^l
<      !
<      sig=(0.d0,-1.d0)**(l-1)
<      sig=sig*ap(lp,ivl,jvl)
<      do ig=1,ngy
<         qg(ig)=qg(ig)+sig*ylm(ig,lp)*qradb(ig,ijvs,l,is)
<      end do
<   end do
---
>          IF( ( iprsta > 2 ) .AND. ( MOD( nfi - 1, iprint) == 0 ) ) THEN  
>             !
>             WRITE( stdout,*)
>             WRITE( stdout,*) "From vofrho:"
>             WRITE( stdout,*) "cell parameters h"
>             WRITE( stdout,5555) (a1(i),a2(i),a3(i),i=1,3)
>             !
>             WRITE( stdout,*)
>             WRITE( stdout,*) "derivative of e(tot)"
>             WRITE( stdout,5555) ((detot(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( detot, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>             !
>             WRITE( stdout,*)
>             WRITE( stdout,*) "derivative of e(kin)"
>             WRITE( stdout,5555) ((dekin(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( dekin, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>             !
>             WRITE( stdout,*) "derivative of e(h)"
>             WRITE( stdout,5555) ((dh(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( dh, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>              !
>             WRITE( stdout,*) "derivative of e(sr)"
>             WRITE( stdout,5555) ((dsr(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( dsr, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>             !
>             WRITE( stdout,*) "derivative of e(ps)"
>             WRITE( stdout,5555) ((dps(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( dps, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>             !
>             WRITE( stdout,*) "derivative of e(nl)"
>             WRITE( stdout,5555) ((denl(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( denl, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>             !
>             WRITE( stdout,*) "derivative of e(xc)"
>             WRITE( stdout,5555) ((dxc(i,j),j=1,3),i=1,3)
>             WRITE( stdout,*) "kbar"
>             detmp = -1.0d0 * MATMUL( dxc, TRANSPOSE( h ) ) / omega * au_gpa * 10.0d0
>             WRITE( stdout,5555) ((detmp(i,j),j=1,3),i=1,3)
>          ENDIF
>       ENDIF
1330,1331c2457,2460
<   return
< end subroutine qvan2b
---
>       DEALLOCATE( rhotmp )
>       DEALLOCATE( vtemp )
>       DEALLOCATE( v )
>       DEALLOCATE( vs )
1333,1352c2462
< !-------------------------------------------------------------------------
< subroutine dqvan2b(ngy,iv,jv,is,ylm,dylm,dqg,dqrad,qradb)
<   !--------------------------------------------------------------------------
<   !
<   !     dq(i,j) derivatives wrt to h(i,j) of q(g,l,k) calculated in qvan2b
<   !
<   USE kinds,         ONLY : DP
<   use control_flags, ONLY : iprint, tpre
<   use uspp,          ONLY : nlx, lpx, lpl, ap, indv, nhtolm
<   use smallbox_gvec,         ONLY : ngb
<   use uspp_param,    ONLY : lmaxq, nbetam
<   use ions_base,     ONLY : nsp
< 
<   implicit none
< 
<   integer,     intent(in)  :: ngy, iv, jv, is
<   REAL(DP),    INTENT(IN)  :: ylm( ngb, lmaxq*lmaxq ), dylm( ngb, lmaxq*lmaxq, 3, 3 )
<   complex(DP), intent(out) :: dqg( ngb, 3, 3 )
<   REAL(DP),    INTENT(IN)  :: dqrad( ngb, nbetam*(nbetam+1)/2, lmaxq, nsp, 3, 3 )
<   real(DP),    intent(in)  :: qradb( ngb, nbetam*(nbetam+1)/2, lmaxq, nsp )
---
>       RETURN
1354,1379c2464,2467
<   integer      :: ivs, jvs, ijvs, ivl, jvl, i, ii, ij, l, lp, ig
<   complex(DP) :: sig, z1, z2, zfac
<   !
<   ! 
<   !       iv  = 1..8     s_1 p_x1 p_z1 p_y1 s_2 p_x2 p_z2 p_y2
<   !       ivs = 1..4     s_1 s_2 p_1 p_2
<   !       ivl = 1..4     s p_x p_z p_y
<   ! 
<   ivs=indv(iv,is)
<   jvs=indv(jv,is)
<   !
<   if (ivs >= jvs) then
<      ijvs = ivs*(ivs-1)/2 + jvs
<   else
<      ijvs = jvs*(jvs-1)/2 + ivs
<   end if
<   !
<   ! ijvs is the packed index for (ivs,jvs)
<   !
<   ivl=nhtolm(iv,is)
<   jvl=nhtolm(jv,is)
<   !
<   if (ivl > nlx .OR. jvl > nlx) &
<        call errore (' qvan2 ', ' wrong dimensions (2)', MAX(ivl,jvl))
<   !
<   dqg(:,:,:) = (0.d0, 0.d0)
---
> 5555  FORMAT(1x,f12.5,1x,f12.5,1x,f12.5/                                &
>      &       1x,f12.5,1x,f12.5,1x,f12.5/                                &
>      &       1x,f12.5,1x,f12.5,1x,f12.5//)
> !
1381,1382c2469
<   !  lpx = max number of allowed y_lm
<   !  lp  = composite lm to indentify them
---
>       END SUBROUTINE vofrho
1384,1388c2471,2488
<   z1 = 0.0d0
<   z2 = 0.0d0
<   do i=1,lpx(ivl,jvl)
<      lp=lpl(ivl,jvl,i)
<      if (lp > lmaxq*lmaxq) call errore(' dqvan2b ',' lp out of bounds ',lp)
---
> !#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> !-----------------------------------------------------------------------
>       subroutine ldaU_init
> !-----------------------------------------------------------------------
> !
>       USE constants,        ONLY: autoev
>       use ldaU,             ONLY: n_atomic_wfc, atomwfc,lda_plus_u, Hubbard_U
>       use ldaU,             ONLY: Hubbard_lmax, Hubbard_l, ns, vupsi
>       use input_parameters, ONLY: lda_plus_u_ => lda_plus_u
>       use input_parameters, ONLY: Hubbard_U_ => Hubbard_U
>       use ions_base,        only: na, nsp, nat, atm
>       use gvecw,            only: ngw
>       use electrons_base,   only: nspin, nx => nbspx
>       USE uspp_param,       ONLY: upf
>       !
>       implicit none
>       integer is, nb, l
>       integer, external :: set_Hubbard_l
1390,1431c2490
<      !  extraction of angular momentum l from lp:  
<      !  l = int ( sqrt( DBLE(l-1) + epsilon) ) + 1
<      !
<      if (lp == 1) then
<         l=1         
<      else if ((lp >= 2) .and. (lp <= 4)) then
<         l=2
<      else if ((lp >= 5) .and. (lp <= 9)) then
<         l=3
<      else if ((lp >= 10).and.(lp <= 16)) then
<         l=4
<      else if ((lp >= 17).and.(lp <= 25)) then
<         l=5
<      else if ((lp >= 26).and.(lp <= 36)) then 
<         l=6
<      else if ((lp >= 37).and.(lp <= 49)) then 
<         l=7
<      else
<         call errore(' qvan2b ',' not implemented ',lp)
<      endif
<      !     
<      !       sig= (-i)^l
<      !
<      sig = (0.0d0,-1.0d0)**(l-1)
<      !
<      sig = sig * ap( lp, ivl, jvl ) 
<      !
<      do ij=1,3
<         do ii=1,3
<            do ig=1,ngy
<               zfac = ylm(ig,lp) * dqrad(ig,ijvs,l,is,ii,ij)
<               zfac = zfac - dylm(ig,lp,ii,ij) * qradb(ig,ijvs,l,is)
<               dqg(ig,ii,ij) = dqg(ig,ii,ij) +  sig * zfac
<            end do
<         end do
<      end do
<   end do
<   !
<   ! WRITE(6,*) 'DEBUG dqvan2b: ', z1, z2
<   !
<   return
< end subroutine dqvan2b
---
> ! allocate vupsi
1433,1441c2492,2494
< !-----------------------------------------------------------------------
< subroutine dylmr2_( nylm, ngy, g, gg, ainv, dylm )
<   !-----------------------------------------------------------------------
<   !
<   ! temporary CP interface for PW routine dylmr2
<   ! dylmr2  calculates d Y_{lm} /d G_ipol
<   ! dylmr2_ calculates G_ipol \sum_k h^(-1)(jpol,k) (dY_{lm} /dG_k)
<   !
<   USE kinds, ONLY: DP
---
>       lda_plus_u = lda_plus_u_
>       if ( .NOT. lda_plus_u ) RETURN
>       allocate(vupsi(ngw,nx))
1443,1477c2496,2498
<   implicit none
<   !
<   integer,   intent(IN)  :: nylm, ngy
<   real(DP), intent(IN)  :: g (3, ngy), gg (ngy), ainv(3,3)
<   real(DP), intent(OUT) :: dylm (ngy, nylm, 3, 3)
<   !
<   integer :: ipol, jpol, lm, ig
<   real(DP), allocatable :: dylmaux (:,:,:)
<   !
<   allocate ( dylmaux(ngy,nylm,3) )
<   !
<   dylmaux(:,:,:) = 0.d0
<   !
<   do ipol =1,3
<      call dylmr2 (nylm, ngy, g, gg, dylmaux(1,1,ipol), ipol)
<   enddo
<   !
<   do ipol =1,3
<      do jpol =1,3
<         do lm=1,nylm
<            do ig = 1, ngy
<               dylm (ig,lm,ipol,jpol) = (dylmaux(ig,lm,1) * ainv(jpol,1) + & 
<                                         dylmaux(ig,lm,2) * ainv(jpol,2) + &
<                                         dylmaux(ig,lm,3) * ainv(jpol,3) ) &
<                                        * g(ipol,ig)
<            end do
<         end do
<      end do
<   end do
<   !
<   deallocate ( dylmaux )
<   !
<   return
<   !
< end subroutine dylmr2_
---
>       vupsi=(0.0d0,0.0d0)
>       ! allocate(vpsi_con(ngw,nx)) ! step_constraint 
>       n_atomic_wfc=0
1478a2500,2511
>       do is=1,nsp
>          !
>          Hubbard_U( is ) = Hubbard_U_( is )/autoev
>          !
>          do nb = 1,upf(is)%nwfc
>             l = upf(is)%lchi(nb)
>             n_atomic_wfc = n_atomic_wfc + (2*l+1)*na(is)
>          end do
>          !
>       end do
> !
>       allocate(atomwfc(ngw,n_atomic_wfc))
1480,1517c2513,2531
< SUBROUTINE print_lambda_x( lambda, descla, n, nshow, ccc, iunit )
<     USE kinds, ONLY : DP
<     USE descriptors,       ONLY: la_descriptor
<     USE io_global,         ONLY: stdout, ionode
<     USE cp_interfaces,     ONLY: collect_lambda
<     USE electrons_base,    ONLY: nudx
<     IMPLICIT NONE
<     real(DP), intent(in) :: lambda(:,:,:), ccc
<     TYPE(la_descriptor), INTENT(IN) :: descla(:)
<     integer, intent(in) :: n, nshow
<     integer, intent(in), optional :: iunit
<     !
<     integer :: nnn, j, un, i, is
<     real(DP), allocatable :: lambda_repl(:,:)
<     if( present( iunit ) ) then
<       un = iunit
<     else
<       un = stdout
<     end if
<     nnn = min( nudx, nshow )
<     ALLOCATE( lambda_repl( nudx, nudx ) )
<     IF( ionode ) WRITE( un,*)
<     DO is = 1, SIZE( lambda, 3 )
<        CALL collect_lambda( lambda_repl, lambda(:,:,is), descla(is) )
<        IF( ionode ) THEN
<           WRITE( un,3370) '    lambda   nudx, spin = ', nudx, is
<           IF( nnn < n ) WRITE( un,3370) '    print only first ', nnn
<           DO i=1,nnn
<              WRITE( un,3380) (lambda_repl(i,j)*ccc,j=1,nnn)
<           END DO
<        END IF
<     END DO
<     DEALLOCATE( lambda_repl )
< 3370   FORMAT(26x,a,2i4)
< 3380   FORMAT(9f8.4)
<     RETURN
< END SUBROUTINE print_lambda_x
< !-----------------------------------------------------------------------
---
>       if (lda_plus_u) then
>          Hubbard_lmax = -1
>          do is=1,nsp
>             if (Hubbard_U(is).ne.0.d0) then 
> !                Hubbard_l(is)=2
>                Hubbard_l(is) = set_Hubbard_l( atm(is) )
>                 Hubbard_lmax = max(Hubbard_lmax,Hubbard_l(is))
>                write (6,*) ' HUBBARD L FOR TYPE ',atm(is),' IS ',&
>      &                       Hubbard_l(is)
>             end if
>          end do
>          write (6,*) ' MAXIMUM HUBBARD L IS ', Hubbard_lmax
>          if (Hubbard_lmax.eq.-1) call errore                            &
>      &        ('setup','lda_plus_u calculation but Hubbard_l not set',1)
>       end if
>       l = 2 * Hubbard_lmax + 1
>       allocate(ns(nat,nspin,l,l))
>       return
>       end subroutine ldaU_init
1520c2534
<    SUBROUTINE denlcc_x( nnr, nspin, vxcr, sfac, drhocg, dcc )
---
> integer function set_Hubbard_l(psd) result (hubbard_l)
1523,1525c2537,2538
< ! derivative of non linear core correction exchange energy wrt cell 
< ! parameters h 
< ! Output in dcc
---
> implicit none
> character*3 :: psd
1527,1534c2540,2578
<       USE kinds,              ONLY: DP
<       USE ions_base,          ONLY: nsp
<       USE gvect, ONLY: gstart, g, gg
<       USE gvecs,              ONLY: ngms
<       USE gvect,              ONLY: ngm, nl
<       USE cell_base,          ONLY: omega, ainv, tpiba2
<       USE mp,                 ONLY: mp_sum
<       USE mp_global,          ONLY: intra_bgrp_comm
---
> ! TRANSITION METALS
> !
> if (psd.eq.'V'  .or. psd.eq.'Cr' .or. psd .eq.'Mn' .or. psd.eq.'Fe' .or. &
>     psd.eq.'Co' .or. psd.eq.'Ni' .or. psd .eq.'Cu'.or. psd .eq.'Fe1'.or. &
>     psd .eq.'Fe2' ) then
>     hubbard_l = 2
> !
> ! RARE EARTHS
> !
> elseif (psd .eq.'Ce') then
>    hubbard_l =  3
> !
> ! OTHER ELEMENTS
> !
> elseif (psd .eq.'H') then
>    hubbard_l =  0
> elseif (psd .eq.'O') then
>    hubbard_l = 1
> else
>    hubbard_l = -1
>    call errore ('set_Hubbard_l','pseudopotential not yet inserted', 1)
> endif
> return
> end function set_Hubbard_l
> !
> !-----------------------------------------------------------------------
>       subroutine new_ns(c,eigr,betae,hpsi,hpsi_con,forceh)
> !-----------------------------------------------------------------------
> !
> ! This routine computes the on site occupation numbers of the Hubbard ions.
> ! It also calculates the contribution of the Hubbard Hamiltonian to the
> ! electronic potential and to the forces acting on ions.
> !
>       use control_flags,      ONLY: tfor, tprnfor
>       use kinds,              ONLY: DP        
>       use ions_base,          only: na, nat, nsp
>       use gvecw,              only: ngw
>       use reciprocal_vectors, only: ng0 => gstart
>       USE uspp,               ONLY: nhsa=>nkb
1536,1558c2580,2582
<       USE fft_interfaces,     ONLY: fwfft
<       USE fft_base,           ONLY: dfftp
< 
<       IMPLICIT NONE
< 
<       ! input
< 
<       INTEGER,     INTENT(IN) :: nnr, nspin
<       REAL(DP),    INTENT(IN) :: vxcr( :, : )
<       COMPLEX(DP), INTENT(IN) :: sfac( :, : )
<       REAL(DP),    INTENT(IN) :: drhocg( :, : )
< 
<       ! output
< 
<       REAL(DP), INTENT(OUT) ::  dcc( :, : )
< 
<       ! local
< 
<       INTEGER     :: i, j, ig, is
<       COMPLEX(DP) :: srhoc
<       REAL(DP)    :: vxcc
<       !
<       COMPLEX(DP), ALLOCATABLE :: vxc( : )
---
>       use electrons_base,     only: nspin, n => nbsp, nx => nbspx, ispin, f
>       USE ldaU,               ONLY: lda_plus_u, Hubbard_U, Hubbard_l
>       USE ldaU,               ONLY: n_atomic_wfc, ns, e_hubbard
1560,1595c2584,2791
<       dcc = 0.0d0
<       !
<       ALLOCATE( vxc( nnr ) )
<       !
<       vxc(:) = vxcr(:,1)
<       !
<       IF( nspin > 1 ) vxc(:) = vxc(:) + vxcr(:,2)
<       !
<       CALL fwfft( 'Dense', vxc, dfftp )
<       !
<       DO i=1,3
<          DO j=1,3
<             DO ig = gstart, ngms
<                srhoc = 0.0d0
<                DO is = 1, nsp
<                  IF( upf(is)%nlcc ) srhoc = srhoc + sfac( ig, is ) * drhocg( ig, is )
<                ENDDO
<                vxcc = DBLE( CONJG( vxc( nl( ig ) ) ) * srhoc ) / SQRT( gg(ig) * tpiba2 )
<                dcc(i,j) = dcc(i,j) + vxcc * &
<      &                      2.d0 * tpiba2 * g(i,ig) *                  &
<      &                    (g(1,ig)*ainv(j,1) +                         &
<      &                     g(2,ig)*ainv(j,2) +                         &
<      &                     g(3,ig)*ainv(j,3) )
<             ENDDO
<          ENDDO
<       ENDDO
< 
<       DEALLOCATE( vxc )
< 
<       dcc = dcc * omega
< 
<       CALL mp_sum( dcc( 1:3, 1:3 ), intra_bgrp_comm )
< 
<       RETURN
<    END SUBROUTINE denlcc_x
< 
---
>       implicit none
> #ifdef __PARA
>       include 'mpif.h'
> #endif
>       integer, parameter :: ldmx = 7
>       complex(DP), intent(in) :: c(ngw,nx), eigr(ngw,nat),      &
>      &                               betae(ngw,nhsa)
>       complex(DP), intent(out) :: hpsi(ngw,nx), hpsi_con(1,1)
>       real(DP) forceh(3,nat)
> !
>       complex(DP), allocatable:: wfc(:,:), swfc(:,:),dphi(:,:,:),   &
>      &                               spsi(:,:)
>       real(DP), allocatable   :: becwfc(:,:), bp(:,:),              &
>      &                               dbp(:,:,:), wdb(:,:,:)
>       real(DP), allocatable   :: dns(:,:,:,:)
>       real(DP), allocatable   :: e(:), z(:,:),                      &
>      &                               proj(:,:), temp(:)
>       real(DP), allocatable   :: ftemp1(:), ftemp2(:)
>       real(DP)                :: lambda(ldmx), somma, ntot, nsum,   &
>      &                           nsuma, x_value, g_value, step_value
>       real(DP) :: f1 (ldmx, ldmx), vet (ldmx, ldmx)
>       integer is, ia, iat, nb, isp, l, m, m1, m2, k, i, counter, err, ig
>       integer iv, jv, inl, jnl,alpha,alpha_a,alpha_s,ipol
>       integer, allocatable ::  offset (:,:)
>       complex(DP) :: tempsi
> !
> !
>       allocate(wfc(ngw,n_atomic_wfc))
>       allocate(ftemp1(ldmx))
>       allocate(ftemp2(ldmx))
> !
> ! calculate wfc = atomic states
> !
> !!!      call ewfc(eigr,n_atomic_wfc,wfc)
> !
> ! calculate bec = <beta|wfc>
> !
>       allocate(becwfc(nhsa,n_atomic_wfc))
> !!!      call nlsm1 (n_atomic_wfc,1,nsp,eigr,wfc,becwfc)
> !
>       allocate(swfc(ngw,n_atomic_wfc))
> !!!      call s_wfc(n_atomic_wfc,becwfc,betae,wfc,swfc)
> !
> ! calculate proj = <c|S|wfc>
> !
>       allocate(proj(n,n_atomic_wfc))
>       CALL projwfc_hub( c, nx, eigr, betae, n, n_atomic_wfc,            &
>      & wfc, becwfc, swfc, proj ) !#@
> !
>       allocate(offset(nsp,nat))
>       counter = 0
>       do is = 1, nsp
>          do ia = 1, na(is)
>             do i = 1, upf(is)%nwfc
>                l = upf(is)%lchi(i)
>                if (l.eq.Hubbard_l(is)) offset (is,ia) = counter
>                counter = counter + 2 * l + 1
>             end do
>          end do
>       end do
>       if (counter.ne.n_atomic_wfc)                                      &
>      &                 call errore ('new_ns','nstart<>counter',1)
>       ns(:,:,:,:) = 0.d0
>       iat = 0
>       do is = 1,nsp
>          do ia = 1,na(is)
>             iat = iat + 1
>             if (Hubbard_U(is).ne.0.d0) then 
>                k = offset(is,ia)
>                do m1 = 1, 2*Hubbard_l(is) + 1
>                   do m2 = m1, 2*Hubbard_l(is) + 1
>                      do i = 1,n
> !                      write(6,*) i,ispin(i),f(i)
>                       ns(iat,ispin(i),m1,m2) = ns(iat,ispin(i),m1,m2) + &
>      &                               f(i) * proj(i,k+m2) * proj(i,k+m1)
>                      end do
> !                     ns(iat,:,m2,m1) = ns(iat,:,m1,m2)
>                      ns(iat,1,m2,m1) = ns(iat,1,m1,m2)
>                      ns(iat,2,m2,m1) = ns(iat,2,m1,m2)
>                   end do
>                end do
>             end if
>          end do
>       end do
>       if (nspin.eq.1) ns = 0.5d0 * ns
> ! Contributions to total energy
>       e_hubbard = 0.d0
>       iat = 0
>       do is = 1,nsp
>          do ia = 1,na(is)
>             iat=iat + 1
>             if (Hubbard_U(is).ne.0.d0) then
>                 k = offset(is,ia)
>                 do isp = 1,nspin
>                    do m1 = 1, 2*Hubbard_l(is) + 1
>                      e_hubbard = e_hubbard + 0.5d0 * Hubbard_U(is) *    &
>      &                           ns(iat,isp,m1,m1)
>                      do m2 = 1, 2*Hubbard_l(is) + 1
>                         e_hubbard = e_hubbard - 0.5d0 * Hubbard_U(is) * &
>      &                              ns(iat,isp,m1,m2) * ns(iat,isp,m2,m1)
>                      end do
>                    end do
>                 end do
>              end if
>          end do
>        end do
>        if (nspin.eq.1) e_hubbard = 2.d0*e_hubbard
> !       if (nspin.eq.1) e_lambda = 2.d0*e_lambda
> !
> !      Calculate the potential and forces on wavefunctions due to U
> !
>       hpsi(:,:)=(0.d0,0.d0)
>       iat=0
>       do is = 1, nsp
>          do ia=1, na(is)
>             iat = iat + 1
>             if (Hubbard_U(is).ne.0.d0) then
>                do i=1, n
>                   do m1 = 1, 2 * Hubbard_l(is) + 1
>                      tempsi = proj (i,offset(is,ia)+m1)
>                      do m2 = 1, 2 * Hubbard_l(is) + 1
>                         tempsi = tempsi - 2.d0 * ns(iat,ispin(i),m1,m2)*&
>      &                                proj (i,offset(is,ia)+m2)
>                      enddo
>                      tempsi = tempsi * Hubbard_U(is)/2.d0*f(i)
>                      call zaxpy (ngw,tempsi,swfc(1,offset(is,ia)+m1),1, &
>      &                           hpsi(1,i),1)
>                   enddo
>                enddo
>             endif
>          enddo
>       enddo
> !
> !      Calculate the potential and energy due to constraint
> !
>       hpsi_con(:,:)=0.d0
> !
> ! Calculate the contribution to forces on ions due to U and constraint
> !
>       forceh=0.d0
>       if ((tfor).or.(tprnfor)) then
>         allocate (bp(nhsa,n), dbp(nhsa,n,3), wdb(nhsa,n_atomic_wfc,3))
>         allocate(dns(nat,nspin,ldmx,ldmx))
>         allocate (spsi(ngw,n))
> !
>         call nlsm1 (n,1,nsp,eigr,c,bp)
>         call s_wfc(n,bp,betae,c,spsi)
>         call nlsm2_repl(ngw,nhsa,n,eigr,c,dbp)
>         call nlsm2_repl(ngw,nhsa,n_atomic_wfc,eigr,wfc,wdb)
> !
>         alpha=0
>         do alpha_s = 1, nsp
>          do alpha_a = 1, na(alpha_s)
>             alpha=alpha+1
>             do ipol = 1,3
>                call dndtau(alpha_a,alpha_s,becwfc,spsi,bp,dbp,wdb,      &
>      &                    offset,c,wfc,eigr,betae,proj,ipol,dns)
>                iat=0
>                do is = 1, nsp
>                   do ia=1, na(is)
>                      iat = iat + 1
>                      if (Hubbard_U(is).ne.0.d0) then
>                         do isp = 1,nspin
>                            do m2 = 1,2*Hubbard_l(is) + 1
>                               forceh(ipol,alpha) = forceh(ipol,alpha) -            &
>      &                        Hubbard_U(is) * 0.5d0 * dns(iat,isp,m2,m2)
>                               do m1 = 1,2*Hubbard_l(is) + 1
>                                  forceh(ipol,alpha) = forceh(ipol,alpha) +         &
>      &                           Hubbard_U(is)*ns(iat,isp,m2,m1)*       &
>      &                           dns(iat,isp,m1,m2)
>                               end do
>                            end do
>                         end do
>                      end if
> ! Occupation constraint add here
>                   end do
>                end do
>             end do
>          end do
>         end do
>         if (nspin.eq.1) then
>            forceh = 2.d0 * forceh
>         end if
> !
>         deallocate ( wfc, becwfc, spsi, proj, offset, swfc, dns, bp, dbp, wdb)
>       end if
>       return
>       end subroutine new_ns
> !
> !
> !
> !-----------------------------------------------------------------------
>       subroutine write_ns
> !-----------------------------------------------------------------------
> !
> ! This routine computes the occupation numbers on atomic orbitals.
> ! It also write the occupation number in the output file.
> !
>       USE kinds,            only: DP
>       USE constants,        ONLY: autoev
>       use electrons_base,   only: nspin
>       use electrons_base,   only: n => nbsp 
>       use ions_base,        only: na, nat, nsp
>       use gvecw,            only: ngw
>       USE ldaU,             ONLY: lda_plus_u, Hubbard_U, Hubbard_l
>       USE ldaU,             ONLY: n_atomic_wfc, ns, e_hubbard
>       USE ldaU,             ONLY: Hubbard_lmax
>       use dspev_module,     only : dspev_drv
1596a2793
>       implicit none
1597a2795,2877
>   integer :: is, isp, ia, m1, m2, ldim, iat, err, k
> ! cpunter on atoms type
> ! counter on spin component
> ! counter on atoms
> ! counter on wavefn
> ! counters on d components
>   integer, parameter :: ldmx = 7
>   real(DP), allocatable   :: ftemp1(:), ftemp2(:)
>   real(DP) :: f1 (ldmx * ldmx), vet (ldmx, ldmx)
>   real(DP) :: lambda (ldmx), nsum, nsuma
>   write (*,*) 'enter write_ns'
> 
>   if ( 2 * Hubbard_lmax + 1 .gt. ldmx ) &
>        call errore ('write_ns', 'ldmx is too small', 1)
> 
> !  if (step_con) then
> !     do isp=1,nspin
> !        write (6,'(6(a,i2,a,i2,a,f8.4,6x))') &
> !        ('A_con(',is,',',isp,') =', A_con(is,isp),is=1,nsp)
> !     enddo
> !     write (6,'(6(a,i2,a,f8.4,6x))') &
> !           ('sigma_con(',is,') =', sigma_con(is), is=1,nsp)
> !     write (6,'(6(a,i2,a,f8.4,6x))') &
> !        ('alpha_con(',is,') =', alpha_con(is), is=1,nsp)
> !  endif
>   write (6,'(6(a,i2,a,f8.4,6x))') &
>         ('U(',is,') =', Hubbard_U(is) * autoev, is=1,nsp)
> !  write (6,'(6(a,i2,a,f8.4,6x))') &
> !        ('alpha(',is,') =', Hubbard_alpha(is) * autoev, is=1,nsp)
>       nsum = 0.d0
>       allocate(ftemp1(ldmx))
>       allocate(ftemp2(ldmx))
>       iat = 0
>       write(6,*) 'nsp',nsp
>       do is = 1,nsp
>          do ia = 1, na(is)
>             nsuma = 0.d0
>             iat = iat + 1
> !        if (iat.eq.1) then
>             if (Hubbard_U(is).ne.0.d0) then
>                do isp = 1, nspin
>                    do m1 = 1, 2 * Hubbard_l(is) + 1
>                       nsuma = nsuma + ns (iat, isp, m1, m1)
>                    end do
>                end do
>                if (nspin.eq.1) nsuma = 2.d0 * nsuma
>                write(6,'(a,1x,i2,2x,a,f11.7)') 'atom', iat,              &
>      &                                      ' Tr[ns(na)]= ',nsuma
>                nsum = nsum + nsuma
> !
>                do isp = 1, nspin
> 
>                   k = 0
>                   do m1 = 1, 2 * Hubbard_l(is) + 1
>                      do m2 = m1, 2 * Hubbard_l(is) + 1
>                         k = k + 1
>                         f1 ( k ) = ns (iat, isp, m2, m1)
>                      enddo
>                   enddo
> 
>                   CALL dspev_drv( 'V', 'L', 2 * Hubbard_l(is) + 1, f1, lambda, vet, ldmx  )
> 
>                   write(6,'(a,1x,i2,2x,a,1x,i2)') 'atom', iat, 'spin', isp
>                   write(6,'(a,7f10.7)') 'eigenvalues: ',(lambda(m1),m1=1,&
>      &                                2 * Hubbard_l(is) + 1)
>                   write(6,*) 'eigenvectors'
>                   do m2 = 1, 2*Hubbard_l(is)+1
>                      write(6,'(i2,2x,7(f10.7,1x))') m2,(real(vet(m1,m2)),&
>      &                            m1=1,2 * Hubbard_l(is) + 1)
>                   end do
>                   write(6,*) 'occupations'
>                   do m1 = 1, 2*Hubbard_l(is)+1
>                      write (6,'(7(f6.3,1x))') (ns(iat,isp,m1,m2),m2=1,    &
>      &                     2*Hubbard_l(is)+1)
>                   end do
>                end do
>             end if
> !        end if
>          end do
>       end do
>       deallocate ( ftemp1, ftemp2)
>       return
>       end subroutine write_ns
1599c2879
<       SUBROUTINE dotcsc_x( eigr, cp, ngw, n )
---
>       subroutine genatwfc(n_atomic_wfc,atwfc)
1601a2882,2890
> ! Compute atomic wavefunctions in G-space, in the same order as used in new_ns
> !
>       use ions_base,          only: na, nsp
>       use gvecw,              only: ngw
>       use reciprocal_vectors, only: g, gx, ng0 => gstart
>       use cell_base,          only: omega, tpiba
>       use constants,          only: fpi
>       USE atom,               ONLY: rgrid
>       USE uspp_param,         ONLY: upf
1603,1610d2891
<       USE ions_base,          ONLY: na, nsp, nat
<       USE io_global,          ONLY: stdout
<       USE gvect, ONLY: gstart
<       USE uspp,               ONLY: nkb, qq
<       USE uspp_param,         ONLY: nh, ish, nvb
<       USE mp,                 ONLY: mp_sum
<       USE mp_global,          ONLY: intra_bgrp_comm, nbgrp
<       USE cp_interfaces,      ONLY: nlsm1
1612c2893,2895
<       IMPLICIT NONE
---
>       implicit none
>       integer, intent(in) :: n_atomic_wfc
>       complex(DP), intent(out):: atwfc(ngw,n_atomic_wfc)
1614,1621c2897,2899
<       INTEGER,     INTENT(IN) :: ngw, n
<       COMPLEX(DP), INTENT(IN) :: eigr(:,:), cp(:,:)
< ! local variables
<       REAL(DP) rsum, csc(n) ! automatic array
<       COMPLEX(DP) temp(ngw) ! automatic array
<  
<       REAL(DP), ALLOCATABLE::  becp(:,:)
<       INTEGER i,kmax,nnn,k,ig,is,ia,iv,jv,inl,jnl
---
>       integer natwfc, is, ia, ir, nb, l, m, lm, i, lmax_wfc, ig
>       real(DP), allocatable::  ylm(:,:), q(:), jl(:), vchi(:),        &
>      &     chiq(:), gxn(:,:)
1623,1624c2901,2902
<       IF( nbgrp > 1 ) &
<          CALL errore( ' dotcsc ', ' parallelization over bands not yet implemented ', 1 ) 
---
>       IF( .NOT. ALLOCATED( rgrid ) ) &
>          CALL errore( ' genatwfc ', ' rgrid not allocated ', 1 )
1626c2904,2906
<       ALLOCATE(becp(nkb,n))
---
>       allocate(q(ngw))
>       allocate(gxn(3,ngw))
>       allocate(chiq(ngw))
1628c2908,2914
< !     < beta | phi > is real. only the i lowest:
---
>       do ig=1,ngw
>          q(ig) = sqrt(g(ig))*tpiba
>       end do
>       if (ng0.eq.2) gxn(1,:)=0.0d0
>       do ig=ng0,ngw
>          gxn(:,ig) = gx(:,ig)/sqrt(g(ig)) !ik<=>ig
>       end do
1630,1634c2916,2917
<       nnn = MIN( 12, n )
< 
<       DO i = nnn, 1, -1
<          kmax = i
<          CALL nlsm1(i,1,nvb,eigr,cp,becp)
---
>       natwfc=0
> !#@@@@
1636,1644c2919,2929
<          DO k=1,kmax
<             DO ig=1,ngw
<                temp(ig)=CONJG(cp(ig,k))*cp(ig,i)
<             END DO
<             csc(k)=2.d0*DBLE(SUM(temp))
<             IF (gstart == 2) csc(k)=csc(k)-DBLE(temp(1))
<          END DO
< 
<          CALL mp_sum( csc( 1:kmax ), intra_bgrp_comm )
---
> ! calculate max angular momentum required in wavefunctions
> !
>       lmax_wfc=-1
>       DO is = 1,nsp
>          lmax_wfc = MAX (lmax_wfc, MAXVAL ( upf(is)%lchi(1:upf(is)%nwfc) ) )
>       ENDDO
>       !
>       ALLOCATE(ylm(ngw,(lmax_wfc+1)**2))
>       !
>       CALL ylmr2 ((lmax_wfc+1)**2, ngw, gx, g, ylm)
> !#@@@@
1646,1661c2931,2968
<          DO k=1,kmax
<             rsum=0.d0
<             DO is=1,nvb
<                DO iv=1,nh(is)
<                   DO jv=1,nh(is)
<                      DO ia=1,na(is)
<                         inl=ish(is)+(iv-1)*na(is)+ia
<                         jnl=ish(is)+(jv-1)*na(is)+ia
<                         rsum = rsum +                                    &
<      &                   qq(iv,jv,is)*becp(inl,i)*becp(jnl,k)
<                      END DO
<                   END DO
<                END DO
<             END DO
<             csc(k)=csc(k)+rsum
<          END DO
---
>       do is = 1, nsp
>          ALLOCATE  ( jl(rgrid(is)%mesh), vchi(rgrid(is)%mesh) )
>          do ia=1,na(is)
> !
> !   radial fourier transform of the chi functions
> !   NOTA BENE: chi is r times the radial part of the atomic wavefunction
> !              bess requires l+1, not l, on input
> !
>             do nb = 1,upf(is)%nwfc
>                l = upf(is)%lchi(nb)
>                do i=1,ngw
>                   call sph_bes (rgrid(is)%mesh, rgrid(is)%r, q(i), l, jl)
>                   do ir=1,rgrid(is)%mesh
>                      vchi(ir) = upf(is)%chi(ir,nb)*rgrid(is)%r(ir)*jl(ir)
>                   enddo
>                   call simpson_cp90(rgrid(is)%mesh,vchi,rgrid(is)%rab,chiq(i))
>                enddo
> !
> !   multiply by angular part and structure factor
> !   NOTA BENE: the factor i^l MUST be present!!!
> !
>                do m = 1,2*l+1
>                   lm = l**2 + m
> !                  call ylmr2b(lm,ngw,ngw,gxn,ylm)
>                   natwfc = natwfc + 1
>                   atwfc(:,natwfc) = (0.d0,1.d0)**l * ylm(:,lm)*chiq(:)
>                enddo
>             enddo
>          end do
>          DEALLOCATE  ( vchi, jl )
>       end do
> !
>       do i = 1,natwfc
>         call dscal(2*ngw,fpi/sqrt(omega),atwfc(1,i),1)
>       end do
> !
>       if (natwfc.ne.n_atomic_wfc)                                       &
>      &     call errore('atomic_wfc','unexpected error',natwfc)
1663c2970,2973
<          WRITE( stdout,'("dotcsc =",12f18.15)') (csc(k),k=1,i)
---
>       deallocate(ylm)
>       deallocate(chiq)
>       deallocate(gxn)
>       deallocate(q)
1665,1666c2975,2976
<       END DO
<       WRITE( stdout,*)
---
>       return
>       end subroutine genatwfc
1668c2978,2983
<       DEALLOCATE(becp)
---
> !-------------------------------------------------------------------------
>       subroutine dndtau(alpha_a,alpha_s,becwfc,spsi,bp,dbp,wdb,         &
>      &                  offset,c,wfc,                                   &
>      &                  eigr,betae,                                     &
>      &                  proj,ipol,dns)
> !-----------------------------------------------------------------------
1670,1673c2985,3208
<       RETURN
<       END SUBROUTINE dotcsc_x
< 
< 
---
> ! This routine computes the derivative of the ns with respect to the ionic
> ! displacement tau(alpha,ipol) used to obtain the Hubbard contribution to the
> ! atomic forces.
> !
>       use ions_base, only: na, nat, nsp
>       use gvecw, only: ngw
>       use electrons_base, only: nspin, n => nbsp, nx => nbspx, ispin, f
>       USE uspp,           ONLY: nhsa=>nkb
>       USE ldaU,           ONLY: Hubbard_U, Hubbard_l
>       USE ldaU,           ONLY: n_atomic_wfc, ns
>       USE kinds,          ONLY: DP
> !
>       implicit none
>       integer, parameter :: ldmx = 7
>       integer ibnd,is,i,ia,counter, m1,m2, l, iat, alpha, ldim
> ! input
>       integer,      intent(in) :: offset(nsp,nat)
>       integer,      intent(in) :: alpha_a,alpha_s,ipol
>       real(DP),     intent(in) :: wfc(ngw,n_atomic_wfc),  c(2,ngw,nx),  &
>      &                            eigr(2,ngw,nat),betae(2,ngw,nhsa),    &
>      &                            becwfc(nhsa,n_atomic_wfc),            &
>      &                            bp(nhsa,n), dbp(nhsa,n,3), wdb(nhsa,n_atomic_wfc,3)
>       real(DP),     intent(in) :: proj(n,n_atomic_wfc)
>       complex (DP), intent(in) :: spsi(ngw,n)
> ! output
>       real (DP),   intent(out) :: dns(nat,nspin,ldmx,ldmx)
> !
> !     dns !derivative of ns(:,:,:,:) w.r.t. tau
> !
>       real (DP),   allocatable :: dproj(:,:)
> !
> !     dproj(n,n_atomic_wfc) ! derivative of proj(:,:) w.r.t. tau 
> !
>       allocate (dproj(n,n_atomic_wfc) )
> !
>       dns(:,:,:,:) = 0.d0
> !
>           call dprojdtau(c,wfc,becwfc,spsi,bp,dbp,wdb,eigr,alpha_a,     &
>      &                   alpha_s,ipol,offset(alpha_s,alpha_a),dproj)
> !
> ! compute the derivative of occupation numbers (the quantities dn(m1,m2))
> ! of the atomic orbitals. They are real quantities as well as n(m1,m2)
> !
>       iat=0
>       do is=1,nsp
>          do ia = 1,na(is)
>             iat=iat+1
>             if (Hubbard_U(is).ne.0.d0) then
>                ldim = 2*Hubbard_l(is) + 1
>                do m1 = 1, ldim
>                   do m2 = m1, ldim
>                      do ibnd = 1,n
>                         dns(iat,ispin(ibnd),m1,m2) =                    &
>      &                  dns(iat,ispin(ibnd),m1,m2) +                    &
>      &                   f(ibnd)*REAL(  proj(ibnd,offset(is,ia)+m1) *   &
>      &                   (dproj(ibnd,offset(is,ia)+m2))  +              &
>      &                         dproj(ibnd,offset(is,ia)+m1)  *          &
>      &                         (proj(ibnd,offset(is,ia)+m2)) )
>                      end do
>                      dns(iat,:,m2,m1) = dns(iat,:,m1,m2)
>                   end do
>                end do
>             end if
>          end do
>       end do
> !
>       deallocate (dproj)
>       return
>       end subroutine dndtau
> !
> !
> !-----------------------------------------------------------------------
>       subroutine dprojdtau(c,wfc,becwfc,spsi,bp,dbp,wdb,eigr,alpha_a,    &
>      &                     alpha_s,ipol,offset,dproj)
> !-----------------------------------------------------------------------
> !
> ! This routine computes the first derivative of the projection
> ! <\fi^{at}_{I,m1}|S|\psi_{k,v,s}> with respect to the atomic displacement
> ! u(alpha,ipol) (we remember that ns_{I,s,m1,m2} = \sum_{k,v}
> ! f_{kv} <\fi^{at}_{I,m1}|S|\psi_{k,v,s}><\psi_{k,v,s}|S|\fi^{at}_{I,m2}>)
> !
>       use ions_base, only: na, nat
>       use gvecw, only: ngw
>       use reciprocal_vectors, only: g, gx, ng0 => gstart
>       use electrons_base, only: n => nbsp, nx => nbspx
> !      use gvec
> !      use constants
>       USE uspp,           ONLY: nhsa=>nkb, qq
>       use cvan,           ONLY: ish
>       USE ldaU,           ONLY: Hubbard_U, Hubbard_l
>       USE ldaU,           ONLY: n_atomic_wfc
>       use cell_base,      ONLY: tpiba
>       USE uspp_param,     only: nh !#@@@
>       use mp_global,      only: intra_image_comm
>       use mp,             only: mp_sum
>       USE kinds,          ONLY: DP
> !
>        implicit none
>        integer, parameter :: ldmx = 7
>        integer alpha_a, alpha_s,ipol, offset
> ! input: the displaced atom
> ! input: the component of displacement
> ! input: the offset of the wfcs of the atom "alpha_a,alpha_s"
>        complex (DP), intent(in) :: spsi(ngw,n),                     &
>      &                  c(ngw,nx), eigr(ngw,nat)
> ! input: the atomic wfc
> ! input: S|evc>
>        real(DP), intent(in) ::becwfc(nhsa,n_atomic_wfc),            &
>      &                            wfc(2,ngw,n_atomic_wfc),              &
>      &            bp(nhsa,n), dbp(nhsa,n,3), wdb(nhsa,n_atomic_wfc,3)
>        real(DP), intent(out) :: dproj(n,n_atomic_wfc)
> ! output: the derivative of the projection
> !
>       integer i,ig,m1,ibnd,iwf,ia,is,iv,jv,ldim,alpha,l,m,k,inl
> !
>       real (DP)  a1, a2
>       real(kind=8), allocatable :: gk(:)
> !
>       complex (DP), allocatable :: dwfc(:,:)
>       real (DP), allocatable :: betapsi(:,:),                       &
>      &                              dbetapsi(:,:),                      &
>      &                              wfcbeta(:,:),wfcdbeta(:,:),temp(:)
> !      dwfc(ngw,ldmx),             ! the derivative of the atomic d wfc
> !      betapsi(nh,n),              ! <beta|evc>
> !      dbetapsi(nh,n),             ! <dbeta|evc>
> !      wfcbeta(n_atomic_wfc,nh),   ! <wfc|beta>
> !      wfcdbeta(n_atomic_wfc,nh),  ! <wfc|dbeta>
>       ldim = 2 * Hubbard_l(alpha_s) + 1
>       allocate ( dwfc(ngw,ldmx),betapsi(nh(alpha_s),n))
>       allocate ( dbetapsi(nh(alpha_s),n),                               &
>      &           wfcbeta(n_atomic_wfc,nh(alpha_s)))
>       allocate (wfcdbeta(n_atomic_wfc,nh(alpha_s)) )
>       dproj(:,:)=0.d0
> !
> ! At first the derivative of the atomic wfc is computed
> !
> !
>       allocate(gk(ngw))
>       allocate(temp(ngw))
> !
>       if (Hubbard_U(alpha_s).ne.0.d0) then
> !
>          do ig=1,ngw
>             gk(ig)=gx(ipol,ig)*tpiba 
> !
>             do m1=1,ldim
>                   dwfc(ig,m1) = CMPLX (gk(ig)*wfc(2,ig,offset+m1),      &
>      &                  -1*gk(ig)*wfc(1,ig,offset+m1), kind=dp )
>             end do
>          end do
> !
>          do ibnd=1,n
>             do m1=1,ldim
>                temp(:)=real(conjg(dwfc(:,m1))*spsi(:,ibnd))
>                dproj(ibnd,offset+m1)=2.d0*SUM(temp) 
>                if (ng0.eq.2) dproj(ibnd,offset+m1)=dproj(ibnd,offset+m1)-temp(1)
>             end do
>          end do
>          call mp_sum( dproj, intra_image_comm )
>       end if
>       do iv=1,nh(alpha_s)
>          inl=ish(alpha_s)+(iv-1)*na(alpha_s)+alpha_a
>          do i=1,n
>             betapsi(iv,i)=bp(inl,i)
>             dbetapsi(iv,i)=dbp(inl,i,ipol)
>          end do
>          do m=1,n_atomic_wfc
> !                 do m1=1,2**Hubbard_l(is) + 1
>             wfcbeta(m,iv)=becwfc(inl,m)
>             wfcdbeta(m,iv)=wdb(inl,m,ipol)
>          end do
>       end do
>       do ibnd=1,n
>          do iv=1,nh(alpha_s)
>             do jv=1,nh(alpha_s)
>                do m=1,n_atomic_wfc
> !                       do m1=1,2**Hubbard_l(is) + 1
>                   dproj(ibnd,m) =                                       &
>      &                        dproj(ibnd,m) + qq(iv,jv,alpha_s) *       &
>      &                         ( wfcdbeta(m,iv)*betapsi(jv,ibnd) +      &
>      &                           wfcbeta(m,iv)*dbetapsi(jv,ibnd) )
>                end do
>             end do
>          end do
>       end do
>       deallocate(temp, gk)
>       deallocate (betapsi)
>       deallocate (dwfc)
>       deallocate (dbetapsi)
>       deallocate (wfcbeta)
>       deallocate (wfcdbeta)
>       return
>       end subroutine dprojdtau
> !
> !
> !-----------------------------------------------------------------------
>       subroutine stepfn(A,sigma,x_value,g_value,step_value)
> !-----------------------------------------------------------------------
> !     This subroutine calculates the value of the gaussian and step
> !     functions with a given x_value. A and sigma are given in the
> !     input file. ... to be used in occupation_constraint...
> !
>       USE constants, ONLY : pi
>       implicit none
>       real(kind=8) A, sigma, x_value, g_value, step_value
>       real(kind=8) x
>       integer i
>       step_value=0.0d0
>       g_value=0.0d0
> !
>       do i=1,100000
>          x=x_value + (i-100000)/100000.0d0*(x_value + 5.d0*sigma)
> !
> ! Integrate from 5 sigma before the x_value
> !
>          g_value=A*dexp(-x*x/(2*sigma*sigma))/(sigma*dsqrt(2*pi))
> !         write(6,*) 'step', step_value,'g',g_value
> !         if (g_value.le.0.0) g_value=0.0
>          if ((x_value+5*sigma).ge.0.0d0) then
>          step_value=step_value+g_value/100000.0d0*(x_value+5.d0*sigma)
>          end if
>       end do
>       return
>       end subroutine stepfn
1676c3211,3212
<    FUNCTION enkin_x( c, f, n )
---
>       SUBROUTINE projwfc_hub( c, nx, eigr, betae, n, n_atomic_wfc,  &
>      & wfc, becwfc, swfc, proj )
1679c3215,3216
<       ! calculation of kinetic energy term
---
>       ! Projection on atomic wavefunctions
>       ! Atomic wavefunctions are not orthogonized
1682,1685c3219,3221
<       USE constants,          ONLY: pi, fpi
<       USE gvecw,              ONLY: ngw
<       USE gvect,              ONLY: gstart
<       USE gvecw,              ONLY: ggp
---
>       USE constants,          ONLY: autoev
>       USE io_global,          ONLY: stdout
>       USE mp_global,          ONLY: intra_image_comm
1687,1743c3223,3226
<       USE mp_global,          ONLY: intra_bgrp_comm
<       USE cell_base,          ONLY: tpiba2
< 
<       IMPLICIT NONE
< 
<       REAL(DP)                :: enkin_x
< 
<       ! input
< 
<       INTEGER,     INTENT(IN) :: n
<       COMPLEX(DP), INTENT(IN) :: c( :, : )
<       REAL(DP),    INTENT(IN) :: f( : )
<       !
<       ! local
< 
<       INTEGER  :: ig, i
<       REAL(DP) :: sk(n)  ! automatic array
<       !
<       DO i=1,n
<          sk(i)=0.0d0
<          DO ig=gstart,ngw
<             sk(i)=sk(i)+DBLE(CONJG(c(ig,i))*c(ig,i))*ggp(ig)
<          END DO
<       END DO
< 
<       CALL mp_sum( sk(1:n), intra_bgrp_comm )
< 
<       enkin_x=0.0d0
<       DO i=1,n
<          enkin_x=enkin_x+f(i)*sk(i)
<       END DO
< 
<       ! ... reciprocal-space vectors are in units of alat/(2 pi) so a
<       ! ... multiplicative factor (2 pi/alat)**2 is required
< 
<       enkin_x = enkin_x * tpiba2
< !
<       RETURN
<    END FUNCTION enkin_x
< 
< !-------------------------------------------------------------------------
<       SUBROUTINE nlfl_bgrp_x( bec_bgrp, becdr_bgrp, lambda, descla, fion )
< !-----------------------------------------------------------------------
< !     contribution to fion due to the orthonormality constraint
< ! 
< !
<       USE kinds,             ONLY: DP
<       USE io_global,         ONLY: stdout
<       USE ions_base,         ONLY: na, nsp, nat
<       USE uspp,              ONLY: nhsa=>nkb, qq
<       USE uspp_param,        ONLY: nhm, nh, ish, nvb
<       USE electrons_base,    ONLY: nspin, iupdwn, nupdwn, nbspx_bgrp, ibgrp_g2l, i2gupdwn_bgrp, nbspx, &
<                                    iupdwn_bgrp, nupdwn_bgrp
<       USE constants,         ONLY: pi, fpi
<       USE descriptors,       ONLY: la_descriptor
<       USE mp,                ONLY: mp_sum
<       USE mp_global,         ONLY: intra_bgrp_comm, inter_bgrp_comm
---
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart
>       USE ions_base,          ONLY: nsp, na, nat
>       USE uspp,               ONLY: nhsa => nkb
1746,1750c3229,3230
<       REAL(DP) :: bec_bgrp(:,:), becdr_bgrp(:,:,:)
<       REAL(DP), INTENT(IN) :: lambda(:,:,:)
<       TYPE(la_descriptor), INTENT(IN) :: descla(:)
<       REAL(DP), INTENT(INOUT) :: fion(:,:)
< 
---
>       INTEGER,     INTENT(IN) :: nx, n, n_atomic_wfc
>       COMPLEX(DP), INTENT(IN) :: c( ngw, nx ), eigr(ngw,nat), betae(ngw,nhsa)
1752,1759c3232,3238
<       INTEGER :: k, is, ia, iv, jv, i, j, inl, isa, iss, nss, istart, ir, ic, nr, nc, ibgrp_i
<       INTEGER :: n1, n2, m1, m2, nrcx
<       REAL(DP), ALLOCATABLE :: temp(:,:), tmpbec(:,:),tmpdr(:,:) 
<       REAL(DP), ALLOCATABLE :: fion_tmp(:,:)
<       REAL(DP), ALLOCATABLE :: bec(:,:,:)
<       REAL(DP), ALLOCATABLE :: becdr(:,:,:,:)
<       REAL(DP), ALLOCATABLE :: bec_g(:,:)
<       REAL(DP), ALLOCATABLE :: becdr_g(:,:,:)
---
>       COMPLEX(DP), INTENT(OUT):: wfc(ngw,n_atomic_wfc),    &
>      & swfc( ngw, n_atomic_wfc )
>       real(DP), intent(out):: becwfc(nhsa,n_atomic_wfc) !DEBUG
>       REAL(DP),    ALLOCATABLE :: overlap(:,:), e(:), z(:,:)
>       REAL(DP),    ALLOCATABLE :: temp(:)
>       REAL(DP)                 :: somma, proj(n,n_atomic_wfc)
>       INTEGER :: is, ia, nb, l, m, k, i
1761c3240
<       CALL start_clock( 'nlfl' )
---
>       ! calculate number of atomic states
1763d3241
<       ALLOCATE( fion_tmp( 3, nat ) )
1765c3243
<       fion_tmp = 0.0d0
---
>       IF ( n_atomic_wfc .EQ. 0 ) RETURN
1767d3244
<       nrcx = MAXVAL( descla( : )%nrcx )
1769,1812c3246
<       ALLOCATE( temp( nrcx, nrcx ), tmpbec( nhm, nrcx ), tmpdr( nrcx, nhm ) )
<       ALLOCATE( bec( nhsa, nrcx, nspin ), becdr( nhsa, nrcx, nspin, 3 ) )
< 
<       ! redistribute bec, becdr according to the ortho subgroup
<       ! this is required because they are combined with "lambda" matrixes
<       
<       DO iss = 1, nspin
<          IF( descla( iss )%active_node > 0 ) THEN
<             nss = nupdwn( iss )
<             istart = iupdwn( iss )
<             ic = descla( iss )%ic
<             nc = descla( iss )%nc
<             DO i=1,nc
<                ibgrp_i = ibgrp_g2l( i+istart-1+ic-1 )
<                IF( ibgrp_i > 0 ) THEN
<                   bec( :, i, iss ) = bec_bgrp( :, ibgrp_i )
<                ELSE
<                   bec( :, i, iss ) = 0.0d0
<                END IF
<             END DO
<             ir = descla( iss )%ir
<             nr = descla( iss )%nr
<             DO i=1,nr
<                ibgrp_i = ibgrp_g2l( i+istart-1+ir-1 )
<                IF( ibgrp_i > 0 ) THEN
<                   becdr(:,i,iss,1) = becdr_bgrp( :, ibgrp_i, 1 )
<                   becdr(:,i,iss,2) = becdr_bgrp( :, ibgrp_i, 2 )
<                   becdr(:,i,iss,3) = becdr_bgrp( :, ibgrp_i, 3 )
<                ELSE
<                   becdr(:,i,iss,1) = 0.0d0
<                   becdr(:,i,iss,2) = 0.0d0
<                   becdr(:,i,iss,3) = 0.0d0
<                END IF
<             END DO
<          ELSE
<             bec(:,:,iss)   = 0.0d0
<             becdr(:,:,iss,1) = 0.0d0
<             becdr(:,:,iss,2) = 0.0d0
<             becdr(:,:,iss,3) = 0.0d0
<          END IF
<       END DO
< 
<       CALL mp_sum( bec, inter_bgrp_comm )
<       CALL mp_sum( becdr, inter_bgrp_comm )
---
>       ! calculate wfc = atomic states
1814,1874c3248
<       DO k=1,3
<          isa = 0
<          DO is=1,nvb
<             DO ia=1,na(is)
<                isa = isa + 1
<                !
<                DO iss = 1, nspin
<                   !
<                   nss = nupdwn( iss )
<                   istart = iupdwn( iss )
<                   !
<                   tmpbec = 0.d0
<                   tmpdr  = 0.d0
<                   !
<                   IF( descla( iss )%active_node > 0 ) THEN
<                      ! tmpbec distributed by columns
<                      ic = descla( iss )%ic
<                      nc = descla( iss )%nc
<                      DO iv=1,nh(is)
<                         DO jv=1,nh(is)
<                            inl=ish(is)+(jv-1)*na(is)+ia
<                            IF(ABS(qq(iv,jv,is)).GT.1.e-5) THEN
<                               DO i=1,nc
<                                  tmpbec(iv,i)=tmpbec(iv,i) + qq(iv,jv,is)*bec(inl,i,iss)
<                               END DO
<                            ENDIF
<                         END DO
<                      END DO
<                      ! tmpdr distributed by rows
<                      ir = descla( iss )%ir
<                      nr = descla( iss )%nr
<                      DO iv=1,nh(is)
<                         inl=ish(is)+(iv-1)*na(is)+ia
<                         DO i=1,nr
<                            tmpdr(i,iv) = becdr( inl, i, iss, k )
<                         END DO
<                      END DO
<                   END IF
<                   !
<                   IF(nh(is).GT.0)THEN
<                      !
<                      IF( descla( iss )%active_node > 0 ) THEN
<                         ir = descla( iss )%ir
<                         ic = descla( iss )%ic
<                         nr = descla( iss )%nr
<                         nc = descla( iss )%nc
<                         CALL dgemm( 'N', 'N', nr, nc, nh(is), 1.0d0, tmpdr, nrcx, tmpbec, nhm, 0.0d0, temp, nrcx )
<                         DO j = 1, nc
<                            DO i = 1, nr
<                               fion_tmp(k,isa) = fion_tmp(k,isa) + 2D0 * temp( i, j ) * lambda( i, j, iss )
<                            END DO
<                         END DO
<                      END IF
< !
<                   ENDIF
< 
<                END DO
< !
<             END DO
<          END DO
<       END DO
---
>       CALL atomic_wfc_northo( eigr, n_atomic_wfc, wfc )
1876,1877c3250
<       DEALLOCATE( bec, becdr )
<       DEALLOCATE( temp, tmpbec, tmpdr )
---
>       ! calculate bec = <beta|wfc>
1879c3252
<       CALL mp_sum( fion_tmp, intra_bgrp_comm )
---
>       CALL nlsm1( n_atomic_wfc, 1, nsp, eigr, wfc, becwfc )
1881c3254
<       fion = fion + fion_tmp
---
>       ! calculate swfc = S|wfc>
1883c3256
<       DEALLOCATE( fion_tmp )
---
>       CALL s_wfc( n_atomic_wfc, becwfc, betae, wfc, swfc )
1885c3258
<       CALL stop_clock( 'nlfl' )
---
>       ! calculate proj = <c|S|wfc>
1886a3260,3270
>       ALLOCATE(temp(ngw))
>       DO m=1,n
>          DO l=1,n_atomic_wfc
>             temp(:)=DBLE(CONJG(c(:,m))*swfc(:,l)) !#@@@
>             proj(m,l)=2.d0*SUM(temp)
>             IF (gstart == 2) proj(m,l)=proj(m,l)-temp(1)
>          END DO
>       END DO
>       DEALLOCATE(temp)
>       CALL mp_sum( proj, intra_image_comm )
> !
1888,1891c3272
< 
<       END SUBROUTINE nlfl_bgrp_x
< 
< 
---
>       END SUBROUTINE projwfc_hub
1894c3275
<       SUBROUTINE pbc(rin,a1,a2,a3,ainv,rout)
---
>       SUBROUTINE atomic_wfc_northo( eigr, n_atomic_wfc, wfc )
1897,1919c3278,3279
< !     brings atoms inside the unit cell
< !
<       USE kinds,  ONLY: DP
< 
<       IMPLICIT NONE
< ! input
<       REAL(DP) rin(3), a1(3),a2(3),a3(3), ainv(3,3)
< ! output
<       REAL(DP) rout(3)
< ! local
<       REAL(DP) x,y,z
< !
< ! bring atomic positions to crystal axis
< !
<       x = ainv(1,1)*rin(1)+ainv(1,2)*rin(2)+ainv(1,3)*rin(3)
<       y = ainv(2,1)*rin(1)+ainv(2,2)*rin(2)+ainv(2,3)*rin(3)
<       z = ainv(3,1)*rin(1)+ainv(3,2)*rin(2)+ainv(3,3)*rin(3)
< !
< ! bring x,y,z in the range between -0.5 and 0.5
< !
<       x = x - NINT(x)
<       y = y - NINT(y)
<       z = z - NINT(z)
---
> ! Compute atomic wavefunctions in G-space
> ! Atomic wavefunctions not orthogonalized
1921c3281,3290
< ! bring atomic positions back in cartesian axis
---
>       USE kinds,              ONLY: DP
>       USE gvecw,              ONLY: ngw
>       USE reciprocal_vectors, ONLY: gstart, g, gx
>       USE ions_base,          ONLY: nsp, na, nat
>       USE cell_base,          ONLY: tpiba, omega !#@@@
>       USE atom,               ONLY: rgrid
>       USE uspp_param,         ONLY: upf
> !#@@@@
>       USE constants,          ONLY: fpi
> !#@@@@
1923,1925c3292,3295
<       rout(1) = x*a1(1)+y*a2(1)+z*a3(1)
<       rout(2) = x*a1(2)+y*a2(2)+z*a3(2)
<       rout(3) = x*a1(3)+y*a2(3)+z*a3(3)
---
>       IMPLICIT NONE
>       INTEGER,     INTENT(in) :: n_atomic_wfc
>       COMPLEX(DP), INTENT(in) :: eigr( ngw, nat )
>       COMPLEX(DP), INTENT(out):: wfc( ngw, n_atomic_wfc )
1927,1928c3297,3298
<       RETURN
<       END SUBROUTINE pbc
---
>       INTEGER :: natwfc, ndm, is, ia, ir, nb, l, m, lm, i, lmax_wfc, isa
>       REAL(DP), ALLOCATABLE ::  ylm(:,:), q(:), jl(:), vchi(:), chiq(:)
1929a3300,3301
>       IF( .NOT. ALLOCATED( rgrid ) ) &
>          CALL errore( ' atomic_wfc_northo ', ' rgrid not allocated ', 1 )
1931,1942c3303
< !-------------------------------------------------------------------------
<       SUBROUTINE prefor_x(eigr,betae)
< !-----------------------------------------------------------------------
< !
< !     input :        eigr =  e^-ig.r_i
< !     output:        betae_i,i(g) = (-i)**l beta_i,i(g) e^-ig.r_i 
< !
<       USE kinds,      ONLY : DP
<       USE ions_base,  ONLY : nsp, na
<       USE gvecw,      ONLY : ngw
<       USE uspp,       ONLY : beta, nhtol
<       USE uspp_param, ONLY : nh, ish
---
> ! calculate max angular momentum required in wavefunctions
1944,1946c3305,3316
<       IMPLICIT NONE
<       COMPLEX(DP), INTENT(IN) :: eigr( :, : )
<       COMPLEX(DP), INTENT(OUT) :: betae( :, : )
---
>       lmax_wfc=-1
>       DO is = 1,nsp
>          lmax_wfc = MAX ( lmax_wfc, MAXVAL (upf(is)%lchi(1:upf(is)%nwfc) ) )
>       ENDDO
>       !
>       ALLOCATE(ylm(ngw,(lmax_wfc+1)**2))
>       !
>       CALL ylmr2 ((lmax_wfc+1)**2, ngw, gx, g, ylm)
>       ndm = MAXVAL(rgrid(1:nsp)%mesh)
>       !
>       ALLOCATE(jl(ndm), vchi(ndm))
>       ALLOCATE(q(ngw), chiq(ngw))
1948,1949c3318,3320
<       INTEGER     :: is, iv, ia, inl, ig, isa
<       COMPLEX(DP) :: ci
---
>       DO i=1,ngw
>          q(i) = SQRT(g(i))*tpiba
>       END DO
1951,1952c3322,3323
<       CALL start_clock( 'prefor' )
<       isa = 0
---
>       natwfc=0
>       isa   = 0
1954,1962c3325,3351
<          DO iv=1,nh(is)
<             ci=(0.0d0,-1.0d0)**nhtol(iv,is)
<             DO ia=1,na(is)
<                inl=ish(is)+(iv-1)*na(is)+ia
<                DO ig=1,ngw
<                   betae(ig,inl)=ci*beta(ig,iv,is)*eigr(ig,ia+isa)
<                END DO
<             END DO
<          END DO
---
>          !
>          !   radial fourier transform of the chi functions
>          !   NOTA BENE: chi is r times the radial part of the atomic wavefunction
>          !
>          DO ia = 1 + isa, na(is) + isa
>             DO nb = 1,upf(is)%nwfc
>                l = upf(is)%lchi(nb)
>                DO i=1,ngw
>                   CALL sph_bes (rgrid(is)%mesh, rgrid(is)%r, q(i), l, jl)
>                   DO ir=1,rgrid(is)%mesh
>                      vchi(ir) = upf(is)%chi(ir,nb)*rgrid(is)%r(ir)*jl(ir)
>                   ENDDO
>                   CALL simpson_cp90(rgrid(is)%mesh,vchi,rgrid(is)%rab,chiq(i))
>                ENDDO
>                !
>                !   multiply by angular part and structure factor
>                !   NOTA BENE: the factor i^l MUST be present!!!
>                !
>                DO m = 1,2*l+1
>                   lm = l**2 + m
>                   !DO ia = 1 + isa, na(is) + isa
>                   natwfc = natwfc + 1
>                   wfc(:,natwfc) = (0.d0,1.d0)**l * eigr(:,ia)* ylm(:,lm)*chiq(:)
>                   !ENDDO
>                ENDDO
>             ENDDO
>          ENDDO
1964,1965c3353,3363
<       END DO
<       CALL stop_clock( 'prefor' )
---
>       ENDDO
> !
>       IF (natwfc.NE.n_atomic_wfc)                                       &
>      &     CALL errore('atomic_wfc','unexpected error',natwfc)
> !
> !#@@@@
>       do i = 1,n_atomic_wfc
>         call dscal(2*ngw,fpi/sqrt(omega),wfc(1,i),1)
>       end do
> !#@@@@
>       DEALLOCATE(q, chiq, vchi, jl, ylm)
1968,2159c3366
<       END SUBROUTINE prefor_x
< 
< !------------------------------------------------------------------------
<     SUBROUTINE collect_bec_x( bec_repl, bec_dist, desc, nspin )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE mp_global,   ONLY : intra_bgrp_comm
<        USE mp,          ONLY : mp_sum
<        USE descriptors, ONLY : la_descriptor
<        USE io_global,   ONLY : stdout
<        REAL(DP), INTENT(OUT) :: bec_repl(:,:)
<        REAL(DP), INTENT(IN)  :: bec_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc(:)
<        INTEGER,  INTENT(IN)  :: nspin
<        INTEGER :: i, ir, n, nrcx, iss
<        !
<        bec_repl = 0.0d0
<        !
<        !  bec is distributed across row processor, the first column is enough
<        !
<        IF( desc( 1 )%active_node > 0 .AND. ( desc( 1 )%myc == 0 ) ) THEN
<           ir = desc( 1 )%ir
<           DO i = 1, desc( 1 )%nr
<              bec_repl( :, i + ir - 1 ) = bec_dist( :, i )
<           END DO
<           IF( nspin == 2 ) THEN
<              n  = desc( 1 )%n   ! number of states with spin==1 ( nupdw(1) )
<              nrcx = desc( 1 )%nrcx ! array elements reserved for each spin ( bec(:,2*nrcx) )
<              ir = desc( 2 )%ir
<              DO i = 1, desc( 2 )%nr
<                 bec_repl( :, i + ir - 1 + n ) = bec_dist( :, i + nrcx )
<              END DO
<           END IF
<        END IF
<        !
<        CALL mp_sum( bec_repl, intra_bgrp_comm )
<        !
<        RETURN
<     END SUBROUTINE collect_bec_x
< 
< !------------------------------------------------------------------------
<     SUBROUTINE distribute_lambda_x( lambda_repl, lambda_dist, desc )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE descriptors
<        REAL(DP), INTENT(IN)  :: lambda_repl(:,:)
<        REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc
<        INTEGER :: i, j, ic, ir
<        IF( desc%active_node > 0 ) THEN
<           ir = desc%ir
<           ic = desc%ic
<           DO j = 1, desc%nc
<              DO i = 1, desc%nr
<                 lambda_dist( i, j ) = lambda_repl( i + ir - 1, j + ic - 1 )
<              END DO
<           END DO
<        END IF
<        RETURN
<     END SUBROUTINE distribute_lambda_x
<     !
< !------------------------------------------------------------------------
<     SUBROUTINE distribute_bec_x( bec_repl, bec_dist, desc, nspin )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE descriptors
<        REAL(DP), INTENT(IN)  :: bec_repl(:,:)
<        REAL(DP), INTENT(OUT) :: bec_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc(:)
<        INTEGER,  INTENT(IN)  :: nspin
<        INTEGER :: i, ir, n, nrcx
<        !
<        IF( desc( 1 )%active_node > 0 ) THEN
<           !
<           bec_dist = 0.0d0
<           !
<           ir = desc( 1 )%ir
<           DO i = 1, desc( 1 )%nr
<              bec_dist( :, i ) = bec_repl( :, i + ir - 1 )
<           END DO
<           !
<           IF( nspin == 2 ) THEN
<              n     = desc( 1 )%n  !  number of states with spin 1 ( nupdw(1) )
<              nrcx  = desc( 1 )%nrcx   !  array elements reserved for each spin ( bec(:,2*nrcx) )
<              ir = desc( 2 )%ir
<              DO i = 1, desc( 2 )%nr
<                 bec_dist( :, i + nrcx ) = bec_repl( :, i + ir - 1 + n )
<              END DO
<           END IF
<           !
<        END IF
<        RETURN
<     END SUBROUTINE distribute_bec_x
<     !
< !------------------------------------------------------------------------
<     SUBROUTINE distribute_zmat_x( zmat_repl, zmat_dist, desc )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE descriptors
<        REAL(DP), INTENT(IN)  :: zmat_repl(:,:)
<        REAL(DP), INTENT(OUT) :: zmat_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc
<        INTEGER :: i, ii, j, me, np
<        me = desc%mype
<        np = desc%npc * desc%npr
<        IF( desc%active_node > 0 ) THEN
<           DO j = 1, desc%n
<              ii = me + 1
<              DO i = 1, desc%nrl
<                 zmat_dist( i, j ) = zmat_repl( ii, j )
<                 ii = ii + np
<              END DO
<           END DO
<        END IF
<        RETURN
<     END SUBROUTINE distribute_zmat_x
<     !
< !------------------------------------------------------------------------
<     SUBROUTINE collect_lambda_x( lambda_repl, lambda_dist, desc )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE mp_global,   ONLY: intra_bgrp_comm
<        USE mp,          ONLY: mp_sum
<        USE descriptors
<        REAL(DP), INTENT(OUT) :: lambda_repl(:,:)
<        REAL(DP), INTENT(IN)  :: lambda_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc
<        INTEGER :: i, j, ic, ir
<        lambda_repl = 0.0d0
<        IF( desc%active_node > 0 ) THEN
<           ir = desc%ir
<           ic = desc%ic
<           DO j = 1, desc%nc
<              DO i = 1, desc%nr
<                 lambda_repl( i + ir - 1, j + ic - 1 ) = lambda_dist( i, j )
<              END DO
<           END DO
<        END IF
<        CALL mp_sum( lambda_repl, intra_bgrp_comm )
<        RETURN
<     END SUBROUTINE collect_lambda_x
<     !
< !------------------------------------------------------------------------
<     SUBROUTINE collect_zmat_x( zmat_repl, zmat_dist, desc )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE mp_global,   ONLY: intra_bgrp_comm
<        USE mp,          ONLY: mp_sum
<        USE descriptors
<        REAL(DP), INTENT(OUT) :: zmat_repl(:,:)
<        REAL(DP), INTENT(IN)  :: zmat_dist(:,:)
<        TYPE(la_descriptor), INTENT(IN)  :: desc
<        INTEGER :: i, ii, j, me, np, nrl
<        zmat_repl = 0.0d0
<        me = desc%mype
<        np = desc%npc * desc%npr
<        nrl = desc%nrl
<        IF( desc%active_node > 0 ) THEN
<           DO j = 1, desc%n
<              ii = me + 1
<              DO i = 1, nrl
<                 zmat_repl( ii, j ) = zmat_dist( i, j )
<                 ii = ii + np
<              END DO
<           END DO
<        END IF
<        CALL mp_sum( zmat_repl, intra_bgrp_comm )
<        RETURN
<     END SUBROUTINE collect_zmat_x
<     !
< !------------------------------------------------------------------------
<     SUBROUTINE setval_lambda_x( lambda_dist, i, j, val, desc )
< !------------------------------------------------------------------------
<        USE kinds,       ONLY : DP
<        USE descriptors
<        REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
<        INTEGER,  INTENT(IN)  :: i, j
<        REAL(DP), INTENT(IN)  :: val
<        TYPE(la_descriptor), INTENT(IN)  :: desc
<        IF( desc%active_node > 0 ) THEN
<           IF( ( i >= desc%ir ) .AND. ( i - desc%ir + 1 <= desc%nr ) ) THEN
<              IF( ( j >= desc%ic ) .AND. ( j - desc%ic + 1 <= desc%nc ) ) THEN
<                 lambda_dist( i - desc%ir + 1, j - desc%ic + 1 ) = val
<              END IF
<           END IF
<        END IF
<        RETURN
<     END SUBROUTINE setval_lambda_x
< 
< 
< !------------------------------------------------------------------------
< 
---
>       END SUBROUTINE atomic_wfc_northo
Only in ../../../ffn2_tsvdw_master/CPV: cplib.F90
diff ./cplib_meta.f90 ../../../ffn2_tsvdw_master/CPV/cplib_meta.f90
2c2
< ! Copyright (C) 2005-2010 Quantum ESPRESSO groups
---
> ! Copyright (C) 2005 FPMD-CPV groups
16,17c16,17
<       use gvect,     only : g
<       use gvecs,                  only : ngms, nlsm, nls
---
>       use reciprocal_vectors
>       use gvecs
18a19,20
>       use smooth_grid_dimensions, only : nr1s, nr2s, nr3s, &
>                                          nr1sx, nr2sx, nr3sx, nnrs => nnrsx
21,22c23,24
<       USE fft_interfaces,         ONLY : fwfft, invfft
<       USE fft_base,               ONLY : dffts
---
>       USE cp_interfaces,          ONLY : fwfft, invfft
>       USE fft_base,               ONLY: dffts
26c28
<       complex(dp) c(ngw), ca(ngw), df(ngw), da(ngw),psi(dffts%nnr)
---
>       complex(8) c(ngw), ca(ngw), df(ngw), da(ngw),psi(nnrs)
28c30
<       real(dp) fi, fip
---
>       real(8) fi, fip
31c33
<       complex(dp) fp,fm,ci
---
>       complex(8) fp,fm,ci
39,40c41,42
<                psi(nls(ig))=g(ipol,ig)* (ci*c(ig) - ca(ig))
<                psi(nlsm(ig))=g(ipol,ig)* (CONJG(ci*c(ig) + ca(ig)))
---
>                psi(nps(ig))=gx(ipol,ig)* (ci*c(ig) - ca(ig))
>                psi(nms(ig))=gx(ipol,ig)* (CONJG(ci*c(ig) + ca(ig)))
44c46
<             do ir=1, dffts%nnr
---
>             do ir=1, nnrs
50,52c52,54
<                fp= (psi(nls(ig)) + psi(nlsm(ig)))
<                fm= (psi(nls(ig)) - psi(nlsm(ig)))
<                df(ig)= df(ig) - ci*fi*tpiba2*g(ipol,ig) * &
---
>                fp= (psi(nps(ig)) + psi(nms(ig)))
>                fm= (psi(nps(ig)) - psi(nms(ig)))
>                df(ig)= df(ig) - ci*fi*tpiba2*gx(ipol,ig) * &
54c56
<                da(ig)= da(ig) - ci*fip*tpiba2*g(ipol,ig)* &
---
>                da(ig)= da(ig) - ci*fip*tpiba2*gx(ipol,ig)* &
65c67
<       subroutine kedtauofr_meta (c, psi, nlsi, psis, nlsis )
---
>       subroutine kedtauofr_meta (c, psi, npsi, psis, npsis )
72,74c74,80
<       use gvect, only: g
<       use gvect, only: nl, nlm
<       use cell_base, only : omega, tpiba, ainv
---
>       use reciprocal_vectors, only: gx
>       use recvecs_indexes, only: np, nm
>       use grid_dimensions, only: nr1, nr2, nr3, &
>             nr1x, nr2x, nr3x, nnr => nnrx
>       use cell_base
>       use smooth_grid_dimensions, only: nr1s, nr2s, nr3s, &
>             nr1sx, nr2sx, nr3sx, nnrsx
77a84
>       use cdvan
81,82c88,89
<       USE fft_interfaces, ONLY: fwfft, invfft
<       USE fft_base,       ONLY: dffts, dfftp
---
>       USE cp_interfaces, ONLY: fwfft, invfft
>       USE fft_base,      ONLY: dffts, dfftp
86,88c93,95
<       integer, intent(in) :: nlsi, nlsis
<       complex(dp) :: c(ngw,nx)
<       complex(dp) :: psi( nlsi ), psis( nlsis )
---
>       integer, intent(in) :: npsi, npsis
>       complex(8) :: c(ngw,nx)
>       complex(8) :: psi( npsi ), psis( npsis )
93,94c100,101
<       real(dp) sa1, sa2
<       complex(dp) ci,fp,fm
---
>       real(8) sa1, sa2
>       complex(8) ci,fp,fm
128,129c135,136
<                psis(nls(ig))=tpiba*g(ipol,ig)* (ci*c(ig,i) - c(ig,i+1))
<                psis(nlsm(ig))=tpiba*g(ipol,ig)*CONJG(ci*c(ig,i)+c(ig,i+1))
---
>                psis(nps(ig))=tpiba*gx(ipol,ig)* (ci*c(ig,i) - c(ig,i+1))
>                psis(nms(ig))=tpiba*gx(ipol,ig)*CONJG(ci*c(ig,i)+c(ig,i+1))
134c141
<             do ir=1, dffts%nnr
---
>             do ir=1, nnrsx
139c146
<                do ir=1, dffts%nnr
---
>                do ir=1, nnrsx
150c157
<                   do ir=1,dffts%nnr
---
>                   do ir=1,nnrsx
166c173
<                      do ir=1,dffts%nnr
---
>                      do ir=1,nnrsx
182c189
<          psis(1:dffts%nnr)=CMPLX(kedtaus(1:dffts%nnr,iss),0.d0,kind=DP)
---
>          psis(1:nnrsx)=CMPLX(kedtaus(1:nnrsx,iss),0.d0,kind=DP)
184c191
<          kedtaug(1:ngms,iss)=psis(nls(1:ngms))
---
>          kedtaug(1:ngs,iss)=psis(nps(1:ngs))
190c197
<          psis(1:dffts%nnr)=CMPLX(kedtaus(1:dffts%nnr,isup),kedtaus(1:dffts%nnr,isdw),kind=DP)
---
>          psis(1:nnrsx)=CMPLX(kedtaus(1:nnrsx,isup),kedtaus(1:nnrsx,isdw),kind=DP)
192,194c199,201
<          do ig=1,ngms
<             fp= psis(nls(ig)) + psis(nlsm(ig))
<             fm= psis(nls(ig)) - psis(nlsm(ig))
---
>          do ig=1,ngs
>             fp= psis(nps(ig)) + psis(nms(ig))
>             fm= psis(nps(ig)) - psis(nms(ig))
208,209c215,216
<          psi(nlm(1:ngms))=CONJG(kedtaug(1:ngms,iss))
<          psi(nl(1:ngms)) =      kedtaug(1:ngms,iss)
---
>          psi(nm(1:ngs))=CONJG(kedtaug(1:ngs,iss))
>          psi(np(1:ngs))=      kedtaug(1:ngs,iss)
211c218
<          kedtaur(1:dfftp%nnr,iss)=DBLE(psi(1:dfftp%nnr))
---
>          kedtaur(1:nnr,iss)=DBLE(psi(1:nnr))
222,224c229,231
<          do ig=1,ngms
<             psi(nlm(ig))=CONJG(kedtaug(ig,isup))+ci*conjg(kedtaug(ig,isdw))
<             psi(nl(ig)) =kedtaug(ig,isup)+ci*kedtaug(ig,isdw)
---
>          do ig=1,ngs
>             psi(nm(ig))=CONJG(kedtaug(ig,isup))+ci*conjg(kedtaug(ig,isdw))
>             psi(np(ig))=kedtaug(ig,isup)+ci*kedtaug(ig,isdw)
227,228c234,235
<          kedtaur(1:dfftp%nnr,isup)= DBLE(psi(1:dfftp%nnr))
<          kedtaur(1:dfftp%nnr,isdw)=AIMAG(psi(1:dfftp%nnr))
---
>          kedtaur(1:nnr,isup)= DBLE(psi(1:nnr))
>          kedtaur(1:nnr,isdw)=AIMAG(psi(1:nnr))
252c259
<       use control_flags, only: thdyn, tpre, tfor, tprnfor
---
>       use control_flags, only: iprint, iprsta, thdyn, tpre, tfor, tprnfor
256c263
<       use gvect, only: ngm, nl, nlm
---
>       use gvecp, only: ng => ngm
257a265,271
>       use cell_base, only: a1, a2, a3, tpiba2
>       use reciprocal_vectors, only: gstart, g
>       use recvecs_indexes, only: np, nm
>       use grid_dimensions, only: nr1, nr2, nr3, &
>             nr1x, nr2x, nr3x, nnr => nnrx
>       use smooth_grid_dimensions, only: nr1s, nr2s, nr3s, &
>             nr1sx, nr2sx, nr3sx, nnrs => nnrsx
263c277
<       use smallbox_gvec
---
>       use gvecb
267c281
<       use mp_global, ONLY : intra_bgrp_comm
---
>       use mp_global, ONLY : intra_image_comm
269,270c283,284
<       USE fft_interfaces, ONLY: fwfft, invfft
<       USE fft_base,       ONLY: dffts, dfftp
---
>       USE cp_interfaces, ONLY: fwfft, invfft
>       USE fft_base,      ONLY: dffts, dfftp
275,277c289,291
<       real(dp) dkedxc(3,3) !metagga
<       complex(dp)  fp, fm, ci
<       complex(dp)  v(dfftp%nnr), vs(dffts%nnr)
---
>       real(8) dkedxc(3,3) !metagga
>       complex(8)  fp, fm, ci
>       complex(8)  v(nnr), vs(nnrs)
302c316
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
307,308c321,322
<          do ig=1,ngm
<             kedtaug(ig,iss)=v(nl(ig))
---
>          do ig=1,ng
>             kedtaug(ig,iss)=v(np(ig))
314c328
<          v(1:dfftp%nnr)=CMPLX(kedtaur(1:dfftp%nnr,isup),kedtaur(1:dfftp%nnr,isdw),kind=DP)
---
>          v(1:nnr)=CMPLX(kedtaur(1:nnr,isup),kedtaur(1:nnr,isdw),kind=DP)
316,318c330,332
<          do ig=1,ngm
<             fp=v(nl(ig))+v(nlm(ig))
<             fm=v(nl(ig))-v(nlm(ig))
---
>          do ig=1,ng
>             fp=v(np(ig))+v(nm(ig))
>             fm=v(np(ig))-v(nm(ig))
328,330c342,344
<          do ig=1,ngms
<             vs(nlsm(ig))=CONJG(kedtaug(ig,iss))
<             vs(nls(ig))=kedtaug(ig,iss)
---
>          do ig=1,ngs
>             vs(nms(ig))=CONJG(kedtaug(ig,iss))
>             vs(nps(ig))=kedtaug(ig,iss)
335c349
<          kedtaus(1:dffts%nnr,iss)=DBLE(vs(1:dffts%nnr))
---
>          kedtaus(1:nnrs,iss)=DBLE(vs(1:nnrs))
339,341c353,355
<          do ig=1,ngms
<             vs(nls(ig))=kedtaug(ig,isup)+ci*kedtaug(ig,isdw)
<             vs(nlsm(ig))=CONJG(kedtaug(ig,isup)) +ci*conjg(kedtaug(ig,isdw))
---
>          do ig=1,ngs
>             vs(nps(ig))=kedtaug(ig,isup)+ci*kedtaug(ig,isdw)
>             vs(nms(ig))=CONJG(kedtaug(ig,isup)) +ci*conjg(kedtaug(ig,isdw))
344,345c358,359
<          kedtaus(1:dffts%nnr,isup)= DBLE(vs(1:dffts%nnr))
<          kedtaus(1:dffts%nnr,isdw)=AIMAG(vs(1:dffts%nnr))
---
>          kedtaus(1:nnrs,isup)= DBLE(vs(1:nnrs))
>          kedtaus(1:nnrs,isdw)=AIMAG(vs(1:nnrs))
353c367
<                   do ir=1,dffts%nnr
---
>                   do ir=1,nnrs
362c376
<           call mp_sum( dkedxc, intra_bgrp_comm )
---
>           call mp_sum( dkedxc, intra_image_comm )
366c380
<                 dxc(i,j) = dxc(i,j) + omega/(dffts%nr1*dffts%nr2*dffts%nr3)*dkedxc(i,j)
---
>                 dxc(i,j) = dxc(i,j) + omega/(nr1s*nr2s*nr3s)*dkedxc(i,j)
Only in ../../../ffn2_tsvdw_master/CPV: cplib_meta.F90
Only in ../../../ffn2_tsvdw_master/CPV: cplib_meta.o
Only in ../../../ffn2_tsvdw_master/CPV: cplib.o
Only in ../../../ffn2_tsvdw_master/CPV: cp_main_variables.mod
Only in ../../../ffn2_tsvdw_master/CPV: cppp.x
diff ./cp_restart.f90 ../../../ffn2_tsvdw_master/CPV/cp_restart.f90
2c2
< ! Copyright (C) 2005-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2005 Quantum ESPRESSO group
16a17
>   USE xml_io_base, ONLY : default_fmt_version => fmt_version
42c43
<     SUBROUTINE cp_writefile( ndw, ascii, nfi, simtime, acc, nk, xk,          &
---
>     SUBROUTINE cp_writefile( ndw, tmp_dir, ascii, nfi, simtime, acc, nk, xk, &
51,66c52,62
<       USE control_flags,            ONLY : gamma_only, force_pairing, trhow, &
<                                            tksw, twfcollect, do_makov_payne
<       USE control_flags,            ONLY : tksw, lwfpbe0nscf, lwfnscf ! Lingzhu Kong
<       USE io_files,                 ONLY : psfile, pseudo_dir, iunwfc, &
<                                            nwordwfc, tmp_dir, diropn
<       USE mp_global,                ONLY : intra_image_comm, me_image, &
<                                            nproc_pool, nproc_image, nproc, &
<                                            mpime, me_bgrp, nproc_bgrp, &
<                                            my_bgrp_id, intra_bgrp_comm, &
<                                            intra_image_comm, inter_bgrp_comm, &
<                                            root_bgrp, intra_pool_comm
<       USE run_info,                 ONLY : title
<       USE gvect,                    ONLY : ngm, ngm_g
<       USE gvecs,                    ONLY : ngms_g, ecuts, dual
<       USE gvecw,                    ONLY : ngw, ngw_g, ecutwfc
<       USE gvect,                    ONLY : ig_l2g, mill
---
>       USE control_flags,            ONLY : gamma_only, force_pairing, trhow, tksw
>       USE io_files,                 ONLY : psfile, pseudo_dir
>       USE mp_global,                ONLY : intra_image_comm, me_image, nproc_image
>       USE printout_base,            ONLY : title
>       USE grid_dimensions,          ONLY : nr1, nr2, nr3, nr1x, nr2x, nr3l
>       USE smooth_grid_dimensions,   ONLY : nr1s, nr2s, nr3s
>       USE smallbox_grid_dimensions, ONLY : nr1b, nr2b, nr3b
>       USE gvecp,                    ONLY : ngm, ngmt, ecutp, gcutp
>       USE gvecs,                    ONLY : ngs, ngst, ecuts, gcuts, dual
>       USE gvecw,                    ONLY : ngw, ngwt, ecutw, gcutw
>       USE reciprocal_vectors,       ONLY : ig_l2g, mill_l
68c64,65
<       USE cell_base,                ONLY : ibrav, alat, celldm, s_to_r
---
>       USE cell_base,                ONLY : ibrav, alat, celldm, &
>                                            symm_type, s_to_r
70,72c67,68
<                                            amass, iforce, ind_bck
<       USE funct,                    ONLY : get_dft_name, get_inlc
<       USE ldaU_cp,                  ONLY : lda_plus_U, ns, ldmx
---
>                                            pmass, amass, iforce, ind_bck
>       USE funct,                    ONLY : get_dft_name
74a71
>       USE mp_global,                ONLY : nproc, mpime
76c73
<       USE fft_base,                 ONLY : dfftp, dffts, dfftb
---
>       USE fft_base,                 ONLY : dfftp
78c75
<       USE uspp_param,               ONLY : n_atom_wfc
---
>       USE cp_interfaces,            ONLY : n_atom_wfc
80,81c77
<       USE cp_main_variables,        ONLY : descla
<       USE cp_interfaces,            ONLY : collect_lambda, collect_zmat
---
>       USE cp_main_variables,        ONLY : collect_lambda, descla, collect_zmat
85a82
>       CHARACTER(LEN=*),      INTENT(IN) :: tmp_dir       !  directory used to store output and restart files
138c135
<       INTEGER               :: j, i, iss, ig, nspin_wfc, iss_wfc
---
>       INTEGER               :: j, i, iss, ig, nspin_wfc, iss_wfc, ii, jj
140c137
<       INTEGER,  ALLOCATABLE :: mill_g(:,:)
---
>       INTEGER,  ALLOCATABLE :: mill(:,:)
154c151
<       INTEGER               :: natomwfc, nbnd_
---
>       INTEGER               :: nbnd_
156,160d152
<       CHARACTER(LEN=256)    :: tmp_dir_save
<       LOGICAL               :: exst
<       INTEGER               :: inlc
<       !
<       ! ... subroutine body
262c254
<       ALLOCATE( mill_g( 3, ngm_g ) )
---
>       ALLOCATE( mill( 3, ngmt ) )
264c256
<       mill_g = 0
---
>       mill = 0
266c258
<       mill_g(:,ig_l2g(1:ngm)) = mill(:,1:ngm)
---
>       mill(:,ig_l2g(1:ngm)) = mill_l(:,1:ngm)
268c260
<       CALL mp_sum( mill_g, intra_bgrp_comm )
---
>       CALL mp_sum( mill, intra_image_comm )
350,351c342,343
<          CALL write_cell( ibrav, celldm, alat, a1, a2, a3, b1, b2, b3, &
<                           do_makov_payne, .FALSE., .FALSE. )
---
>          CALL write_cell( ibrav, symm_type, &
>                           celldm, alat, a1, a2, a3, b1, b2, b3 )
365,367c357,359
<          CALL write_planewaves( ecutwfc, dual, ngw_g, gamma_only, dfftp%nr1, dfftp%nr2, &
<                                 dfftp%nr3, ngm_g, dffts%nr1, dffts%nr2, dffts%nr3, ngms_g, dfftb%nr1, &
<                                 dfftb%nr2, dfftb%nr3, mill_g, .FALSE. )
---
>          CALL write_planewaves( ecutw, dual, ngwt, gamma_only, nr1, nr2, &
>                                 nr3, ngmt, nr1s, nr2s, nr3s, ngst, nr1b, &
>                                 nr2b, nr3b, mill, .FALSE. )
380,382c372
<          inlc = get_inlc()
<          CALL write_xc( DFT = dft_name, NSP = nsp, LDA_PLUS_U = .FALSE., INLC = inlc )
< 
---
>          CALL write_xc( DFT = dft_name, NSP = nsp, LDA_PLUS_U = .FALSE. )
402c392,397
<          CALL write_para( kunit, nproc, nproc_pool, nproc_image )
---
>          CALL iotk_write_begin( iunpun, "PARALLELISM" )
>          !
>          CALL iotk_write_dat( iunpun, &
>                               "GRANULARITY_OF_K-POINTS_DISTRIBUTION", kunit )
>          !
>          CALL iotk_write_end( iunpun, "PARALLELISM" )
423,424c418
<                                 dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, &
<                                 dfftp%ipp, dfftp%npp, ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>                                 nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
433,434c427
<                                 dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, &
<                                 dfftp%ipp, dfftp%npp, ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>                                 nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
447,448c440
<                                 dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, &
<                                 dfftp%ipp, dfftp%npp, ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>                                 nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
457,477d448
< ! ... LDA+U OCCUPATIONS (compatibility with PWscf)
< !-------------------------------------------------------------------------------
<       !
<       IF ( lda_plus_u ) THEN
<          !
<          IF ( ionode ) THEN
<             i = LEN_TRIM( dirname )
<             ! ugly hack to remove .save from dirname
<             filename = dirname (1:i-4) // 'occup'
<             OPEN (UNIT=iunout,FILE=filename,FORM ='formatted',STATUS='unknown')
<             WRITE( iunout, * , iostat = ierr) & 
<                ((( (ns(ia,is,i,j), i=1,ldmx), j=1,ldmx), is=1,nspin), ia=1,nat)
<          END IF
<          CALL mp_bcast( ierr, ionode_id, intra_image_comm )
<          IF ( ierr/=0 ) CALL errore('cp_writefile', 'Writing ldaU ns', 1)
<          IF ( ionode ) THEN
<             CLOSE( UNIT = iunout, STATUS = 'KEEP' )
<          ENDIF
<          !
<       END IF
< !-------------------------------------------------------------------------------
570,571c541
<          natomwfc =  n_atom_wfc ( nat, ityp ) 
<          CALL iotk_write_dat( iunpun, "NUMBER_OF_ATOMIC_WFC", natomwfc )
---
>          CALL iotk_write_dat( iunpun, "NUMBER_OF_ATOMIC_WFC", n_atom_wfc() )
678c648
<          CALL iotk_write_dat  ( iunpun, "MAX_NUMBER_OF_GK-VECTORS", ngw_g )
---
>          CALL iotk_write_dat  ( iunpun, "MAX_NUMBER_OF_GK-VECTORS", ngwt )
694c664
<             CALL iotk_write_dat( iunpun, "NUMBER_OF_GK-VECTORS", ngw_g )
---
>             CALL iotk_write_dat( iunpun, "NUMBER_OF_GK-VECTORS", ngwt )
705c675
<          CALL write_gk( iunout, ik, mill_g, filename )
---
>          CALL write_gk( iunout, ik, mill, filename )
753,755c723,724
<                                ctot( :, ib : ib + nbnd_tot - 1 ), ngw_g, gamma_only,&
<                                nbnd_tot, ig_l2g, ngw, filename, scalef, &
<                                ionode, root_bgrp, intra_bgrp_comm, inter_bgrp_comm, intra_pool_comm )
---
>                                ctot( :, ib : ib + nbnd_tot - 1 ), ngwt, gamma_only,&
>                                nbnd_tot, ig_l2g, ngw, filename, scalef )
759,761c728,730
<             IF( twfcollect ) THEN
<                !
<                !  Save wave function at time t
---
>             !  Save wave function at time t
>             !
>             IF ( ionode ) THEN
763c732
<                IF ( ionode ) THEN
---
>                IF ( nspin == 1 ) THEN
765,773c734
<                   IF ( nspin == 1 ) THEN
<                      !
<                      filename = TRIM( wfc_filename( ".", 'evc0', ik ) )
<                      !
<                   ELSE
<                      !
<                      filename = TRIM( wfc_filename( ".", 'evc0', ik, iss ) )
<                      !
<                   END IF
---
>                   filename = TRIM( wfc_filename( ".", 'evc0', ik ) )
775,776c736
<                   CALL iotk_link( iunpun, "WFC0" // TRIM( iotk_index (iss) ), &
<                                   filename, CREATE = .FALSE., BINARY = .TRUE. )
---
>                ELSE
778,786c738
<                   IF ( nspin == 1 ) THEN
<                      !
<                      filename = TRIM( wfc_filename( dirname, 'evc0', ik ) )
<                      !
<                   ELSE
<                      !
<                      filename = TRIM( wfc_filename( dirname, 'evc0', ik, iss ) )
<                      !
<                   END IF
---
>                   filename = TRIM( wfc_filename( ".", 'evc0', ik, iss ) )
790c742,743
<                ib = iupdwn(iss_wfc)
---
>                CALL iotk_link( iunpun, "WFC0" // TRIM( iotk_index (iss) ), &
>                                filename, CREATE = .FALSE., BINARY = .TRUE. )
792,795c745,753
<                CALL write_wfc( iunout, ik_eff, nk*nspin, kunit, iss, nspin,     &
<                                c02( :, ib : ib + nbnd_ - 1 ), ngw_g, gamma_only, &
<                                nbnd_, ig_l2g, ngw, filename, scalef, &
<                                ionode, root_bgrp, intra_bgrp_comm, inter_bgrp_comm, intra_pool_comm )
---
>                IF ( nspin == 1 ) THEN
>                   !
>                   filename = TRIM( wfc_filename( dirname, 'evc0', ik ) )
>                   !
>                ELSE
>                   !
>                   filename = TRIM( wfc_filename( dirname, 'evc0', ik, iss ) )
>                   !
>                END IF
797c755,765
<                !  Save wave function at time t - dt
---
>             END IF
>             !
>             ib = iupdwn(iss_wfc)
>             !
>             CALL write_wfc( iunout, ik_eff, nk*nspin, kunit, iss, nspin,     &
>                             c02( :, ib : ib + nbnd_ - 1 ), ngwt, gamma_only, &
>                             nbnd_, ig_l2g, ngw, filename, scalef )
>             !
>             !  Save wave function at time t - dt
>             !
>             IF ( ionode ) THEN
799c767
<                IF ( ionode ) THEN
---
>                IF ( nspin == 1 ) THEN
801,809c769
<                   IF ( nspin == 1 ) THEN
<                      !
<                      filename = TRIM( wfc_filename( ".", 'evcm', ik ) )
<                      !
<                   ELSE
<                      !
<                      filename = TRIM( wfc_filename( ".", 'evcm', ik, iss ) )
<                      !
<                   END IF
---
>                   filename = TRIM( wfc_filename( ".", 'evcm', ik ) )
811,812c771
<                   CALL iotk_link( iunpun, "WFCM" // TRIM( iotk_index (iss) ), &
<                                   filename, CREATE = .FALSE., BINARY = .TRUE. )
---
>                ELSE
814,822c773
<                   IF ( nspin == 1 ) THEN
<                      !
<                      filename = TRIM( wfc_filename( dirname, 'evcm', ik ) )
<                      !
<                   ELSE
<                      !
<                      filename = TRIM( wfc_filename( dirname, 'evcm', ik, iss ) )
<                      !
<                   END IF
---
>                   filename = TRIM( wfc_filename( ".", 'evcm', ik, iss ) )
826c777,778
<                ib = iupdwn(iss_wfc)
---
>                CALL iotk_link( iunpun, "WFCM" // TRIM( iotk_index (iss) ), &
>                                filename, CREATE = .FALSE., BINARY = .TRUE. )
828,831c780,788
<                CALL write_wfc( iunout, ik_eff, nk*nspin, kunit, iss, nspin,     &
<                                cm2( :, ib : ib + nbnd_ - 1 ), ngw_g, gamma_only, &
<                                nbnd_, ig_l2g, ngw, filename, scalef, &
<                                ionode, root_bgrp, intra_bgrp_comm, inter_bgrp_comm, intra_pool_comm )
---
>                IF ( nspin == 1 ) THEN
>                   !
>                   filename = TRIM( wfc_filename( dirname, 'evcm', ik ) )
>                   !
>                ELSE
>                   !
>                   filename = TRIM( wfc_filename( dirname, 'evcm', ik, iss ) )
>                   !
>                END IF
834a792,797
>             ib = iupdwn(iss_wfc)
>             !
>             CALL write_wfc( iunout, ik_eff, nk*nspin, kunit, iss, nspin,     &
>                             cm2( :, ib : ib + nbnd_ - 1 ), ngwt, gamma_only, &
>                             nbnd_, ig_l2g, ngw, filename, scalef )
>             !
841c804
<             CALL collect_lambda( mrepl, lambda0(:,:,iss), descla(iss) )
---
>             CALL collect_lambda( mrepl, lambda0(:,:,iss), descla(:,iss) )
852,862d814
<                !=============================================================
<                !  Lingzhu Kong
<                IF ( lwfpbe0nscf .or. lwfnscf ) THEN
<                   OPEN(60,file='cp_lambda.dat',status='unknown',form='formatted') 
<                   DO j = 1, nudx
<                      write(60, '(8f15.8)')(mrepl(i,j),i=1,nudx)
<                   ENDDO
<                   CLOSE(60)
<                ENDIF
<                !=============================================================
< 
866c818
<             CALL collect_lambda( mrepl, lambdam(:,:,iss), descla(iss) )
---
>             CALL collect_lambda( mrepl, lambdam(:,:,iss), descla(:,iss) )
882c834
<                CALL collect_zmat( mrepl, mat_z(:,:,iss), descla(iss) )
---
>                CALL collect_zmat( mrepl, mat_z(:,:,iss), descla(:,iss) )
910,928d861
<       IF( .NOT. twfcollect ) THEN
<          !
<          tmp_dir_save = tmp_dir
<          tmp_dir = TRIM( restart_dir( tmp_dir, ndw ) ) // '/'
<          tmp_dir = TRIM( kpoint_dir( tmp_dir, 1 ) ) // '/'
<          !
<          iunwfc = 10
<          nwordwfc = SIZE( c02 )
<          !
<          CALL diropn ( iunwfc, 'wfc', 2*nwordwfc, exst )
< 
<          CALL davcio ( c02, 2*nwordwfc, iunwfc, 1, +1 )  ! save wave funct
<          CALL davcio ( cm2, 2*nwordwfc, iunwfc, 2, +1 )  ! save wave funct
<          !
<          CLOSE( UNIT = iunwfc, STATUS = 'KEEP' )
<          tmp_dir = tmp_dir_save
<          !
<       END IF
< 
936c869
<       DEALLOCATE( mill_g )
---
>       DEALLOCATE( mill )
954c887
<     SUBROUTINE cp_readfile( ndr, ascii, nfi, simtime, acc, nk, xk,   &
---
>     SUBROUTINE cp_readfile( ndr, tmp_dir, ascii, nfi, simtime, acc, nk, xk,   &
962,967c895,903
<       USE control_flags,            ONLY : gamma_only, force_pairing, iverbosity, twfcollect
<       USE io_files,                 ONLY : iunpun, xmlpun, iunwfc, nwordwfc, &
<                                            tmp_dir, diropn
<       USE run_info,                 ONLY : title
<       USE gvect,                    ONLY : ngm
<       USE gvecw,                    ONLY : ngw, ngw_g
---
>       USE control_flags,            ONLY : gamma_only, force_pairing, iprsta
>       USE io_files,                 ONLY : iunpun, xmlpun
>       USE printout_base,            ONLY : title
>       USE grid_dimensions,          ONLY : nr1, nr2, nr3
>       USE smooth_grid_dimensions,   ONLY : nr1s, nr2s, nr3s
>       USE smallbox_grid_dimensions, ONLY : nr1b, nr2b, nr3b
>       USE gvecp,                    ONLY : ngm, ngmt, ecutp
>       USE gvecs,                    ONLY : ngs, ngst
>       USE gvecw,                    ONLY : ngw, ngwt, ecutw
970,971c906,908
<       USE cell_base,                ONLY : ibrav, alat, celldm, s_to_r, r_to_s
<       USE ions_base,                ONLY : nsp, nat, na, atm, zv, &
---
>       USE cell_base,                ONLY : ibrav, alat, celldm, symm_type, &
>                                            s_to_r, r_to_s
>       USE ions_base,                ONLY : nsp, nat, na, atm, zv, pmass, &
973,978c910,913
<       USE gvect,       ONLY : ig_l2g, mill
<       USE cp_main_variables,        ONLY : nprint_nfi, descla
<       USE cp_interfaces,            ONLY : distribute_lambda, distribute_zmat
<       USE mp,                       ONLY : mp_sum, mp_bcast
<       USE mp_global,                ONLY : intra_image_comm, my_bgrp_id
<       USE mp_global,                ONLY : root_bgrp, intra_bgrp_comm, inter_bgrp_comm, intra_pool_comm
---
>       USE reciprocal_vectors,       ONLY : ig_l2g, mill_l
>       USE cp_main_variables,        ONLY : nprint_nfi, distribute_lambda, descla, distribute_zmat
>       USE mp,                       ONLY : mp_sum
>       USE mp_global,                ONLY : intra_image_comm
984a920
>       CHARACTER(LEN=*),      INTENT(IN)    :: tmp_dir       !
1036c972
<       INTEGER, ALLOCATABLE :: mill_g(:,:)
---
>       INTEGER, ALLOCATABLE :: mill(:,:)
1040a977
>       CHARACTER(LEN=9)      :: symm_type_
1046c983
<       REAL(DP)              :: zv_ 
---
>       REAL(DP)              :: pmass_, zv_ 
1066,1068d1002
<       LOGICAL               :: exst, exist_wfc 
<       CHARACTER(LEN=256)    :: tmp_dir_save
<       INTEGER               :: io_bgrp_id
1079d1012
<       exist_wfc = .FALSE.
1116c1049
<             qexml_version = TRIM( fmt_version )
---
>             qexml_version = TRIM( default_fmt_version )
1161c1094,1095
<          CALL read_cell( ibrav_, celldm_, alat_, a1_, a2_, a3_, b1, b2, b3 )
---
>          CALL read_cell( ibrav_, symm_type_, celldm_, &
>                          alat_, a1_, a2_, a3_, b1, b2, b3 )
1474,1475c1408,1412
<                ierr = 33
<                GOTO 90
---
> !===============================================================
> !Lingzhu Kong
> !              ierr = 33
> !              GOTO 90
> !===============================================================
1486,1487c1423,1427
<                ierr = 33
<                GOTO 90
---
> !===============================================================
> !Lingzhu Kong
> !              ierr = 33
> !              GOTO 90
> !===============================================================
1603d1542
<             !
1626,1633c1565,1580
<             IF ( iss == 1 ) THEN
<                IF( found ) THEN
<                   exist_wfc = .TRUE.
<                END IF
<             ELSE
<                IF( exist_wfc .AND. .NOT. found ) THEN
<                   CALL errore( " readfile ", " second spin component of wave functions not found! ", 1 )
<                END IF
---
>             IF( .NOT. found ) &
>                CALL errore( " readfile ", " wave functions not found! ", 1 )
>             !
>             IF( .NOT. ( iss > 1 .AND. force_pairing ) ) THEN
>                !
>                ! Only WF with spin 1 are needed when force_pairing is active
>                !
>                ib = iupdwn(iss)
>                nb = nupdwn(iss)
>                !
>                ! filename is not needed we are following the link!
>                !
>                CALL read_wfc( iunpun, ik_eff , nk, kunit, iss_, nspin_, &
>                               c02( :, ib:ib+nb-1 ), ngwt_, nbnd_, ig_l2g, ngw, &
>                               filename, scalef_, .TRUE. )
>                !
1636c1583,1596
<             IF( exist_wfc ) THEN
---
>             IF ( ionode ) &
>                CALL iotk_scan_end( iunpun, TRIM(filename) )
>             !
>             IF ( ionode ) THEN 
>                !
>                CALL iotk_scan_begin( iunpun, "WFCM" // TRIM( iotk_index (iss) ), FOUND = found )
>                !
>                filename = "WFCM" // TRIM( iotk_index (iss) )
>                !
>             END IF
>             !
>             CALL mp_bcast( found, ionode_id, intra_image_comm )
>             !
>             IF( found ) THEN
1645,1651c1605,1607
<                   ! filename is not needed we are following the link!
<                   !
<                   CALL read_wfc( iunpun, ik_eff , nk, kunit, iss_, nspin_, &
<                                  c02( :, ib:ib+nb-1 ), ngwt_, nbnd_, ig_l2g, ngw, &
<                                  filename, scalef_, &
<                                  ionode, root_bgrp, intra_bgrp_comm, &
<                                  inter_bgrp_comm, intra_pool_comm, .TRUE. )
---
>                   CALL read_wfc( iunpun, ik_eff, nk, kunit, iss_, nspin_, &
>                                  cm2( :, ib:ib+nb-1 ), ngwt_, nbnd_, ig_l2g, ngw, &
>                                  filename, scalef_ , .TRUE. )
1656c1612
<                   CALL iotk_scan_end( iunpun, TRIM(filename) )
---
>                   CALL iotk_scan_end( iunpun, TRIM( filename ) )
1658,1666c1614
<                IF ( ionode ) THEN 
<                   !
<                   CALL iotk_scan_begin( iunpun, "WFCM" // TRIM( iotk_index (iss) ), FOUND = found )
<                   !
<                   filename = "WFCM" // TRIM( iotk_index (iss) )
<                   !
<                END IF
<                !
<                CALL mp_bcast( found, ionode_id, intra_image_comm )
---
>             ELSE
1668,1692c1616
<                IF( found ) THEN
<                   !
<                   IF( .NOT. ( iss > 1 .AND. force_pairing ) ) THEN
<                      !
<                      ! Only WF with spin 1 are needed when force_pairing is active
<                      !
<                      ib = iupdwn(iss)
<                      nb = nupdwn(iss)
<                      !
<                      CALL read_wfc( iunpun, ik_eff, nk, kunit, iss_, nspin_, &
<                                     cm2( :, ib:ib+nb-1 ), ngwt_, nbnd_, ig_l2g, ngw, &
<                                     filename, scalef_ , &
<                                     ionode, root_bgrp, intra_bgrp_comm, &
<                                     inter_bgrp_comm, intra_pool_comm, .TRUE. )
<                      !
<                   END IF
<                   !
<                   IF ( ionode ) &
<                      CALL iotk_scan_end( iunpun, TRIM( filename ) )
<                   !
<                ELSE
<                   !
<                   cm2 = c02
<                   !
<                END IF
---
>                cm2 = c02
1697,1706d1620
<          ! 
<          !  here the I/O group send wfc to other groups
<          !
<          io_bgrp_id = 0
<          IF( ionode ) io_bgrp_id = my_bgrp_id
<          CALL mp_sum( io_bgrp_id, inter_bgrp_comm )
<          CALL mp_sum( io_bgrp_id, intra_bgrp_comm )
<          !
<          CALL mp_bcast( cm2, io_bgrp_id, inter_bgrp_comm )
<          CALL mp_bcast( c02, io_bgrp_id, inter_bgrp_comm )
1726c1640
<             CALL distribute_lambda( mrepl, lambda0(:,:,iss), descla(iss) )
---
>             CALL distribute_lambda( mrepl, lambda0(:,:,iss), descla(:,iss) )
1738c1652
<             CALL distribute_lambda( mrepl, lambdam(:,:,iss), descla(iss) )
---
>             CALL distribute_lambda( mrepl, lambdam(:,:,iss), descla(:,iss) )
1752c1666
<                CALL distribute_zmat( mrepl, mat_z(:,:,iss), descla(iss) )
---
>                CALL distribute_zmat( mrepl, mat_z(:,:,iss), descla(:,iss) )
1814,1833d1727
<       !
<       IF( .NOT. exist_wfc ) THEN
<          !
<          tmp_dir_save = tmp_dir
<          tmp_dir = TRIM( restart_dir( tmp_dir, ndr ) ) // '/'
<          tmp_dir = TRIM( kpoint_dir( tmp_dir, 1 ) ) // '/'
<          !
<          iunwfc = 10
<          nwordwfc = SIZE( c02 )
<          !
<          CALL diropn ( iunwfc, 'wfc', 2*nwordwfc, exst )
<   
<          IF ( exst ) THEN
<             CALL davcio ( c02, 2*nwordwfc, iunwfc, 1, -1 )  ! read wave funct
<             CALL davcio ( cm2, 2*nwordwfc, iunwfc, 2, -1 )  ! read wave funct
<             CLOSE( UNIT = iunwfc, STATUS = 'KEEP' )
<          ELSE
<             CLOSE( UNIT = iunwfc, STATUS = 'DELETE' )
<             CALL errore( ' readfile ' , ' no wave function found! ' , 1 )
<          END IF
1835,1837d1728
<          tmp_dir = tmp_dir_save
<          !
<       END IF
1850c1741
<          IF( iverbosity > 2 ) write( stdout,*) 'nprint_nfi= ',nprint_nfi
---
>          IF( iprsta > 2 ) write( stdout,*) 'nprint_nfi= ',nprint_nfi
1862,1866c1753
<       USE gvecw,              ONLY : ngw
<       USE io_global,          ONLY : ionode
<       USE mp_global,          ONLY : root_bgrp, intra_bgrp_comm, inter_bgrp_comm, intra_pool_comm, my_bgrp_id
<       USE mp,                 ONLY : mp_bcast, mp_sum
<       USE gvect,              ONLY : ig_l2g
---
>       USE reciprocal_vectors, ONLY : ngwt, ngw, ig_l2g
1878d1764
<       INTEGER            :: io_bgrp_id
1915a1802
>                   print *, 'before read_wfc me4'
1918,1928c1805
<                      filename, scalef, & 
<                      ionode, root_bgrp, intra_bgrp_comm, &
<                      inter_bgrp_comm, intra_pool_comm )
<       ! 
<       !  here the I/O group send wfc to other groups
<       !
<       io_bgrp_id = 0
<       IF( ionode ) io_bgrp_id = my_bgrp_id
<       CALL mp_sum( io_bgrp_id, inter_bgrp_comm )
<       CALL mp_sum( io_bgrp_id, intra_bgrp_comm )
<       CALL mp_bcast( c2, io_bgrp_id, inter_bgrp_comm )
---
>                      filename, scalef )
1933a1811
> 
1936a1815
> 
1942,1943c1821
<       USE gvecw,              ONLY : ngw
<       USE gvect,              ONLY : ig_l2g
---
>       USE reciprocal_vectors, ONLY : ngwt, ngw, ig_l2g
1945,1946c1823
<       USE mp_global,          ONLY : intra_bgrp_comm, inter_bgrp_comm, &
<                                      root_bgrp, intra_pool_comm
---
>       !
1997,2000c1874
<                      filename, scalef, &
<                      ionode, root_bgrp, intra_bgrp_comm, &
<                      inter_bgrp_comm, intra_pool_comm )
< 
---
>                      filename, scalef )
2004a1879
> 
2038a1914
>       CHARACTER(LEN=9) :: symm_type_
2114c1990,1991
<             CALL read_cell( ibrav_, celldm_, alat_, a1_,a2_,a3_, b1_, b2_, b3_ )
---
>             CALL read_cell( ibrav_, symm_type_, celldm_, &
>                             alat_, a1_, a2_, a3_, b1_, b2_, b3_ )
2153c2030,2031
<     SUBROUTINE read_cell( ibrav, celldm, alat, a1, a2, a3, b1, b2, b3 )
---
>     SUBROUTINE read_cell( ibrav, symm_type, &
>                           celldm, alat, a1, a2, a3, b1, b2, b3 )
2156a2035
>       CHARACTER(LEN=*), INTENT(OUT) :: symm_type
2200a2080,2082
>       IF ( ibrav == 0 ) &
>          CALL iotk_scan_dat( iunpun, "CELL_SYMMETRY", symm_type )
>       !
2312c2194
<     SUBROUTINE write_gk( iun, ik, mill_g, filename )
---
>     SUBROUTINE write_gk( iun, ik, mill, filename )
2314c2196
<        USE gvecw,                    ONLY : ngw, ngw_g
---
>        USE gvecw,                    ONLY : ngw, ngwt
2316c2198
<        USE gvect,       ONLY : ig_l2g, mill
---
>        USE reciprocal_vectors,       ONLY : ig_l2g, mill_l
2318c2200
<        USE mp_global,                ONLY : intra_bgrp_comm
---
>        USE mp_global,                ONLY : intra_image_comm
2324c2206
<        INTEGER,            INTENT(IN) :: mill_g(:,:)
---
>        INTEGER,            INTENT(IN) :: mill(:,:)
2329c2211
<        INTEGER  :: npwx_g, npw_g, ig, ngg
---
>        INTEGER  :: npwx_g, npw_g, ig, ngg, i, j
2333,2334c2215,2216
<        npwx_g = ngw_g
<        npw_g  = ngw_g
---
>        npwx_g = ngwt
>        npw_g  = ngwt
2351c2233
<        CALL mp_sum( itmp1, intra_bgrp_comm )
---
>        CALL mp_sum( itmp1, intra_image_comm )
2382c2264
<           CALL iotk_write_dat( iun, "GRID", mill_g(1:3, igwk(1:npw_g)), COLUMNS = 3 )
---
>           CALL iotk_write_dat( iun, "GRID", mill( 1:3, igwk( 1:npw_g ) ), COLUMNS = 3 )
Only in ../../../ffn2_tsvdw_master/CPV: cp_restart.F90
Only in ../../../ffn2_tsvdw_master/CPV: cp_restart.mod
Only in ../../../ffn2_tsvdw_master/CPV: cp_restart.o
diff ./cpr.f90 ../../../ffn2_tsvdw_master/CPV/cpr.f90
15c15
<   USE control_flags,            ONLY : iprint, isave, thdyn, tpre, iverbosity, &
---
>   USE control_flags,            ONLY : iprint, isave, thdyn, tpre, iprsta,     &
18c18
<                                        ndr, ndw, nomore, tsde, &
---
>                                        lcoarsegrained, ndr, ndw, nomore, tsde, &
22,25c22,26
<                                        textfor
<   USE core,                     ONLY : rhoc
<   USE uspp_param,               ONLY : nhm, nh, nvb, ish
<   USE uspp,                     ONLY : nkb, vkb, becsum, deeq, okvan, nlcc_any
---
>                                        tprojwfc, textfor, remove_drift  
>   USE core,                     ONLY : nlcc_any, rhoc
>   USE uspp_param,               ONLY : nhm, nh
>   USE cvan,                     ONLY : nvb, ish
>   USE uspp,                     ONLY : nkb, vkb, becsum, deeq, okvan
29c30
<   USE electrons_base,           ONLY : nbspx, nbsp, ispin, f, nspin, nbsp_bgrp
---
>   USE electrons_base,           ONLY : nbspx, nbsp, ispin, f, nspin
31d31
<   USE electrons_module,         ONLY : distribute_c, collect_c
41,43c41,43
<   USE gvect,                    ONLY : ngm
<   USE gvecs,                    ONLY : ngms
<   USE smallbox_gvec,                    ONLY : ngb
---
>   USE gvecp,                    ONLY : ngm
>   USE gvecs,                    ONLY : ngs
>   USE gvecb,                    ONLY : ngb
45,46c45,46
<   USE gvect,       ONLY : gstart, mill, eigts1, eigts2, eigts3
<   USE ions_base,                ONLY : na, nat, amass, nax, nsp, rcmax
---
>   USE reciprocal_vectors,       ONLY : gstart, mill_l
>   USE ions_base,                ONLY : na, nat, pmass, nax, nsp, rcmax
52c52
<   USE cell_base,                ONLY : at, bg, ainv, frich, &
---
>   USE cell_base,                ONLY : a1, a2, a3, b1, b2, b3, ainv, frich, &
54,55c54,59
<                                        celldm, h, hold, hnew, velh,         &
<                                        wmass, press, iforceh, cell_force
---
>                                        celldm, h, hold, hnew, velh, deth,   &
>                                        wmass, press, iforceh, cell_force,   &
>                                        thdiag
>   USE grid_dimensions,          ONLY : nnrx, nr1, nr2, nr3
>   USE smooth_grid_dimensions,   ONLY : nnrsx, nr1s, nr2s, nr3s
>   USE smallbox_grid_dimensions, ONLY : nr1b, nr2b, nr3b
57c61,62
<   USE io_global,                ONLY : stdout, ionode, ionode_id
---
>   USE io_global,                ONLY : io_global_start, &
>                                        stdout, ionode, ionode_id
59c64
<   !USE cdvan,                    ONLY : drhovan
---
>   USE cdvan,                    ONLY : dbec, drhovan
85c90
<   USE wavefunctions_module,     ONLY : c0_bgrp, cm_bgrp, phi_bgrp
---
>   USE wavefunctions_module,     ONLY : c0, cm, phi => cp
87c92,96
<   USE cp_interfaces,            ONLY : printout_new, move_electrons, newinit
---
>   USE cp_interfaces,            ONLY : printout_new, move_electrons
>   USE printout_base,            ONLY : printout_base_open, &
>                                        printout_base_close, &
>                                        printout_pos, printout_cell, &
>                                        printout_stress
93,94c102,103
<   USE gvecw,                    ONLY : ecutwfc
<   USE gvect,                    ONLY : ecutrho
---
>   USE gvecw,                    ONLY : ecutw
>   USE gvecp,                    ONLY : ecutp
96,101c105,110
<   USE cp_interfaces,            ONLY : cp_print_rho, nlfh, print_lambda, prefor, dotcsc
<   USE cp_main_variables,        ONLY : acc, lambda, lambdam, lambdap, &
<                                        ema0bg, sfac, eigr, iprint_stdout,  &
<                                        irb, taub, eigrb, rhog, rhos, &
<                                        rhor, bephi, becp_bgrp, nfi, descla, &
<                                        drhor, drhog, bec_bgrp, dbec
---
>   USE cp_interfaces,            ONLY : cp_print_rho, nlfh, print_lambda
>   USE cp_main_variables,        ONLY : acc, bec, lambda, lambdam, lambdap, &
>                                        ema0bg, sfac, eigr, ei1, ei2, ei3,  &
>                                        irb, becdr, taub, eigrb, rhog, rhos, &
>                                        rhor, bephi, becp, nfi, descla, iprint_stdout, &
>                                        drhor, drhog, nlax
108c117
<   USE cp_interfaces,            ONLY : ortho, elec_fakekine, calbec_bgrp, calbec, caldbec_bgrp
---
>   USE cp_interfaces,            ONLY : ortho, elec_fakekine, print_projwfc
109a119
>   USE metadyn_base,             ONLY : set_target, mean_force
114,118c124,129
<   USE mp,                       ONLY : mp_bcast, mp_sum
<   USE mp_global,                ONLY : root_bgrp, intra_bgrp_comm, np_ortho, me_ortho, ortho_comm, &
<                                        me_bgrp, inter_bgrp_comm, nbgrp
<   USE ldaU_cp,                  ONLY : lda_plus_u, vupsi
<   USE fft_base,                 ONLY : dfftp
---
>   USE mp,                       ONLY : mp_bcast
>   USE mp_global,                ONLY : root_image, intra_image_comm, np_ortho, me_ortho, ortho_comm, &
>                                        me_image
>   USE ldaU,                     ONLY : lda_plus_u, vupsi
>   USE step_constraint
>   USE small_box,                ONLY : ainvb
152a164
>   INTEGER ::CYCL                       
156a169,170
>   REAL(DP), ALLOCATABLE :: tauw(:,:)  
>     ! temporary array used to printout positions
160,161c174
<     ! pmass contains masses in atomic Hartree units
<   REAL(DP), ALLOCATABLE :: pmass(:)
---
>   !
163a177
>   !
166d179
<   stress   = 0.0D0
172,173d184
<   ALLOCATE ( pmass (nsp) )
<   pmass(1:nsp) = amass(1:nsp) * amu_au
189d199
<   !
198c208
<      CALL start_clock( 'main_loop' )
---
>      CALL start_clock( 'total_time' )
253c263
<         CALL initbox( tau0, alat, at, ainv, taub, irb )
---
>         CALL initbox( tau0, taub, irb, ainv, a1, a2, a3 )
255c265
<         CALL phbox( taub, iverbosity, eigrb )
---
>         CALL phbox( taub, eigrb, ainvb )
261c271
<         CALL phfacs( eigts1,eigts2,eigts3, eigr, mill, taus, dfftp%nr1,dfftp%nr2,dfftp%nr3, nat )
---
>         CALL phfacs( ei1, ei2, ei3, eigr, mill_l, taus, nr1, nr2, nr3, nat )
265c275
<         CALL strucf( sfac, eigts1, eigts2, eigts3, mill, ngms )
---
>         CALL strucf( sfac, ei1, ei2, ei3, mill_l, ngs )
279c289
<         CALL calbec( 1, nsp, eigr, c0_bgrp, bec_bgrp ) ! ATTENZIONE  
---
>         CALL calbec( 1, nsp, eigr, c0, bec ) ! ATTENZIONE  
295c305,307
<         CALL new_ns(c0_bgrp,eigr,vkb,vupsi,forceh)
---
>         ! vpsi_con  ! potentials on electrons due to occupation constraints ...not yet implemented...
>         vpsi_con=(0.0d0,0.0d0)
>         CALL new_ns(c0,eigr,vkb,vupsi,vpsi_con,forceh)
306,308c318,320
<           c0_bgrp(:,iupdwn(2):nbsp)       =     c0_bgrp(:,1:nupdwn(2))
<           cm_bgrp(:,iupdwn(2):nbsp)       =     cm_bgrp(:,1:nupdwn(2))
<          phi_bgrp(:,iupdwn(2):nbsp)       =    phi_bgrp(:,1:nupdwn(2))
---
>           c0(:,iupdwn(2):nbsp)       =     c0(:,1:nupdwn(2))
>           cm(:,iupdwn(2):nbsp)       =     cm(:,1:nupdwn(2))
>          phi(:,iupdwn(2):nbsp)       =    phi(:,1:nupdwn(2))
318c330
<         CALL elec_fakekine( ekincf, ema0bg, emass, cm_bgrp, c0_bgrp, ngw, nbsp_bgrp, 1, delt )
---
>         CALL elec_fakekine( ekincf, ema0bg, emass, cm, c0, ngw, nbsp, 1, delt )
322,323c334,335
<      CALL move_electrons( nfi, tfirst, tlast, bg(:,1), bg(:,2), bg(:,3), &
<                           fion, c0_bgrp, cm_bgrp, phi_bgrp, &
---
>      !
>      CALL move_electrons( nfi, tfirst, tlast, b1, b2, b3, fion, &
330c342
<         CALL nlfh( stress, bec_bgrp, dbec, lambda, descla )
---
>         CALL nlfh( stress, bec, dbec, lambda )
364c376,379
<      IF ( tfor ) THEN
---
> !===========================================================================
>      CYCL=0
>  444 IF ( tfor ) THEN
> !===========================================================================
374c389,395
<            FORALL( ia = 1:nat ) fion(:,ia) = fion(:,ia) - fion_tot(:)
---
> !===========================================================================
> !changed
>            IF(remove_drift) THEN
>               FORALL( ia = 1:nat ) fion(:,ia) = fion(:,ia) - fion_tot(:)
>            END IF
> !          FORALL( ia = 1:nat ) fion(:,ia) = fion(:,ia) - fion_tot(:)
> !===========================================================================
391a413,414
>               IF ( lcoarsegrained ) CALL set_target()
>               !
402c425
<            CALL mp_bcast( fion, ionode_id, intra_bgrp_comm )
---
>            CALL mp_bcast( fion, ionode_id, intra_image_comm )
406,411d428
<         !
<         ! ... call void routine for user define/ plugin patches on forces
<         !
<         CALL plugin_forces()
<         !
<         !
431a449,452
>               ! ... average value of the lagrange multipliers
>               !
>               IF ( lcoarsegrained ) CALL mean_force( nfi, etot, 1.D0 )
>               !
436,437c457,458
<            CALL mp_bcast( taup, ionode_id, intra_bgrp_comm )
<            CALL mp_bcast( fion, ionode_id, intra_bgrp_comm )
---
>            CALL mp_bcast( taup, ionode_id, intra_image_comm )
>            CALL mp_bcast( fion, ionode_id, intra_image_comm )
466c487
<            CALL newinit( h, iverbosity )
---
>            CALL newinit( h )
478c499,500
<         CALL phfacs( eigts1,eigts2,eigts3, eigr, mill, tausp, dfftp%nr1,dfftp%nr2,dfftp%nr3, nat ) 
---
>         CALL phfacs( ei1, ei2, ei3, eigr, mill_l, tausp, nr1, nr2, nr3, nat ) 
>         !
489,491c511,513
<      IF ( .NOT. tcg ) THEN
<         !
<         IF ( tortho ) THEN
---
>      !Charles Swartz
>      !IF(CYCL == 0)THEN                     
>         IF ( .NOT. tcg ) THEN
493c515,526
<            CALL ortho( eigr, cm_bgrp, phi_bgrp, lambda, descla, bigr, iter, ccc, bephi, becp_bgrp )
---
>            IF ( tortho ) THEN
>               !
>               CALL ortho( eigr, cm, phi, ngw, lambda, descla, &
>                           bigr, iter, ccc, bephi, becp, nbsp, nspin, nupdwn, iupdwn )
>               !
>            ELSE
>               !
>               CALL gram( vkb, bec, nkb, cm, ngw, nbsp )
>               !
>               IF ( iprsta > 4 ) CALL dotcsc( eigr, cm, ngw, nbsp )
>               !
>            END IF
495c528
<         ELSE
---
>            !  correction to displacement of ions
497c530
<            CALL gram_bgrp( vkb, bec_bgrp, nkb, cm_bgrp, ngw )
---
>            IF ( iprsta >= 3 ) CALL print_lambda( lambda, nbsp, 9, 1.D0 )
499c532,555
<            IF ( iverbosity > 3 ) CALL dotcsc( eigr, cm_bgrp, ngw, nbsp_bgrp )
---
>            IF ( tortho ) THEN
>               DO iss = 1, nspin_sub
>                  i1 = (iss-1)*nlax+1
>                  i2 = iss*nlax
>                  CALL updatc( ccc, nbsp, lambda(:,:,iss), SIZE(lambda,1), phi, SIZE(phi,1), &
>                            bephi(:,i1:i2), SIZE(bephi,1), becp, bec, cm, nupdwn(iss), iupdwn(iss), &
>                            descla(:,iss) )
>               END DO
>            END IF
>            !
>            IF( force_pairing ) THEN
>                  c0(:,iupdwn(2):nbsp)       =     c0(:,1:nupdwn(2))
>                  cm(:,iupdwn(2):nbsp)       =     cm(:,1:nupdwn(2))
>                 phi(:,iupdwn(2):nbsp)       =    phi(:,1:nupdwn(2))
>              lambda(:,:, 2) = lambda(:,:, 1)
>            ENDIF
>            !
>            CALL calbec( nvb+1, nsp, eigr, cm, bec )
>            !
>            IF ( tpre ) THEN
>               CALL caldbec( ngw, nkb, nbsp, 1, nsp, eigr, cm, dbec )
>            END IF
>            !
>            IF ( iprsta >= 3 ) CALL dotcsc( eigr, cm, ngw, nbsp )
502,526c558
<         !
<         !  correction to displacement of ions
<         !
<         IF ( iverbosity > 2 ) CALL print_lambda( lambda, descla, nbsp, 9, 1.D0 )
<         !
<         IF ( tortho ) THEN
<            CALL updatc( ccc, lambda, phi_bgrp, bephi, becp_bgrp, bec_bgrp, cm_bgrp, descla )
<         END IF
<         !
<         IF( force_pairing ) THEN
<               c0_bgrp(:,iupdwn(2):nbsp)       =     c0_bgrp(:,1:nupdwn(2))
<               cm_bgrp(:,iupdwn(2):nbsp)       =     cm_bgrp(:,1:nupdwn(2))
<              phi_bgrp(:,iupdwn(2):nbsp)       =    phi_bgrp(:,1:nupdwn(2))
<           lambda(:,:, 2) = lambda(:,:, 1)
<         ENDIF
<         !
<         CALL calbec_bgrp( nvb+1, nsp, eigr, cm_bgrp, bec_bgrp )
<         !
<         IF ( tpre ) THEN
<            CALL caldbec_bgrp( eigr, cm_bgrp, dbec, descla )
<         END IF
<         !
<         IF ( iverbosity > 2 ) CALL dotcsc( eigr, cm_bgrp, ngw, nbsp_bgrp )
<         !
<      END IF
---
>      !END IF                    
557c589
<         CALL elec_fakekine( ekinc0, ema0bg, emass, c0_bgrp, cm_bgrp, ngw, nbsp_bgrp, 1, delt )
---
>         CALL elec_fakekine( ekinc0, ema0bg, emass, c0, cm, ngw, nbsp, 1, delt )
595a628,632
> !=================================================================
>      CYCL=CYCL+1
>      !Charles Swartz
>      IF(tnosep .AND. ( CYCL == 1 .OR. CYCL == 2 ) ) GO TO 444
> !=================================================================
623c660
<            CALL eigs( nfi, lambdap, lambda, descla )
---
>            CALL eigs( nfi, lambdap, lambda )
689c726
<                         ekin, epot, tprnfor, tpre, tstdout )
---
>                         ekin, epot, tprnfor, tpre )
708c745
<      IF ( thdyn .AND. tfirst ) CALL emass_precond( ema0bg, ggp, ngw, tpiba2, emass_cutoff )
---
>      IF ( thdyn ) CALL emass_precond( ema0bg, ggp, ngw, tpiba2, emass_cutoff )
716c753
<         CALL dswap( 2*SIZE( c0_bgrp ), c0_bgrp, 1, cm_bgrp, 1 )
---
>         CALL dswap( 2*ngw*nbsp, c0, 1, cm, 1 )
720c757
<         CALL cg_update( tfirst, nfi, c0_bgrp )
---
>         CALL cg_update( tfirst, nfi, c0 )
729,730c766,767
<               CALL initbox( tau0, alat, at, ainv, taub, irb )
<               CALL phbox( taub, iverbosity, eigrb ) 
---
>               CALL initbox( tau0, taub, irb, ainv, a1, a2, a3 )
>               CALL phbox( taub, eigrb, ainvb )
733,734c770,771
<            CALL phfacs( eigts1,eigts2,eigts3, eigr, mill, taus, dfftp%nr1,dfftp%nr2,dfftp%nr3, nat )
<            CALL strucf( sfac, eigts1, eigts2, eigts3, mill, ngms )
---
>            CALL phfacs( ei1, ei2, ei3, eigr, mill_l, taus, nr1, nr2, nr3, nat )
>            CALL strucf( sfac, ei1, ei2, ei3, mill_l, ngs )
742,744c779,780
<            CALL move_electrons( nfi, tfirst, tlast, bg(:,1), bg(:,2), bg(:,3),&
<                                 fion, c0_bgrp, cm_bgrp, phi_bgrp, enthal, enb,&
<                                 enbi, fccc, ccc, dt2bye, stress )
---
>            CALL move_electrons( nfi, tfirst, tlast, b1, b2, b3, &
>                                 fion, enthal, enb, enbi, fccc, ccc, dt2bye, stress )
754,755d789
<      CALL stop_clock( 'main_loop' )
<      !
762,763c796,797
<           CALL writefile( h, hold ,nfi, c0_bgrp, c0old, taus, tausm,  &
<                           vels, velsm, acc, lambda, lambdam, descla, xnhe0, xnhem,     &
---
>           CALL writefile( h, hold ,nfi, c0, c0old, taus, tausm,  &
>                           vels, velsm, acc, lambda, lambdam, xnhe0, xnhem,     &
769,770c803,804
<            CALL writefile( h, hold, nfi, c0_bgrp, cm_bgrp, taus,  &
<                            tausm, vels, velsm, acc,  lambda, lambdam, descla, xnhe0,   &
---
>            CALL writefile( h, hold, nfi, c0, cm, taus,  &
>                            tausm, vels, velsm, acc,  lambda, lambdam, xnhe0,   &
786a821,822
>      CALL stop_clock( 'total_time' )
>      !
835,839c871,875
<      IF ( lwf ) &
<         CALL wf_closing_options( nfi, c0_bgrp, cm_bgrp, bec_bgrp, eigr, eigrb,&
<                                  taub, irb, ibrav, bg(:,1), bg(:,2), bg(:,3), &
<                                  taus, tausm, vels, &
<                                  velsm, acc, lambda, lambdam, descla, xnhe0, xnhem,  &
---
>      IF ( lwf ) THEN 
>         CALL start_clock( 'wf_closing' )    !Lingzhu Kong
>         CALL wf_closing_options( nfi, c0, cm, bec, eigr, eigrb, taub, &
>                                  irb, ibrav, b1, b2, b3, taus, tausm, vels,  &
>                                  velsm, acc, lambda, lambdam, xnhe0, xnhem,  &
841,842c877,880
<                                  ekincm, xnhh0, xnhhm, vnhh, velh, ecutrho,  &
<                                  ecutwfc,delt,celldm, fion, tps, z0t, f, rhor )
---
>                                  ekincm, xnhh0, xnhhm, vnhh, velh, ecutp,    &
>                                  ecutw, delt, celldm, fion, tps, z0t, f, rhor )
>         CALL stop_clock( 'wf_closing' )    !Lingzhu Kong
>      ENDIF
850d887
<   DEALLOCATE ( pmass )
877c914
<   IF ( tcg ) cm_bgrp = c0old
---
>   IF ( tcg ) cm = c0old
879,880c916,917
<   CALL writefile( h, hold, nfi, c0_bgrp, cm_bgrp, taus, tausm, &
<                   vels, velsm, acc, lambda, lambdam, descla, xnhe0, xnhem, vnhe,    &
---
>   CALL writefile( h, hold, nfi, c0, cm, taus, tausm, &
>                   vels, velsm, acc, lambda, lambdam, xnhe0, xnhem, vnhe,    &
884c921,923
<   IF( iverbosity > 2 ) CALL print_lambda( lambda, descla, nbsp, nbsp, 1.D0 )
---
>   IF( tprojwfc ) CALL print_projwfc( c0, lambda, eigr, vkb )
>   !
>   IF( iprsta > 2 ) CALL print_lambda( lambda, nbsp, nbsp, 1.D0 )
895a935
>   USE kinds,             ONLY : DP
897c937
<   USE control_flags,     ONLY : thdyn, tortho
---
>   USE cp_main_variables, ONLY : acc
899d938
<   USE ldaU_cp,           ONLY : lda_plus_u
900a940,945
>   USE mp_global,         ONLY : use_task_groups
> !==============================================================================
> !Charles Swartz
>   USE input_parameters,  ONLY : ts_vdw
>   USE tsvdw_module,      ONLY : tsvdw_finalize
> !==============================================================================
908a954
>   CALL print_clock( 'total_time' )
910,924c956
<   !
<   WRITE( stdout, '(/5x,"Called by main_loop:")' )
<   IF (thdyn) CALL print_clock( 'formf' )
<   CALL print_clock( 'move_electrons' )
<   IF (tortho) THEN
<      CALL print_clock( 'ortho' )
<      CALL print_clock( 'updatc' )
<   ELSE
<      CALL print_clock( 'gram' )
<   END IF
<   CALL print_clock( 'new_ns' )
<   CALL print_clock( 'strucf' )
<   CALL print_clock( 'calbec' )
< 
<   WRITE( stdout, '(/5x,"Called by move_electrons:")' )
---
>   CALL print_clock( 'formf' )
929,937c961
<   CALL print_clock( 'newd' )
<   CALL print_clock( 'nlfl' )
< 
<   IF (lda_plus_u) WRITE( stdout, '(/5x,"Called by new_ns:")' )
<   CALL print_clock( 'new_ns:forc' )
<   CALL print_clock( 'projwfc_hub' )
<   CALL print_clock( 'dndtau' )
< 
<   IF (tortho) WRITE( stdout, '(/5x,"Called by ortho:")' )
---
>   CALL print_clock( 'ortho' )
941,950c965,968
<   CALL print_clock( 'sigset' )
<   CALL print_clock( 'tauset' )
< 
<   WRITE( stdout, '(/5x,"Small boxes:")' )
<   CALL print_clock( 'rhov' )
<   CALL print_clock( 'fftb' )
<   CALL print_clock( 'set_cc' )
<   CALL print_clock( 'forcecc' )
< 
<   WRITE( stdout, '(/5x,"Low-level routines:")' )
---
>   CALL print_clock( 'updatc' )
>   CALL print_clock( 'gram' )
>   CALL print_clock( 'newd' )
>   CALL print_clock( 'calbec' )
951a970,971
>   CALL print_clock( 'strucf' )
>   CALL print_clock( 'nlfl' )
952a973,974
>   CALL print_clock( 'set_cc' )
>   CALL print_clock( 'rhov' )
954a977
>   CALL print_clock( 'forcecc' )
957a981,982
>   CALL print_clock( 'fftb' )
>   CALL print_clock( 'cft3s' )
959,963d983
<   CALL print_clock( 'betagx' )
<   CALL print_clock( 'qradx' )
<   CALL print_clock( 'tmp_clk1' )
<   CALL print_clock( 'tmp_clk2' )
<   CALL print_clock( 'tmp_clk3' )
965d984
< ! Lingzhu Kong
969c988
<   CALL print_clock('rhoiofr')
---
>   CALL print_clock(' rhoiofr ')
985a1005
>   CALL print_clock('wf_closing')
987a1008,1023
> !==============================================================================
> !Charles Swartz
>   IF (ts_vdw .EQV. .TRUE.) THEN
>     WRITE( stdout, '(/5x,"Called by tsvdw:")' )
>     CALL print_clock( 'ts_vdw' )
>     CALL print_clock( 'tsvdw_rhosad' )
>     CALL print_clock( 'tsvdw_veff' )
>     CALL print_clock( 'tsvdw_energy' )
>     CALL print_clock( 'tsvdw_wfforces' )
>     CALL print_clock( 'tsvdw_dveff' )
>     CALL print_clock( 'tsvdw_ionforces' )
>     CALL print_clock( 'tsvdw_pressure' )
>     CALL tsvdw_finalize()
>   END IF
> !==============================================================================
>   !
990c1026,1030
<   CALL print_clock( 'ALLTOALL' )
---
>   IF( use_task_groups ) THEN
>      !
>      CALL print_clock( 'ALLTOALL' )
>      !
>   END IF
Only in ../../../ffn2_tsvdw_master/CPV: cpr.F90
Only in .: cpr_loop.f90
Only in ../../../ffn2_tsvdw_master/CPV: cpr_mod.F90
Only in ../../../ffn2_tsvdw_master/CPV: cpr_mod.o
Only in ../../../ffn2_tsvdw_master/CPV: cpr.o
diff ./cprstart.f90 ../../../ffn2_tsvdw_master/CPV/cprstart.f90
21,25c21,23
<   USE input,         ONLY : iosys_pseudo, iosys
<   USE read_input,    ONLY : read_input_file
<   USE mp_global,     ONLY : mp_startup, nimage, me_image, root_image
<   USE io_global,     ONLY : ionode, ionode_id, io_global_start
<   USE control_flags, ONLY : lneb, lsmd
---
>   USE input,         ONLY : read_input_file, iosys_pseudo, iosys
>   USE mp_global,     ONLY : mp_startup
>   USE control_flags, ONLY : lneb, lsmd, program_name
28d25
<   USE mp_global,     ONLY : mp_bcast, intra_image_comm
33a31,32
>   program_name = 'CP'
>   !
40c39
<   CALL environment_start( 'CP' )
---
>   CALL environment_start( program_name )
44,48c43,44
<   if ( nimage > 1) CALL io_global_start( me_image, root_image )
<   !
<   ! reading plugin arguments
<   IF(ionode) CALL plugin_arguments()
<   CALL plugin_arguments_bcast(ionode_id,intra_image_comm)
---
>   ! KNK_nimage
>   ! if (nimage.gt.1) CALL io_global_start( me_image, root_image )
52c48
<   CALL read_input_file( 'CP' )
---
>   CALL read_input_file()
63,67d58
<   ! call to void routine for user define / plugin patches initializations
<   ! temporary moved to init_run
< !  CALL plugin_initialization()
<   !
<   !
72c63
<      CALL errore ( 'cpr_main', 'NEB no longer implemented, use "neb.x" instead', 1)
---
>      CALL neb_loop( )
Only in ../../../ffn2_tsvdw_master/CPV: cprstart.F90
Only in ../../../ffn2_tsvdw_master/CPV: cprstart.o
Only in ../../../ffn2_tsvdw_master/CPV: cprsub.f90
Only in ../../../ffn2_tsvdw_master/CPV: cprsub.F90
Only in ../../../ffn2_tsvdw_master/CPV: cprsub.o
Only in ../../../ffn2_tsvdw_master/CPV: cp.x
Only in ../../../ffn2_tsvdw_master/CPV: cvan.mod
diff ./dealloc.f90 ../../../ffn2_tsvdw_master/CPV/dealloc.f90
13c13,14
<   USE uspp,       ONLY : beta, dbeta, qq
---
>   USE uspp,       ONLY : beta, qq
>   USE qgb_mod,    ONLY : qgb
14a16,17
>   USE cdvan,      ONLY : dbeta
>   USE dqgb_mod,   ONLY : dqgb
16a20
>   USE cvan,                 ONLY : deallocate_cvan
22,26c26,27
<   USE gvect,                ONLY : deallocate_gvect
<   USE gvect,                ONLY : deallocate_gvect
<   USE gvecs,                ONLY : deallocate_gvecs
<   USE gvecw,                ONLY : deallocate_gvecw
<   USE smallbox_gvec,        ONLY : deallocate_smallbox_gvec
---
>   USE reciprocal_vectors,   ONLY : deallocate_recvecs
>   USE recvecs_indexes,      ONLY : deallocate_recvecs_indexes
28a30
>   USE dqgb_mod,             ONLY : deallocate_dqgb_mod
40a43
>   USE cdvan,                ONLY : deallocate_cdvan
46,48c49
<   USE ldaU_cp,              ONLY : deallocate_lda_plus_u
<   USE step_penalty,         ONLY : deallocate_step_pen
< 
---
>   USE ldau,                 ONLY : deallocate_lda_plus_u
53a55
>   IF ( ALLOCATED( qgb ) )      DEALLOCATE( qgb )
55a58
>   IF ( ALLOCATED( dqgb ) )     DEALLOCATE( dqgb )
59a63
>   CALL deallocate_cvan()
65,68c69,70
<   CALL deallocate_gvect()
<   CALL deallocate_gvecs()
<   CALL deallocate_gvecw()
<   CALL deallocate_smallbox_gvec( )
---
>   CALL deallocate_recvecs()
>   CALL deallocate_recvecs_indexes()
70a73,74
>   CALL deallocate_dqgb_mod()
>   CALL deallocate_cdvan()
94d97
<   CALL deallocate_step_pen()
Only in ../../../ffn2_tsvdw_master/CPV: dealloc.F90
Only in ../../../ffn2_tsvdw_master/CPV: dealloc.o
Only in ../../../ffn2_tsvdw_master/CPV: dener.mod
diff ./dforceb.f90 ../../../ffn2_tsvdw_master/CPV/dforceb.f90
36a37
>   use  cvan
38,39c39,40
<   use cell_base, only: at, alat
<   use uspp_param, only: nh, nhm, nvb, ish
---
>   use cell_base, only: a1, a2, a3
>   use uspp_param, only: nh, nhm
43c44
<   use mp_global, only: intra_bgrp_comm, nproc_bgrp
---
>   use mp_global, only: intra_image_comm, nproc_image
54,55c55,56
<   real(DP) bec0(nhsa,n), dq2(nat,nhm,nhm,nspin),  gmes
<   real(DP), EXTERNAL :: g_mes
---
>   real(DP) bec0(nhsa,n),&
>        &   dq2(nat,nhm,nhm,nspin),  gmes
103c104
< #ifdef __MPI
---
> #ifdef __PARA
107c108
<              allocate(sndbuf(n_g_missing_m(ipol),2,nproc_bgrp))
---
>              allocate(sndbuf(n_g_missing_m(ipol),2,nproc_image))
109c110
<              allocate(rcvbuf(n_g_missing_m(ipol),2,nproc_bgrp))
---
>              allocate(rcvbuf(n_g_missing_m(ipol),2,nproc_image))
111c112
<              do ip=1,nproc_bgrp
---
>              do ip=1,nproc_image
145c146
<              CALL mp_alltoall( sndbuf, rcvbuf, intra_bgrp_comm )           
---
>              CALL mp_alltoall( sndbuf, rcvbuf, intra_image_comm )           
148c149
<              do ip=1,nproc_bgrp
---
>              do ip=1,nproc_image
181c182,193
<   gmes = g_mes ( ipol, at, alat ) 
---
>   if(ipol.eq.1) then
>      gmes=a1(1)**2+a1(2)**2+a1(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.2) then
>      gmes=a2(1)**2+a2(2)**2+a2(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.3) then
>      gmes=a3(1)**2+a3(2)**2+a3(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
238c250
< function enberry( detq,  ipol )
---
>  subroutine enberry( detq,  ipol, enb)
241,242c253,254
<    use kinds, only: dp
<    use cell_base, only: alat, at
---
>    use parameters
>    use cell_base, only: a1, a2, a3
247,249c259,260
<    complex(dp), intent (in) :: detq
<    real(dp) :: enberry
<  
---
>    complex(8) detq
>    real(8) enb
251,252c262,276
<    real(dp) gmes
<    real(dp), external :: g_mes
---
>    real(8) gmes
> 
>      
>    if(ipol.eq.1) then
>       gmes=a1(1)**2+a1(2)**2+a1(3)**2
>       gmes=2*pi/SQRT(gmes)
>    endif
>    if(ipol.eq.2) then
>       gmes=a2(1)**2+a2(2)**2+a2(3)**2
>       gmes=2*pi/SQRT(gmes)
>    endif
>    if(ipol.eq.3) then
>       gmes=a3(1)**2+a3(2)**2+a3(3)**2
>       gmes=2*pi/SQRT(gmes)
>    endif
254,255c278
<    gmes = g_mes ( ipol, at, alat )
<    enberry = 2.d0/REAL(nspin,DP)*AIMAG(log(detq))/gmes ! take care of sign
---
>    enb = 2.d0/REAL(nspin,DP)*AIMAG(log(detq))/gmes ! take care of sign
258c281
<  end function enberry
---
>  end subroutine enberry
261,267d283
< !
< ! Copyright (C) 2011 Quantum ESPRESSO group
< ! This file is distributed under the terms of the
< ! GNU General Public License. See the file `License'
< ! in the root directory of the present distribution,
< ! or http://www.gnu.org/copyleft/gpl.txt .
< !
269,283d284
< FUNCTION g_mes ( ipol, at, alat )
< 
<   USE kinds, ONLY : dp
<   USE constants, ONLY : pi
< 
<   IMPLICIT NONE
< 
<   INTEGER, INTENT(IN) :: ipol
<   REAL(dp), INTENT(IN) :: at(3,3), alat
<   REAL(dp) :: g_mes
< 
<   IF ( ipol < 1 .OR. ipol > 3) CALL errore ( 'gmes','incorrect ipol', 1)
<   g_mes = 2.0_dp*pi/alat/SQRT(at(1,ipol)**2+at(2,ipol)**2+at(3,ipol)**2)
<   
< END FUNCTION g_mes
Only in ../../../ffn2_tsvdw_master/CPV: dforceb.F90
Only in ../../../ffn2_tsvdw_master/CPV: dforceb.o
Only in ../../../ffn2_tsvdw_master/CPV: dqgb_mod.mod
Only in ../../../ffn2_tsvdw_master/CPV: efcalc.mod
diff ./efermi.f90 ../../../ffn2_tsvdw_master/CPV/efermi.f90
170c170
<   REAL(kind=DP), EXTERNAL :: qe_erfc,FERMID,DELTHM,POSHM,POSHM2, EFERMI_SPLINE
---
>   REAL(kind=DP), EXTERNAL :: qe_erfc,FERMID,DELTHM,POSHM,POSHM2, SPLINE
396c396
<            Z1 = Z1 + WEIGHT(ISPPT)*EFERMI_SPLINE(-X)/fspin
---
>            Z1 = Z1 + WEIGHT(ISPPT)*SPLINE(-X)/fspin
422c422
<            Z1 = Z1 + WEIGHT(ISPPT)*EFERMI_SPLINE(-X)/fspin
---
>            Z1 = Z1 + WEIGHT(ISPPT)*SPLINE(-X)/fspin
463c463
<               Z1 = Z1 + WEIGHT(ISPPT)*EFERMI_SPLINE(-X)/fspin
---
>               Z1 = Z1 + WEIGHT(ISPPT)*SPLINE(-X)/fspin
497c497
<            OCC(J,ISPPT) = EFERMI_SPLINE(-X)
---
>            OCC(J,ISPPT) = SPLINE(-X)
648c648
< FUNCTION efermi_spline(x)
---
> FUNCTION spline(x)
654c654
<   REAL(kind=DP) :: efermi_spline
---
>   REAL(kind=DP) :: spline
666c666
<   efermi_spline=2.d0*fx
---
>   spline=2.d0*fx
669c669
< END FUNCTION efermi_spline
---
> END FUNCTION spline
Only in ../../../ffn2_tsvdw_master/CPV: efermi.F90
Only in ../../../ffn2_tsvdw_master/CPV: efermi.o
diff ./efield.f90 ../../../ffn2_tsvdw_master/CPV/efield.f90
99c99
<     if(ionode) write(stdout,'("Initialize Berry phase electric field")')
---
>     if(ionode) write(stdout,'(''Initialize Berry phase electric field'')')
104c104
< #ifdef __MPI
---
> #ifdef __PARA
131c131
<   SUBROUTINE allocate_efield( ngw, ngw_g, nx, nhx, nas, nsp )
---
>   SUBROUTINE allocate_efield( ngw, ngwt,nx, nhx, nas, nsp )
133c133
<     INTEGER, INTENT(IN) :: ngw, ngw_g, nx, nhx, nas, nsp
---
>     INTEGER, INTENT(IN) :: ngw, ngwt, nx, nhx, nas, nsp
142c142
<       allocate( whose_is_g(ngw_g))
---
>       allocate( whose_is_g(ngwt))
179,180d178
<     real(dp), external :: enberry
< 
182c180
<     enb =  enberry( detq, ipolp )
---
>     call enberry( detq, ipolp,enb)
240c238
<     if(ionode) write(stdout,'("Initialize Berry phase electric field")')
---
>     if(ionode) write(stdout,'(''Initialize Berry phase electric field'')')
298,299d295
<     real(dp), external :: enberry
< 
301c297
<     enb =  enberry( detq2, ipolp2 )
---
>     call enberry( detq2, ipolp2,enb)
Only in ../../../ffn2_tsvdw_master/CPV: efield.F90
Only in ../../../ffn2_tsvdw_master/CPV: efield_module.mod
Only in ../../../ffn2_tsvdw_master/CPV: efield.o
diff ./eigs0.f90 ../../../ffn2_tsvdw_master/CPV/eigs0.f90
9c9
<    subroutine eigs0( ei, nudx, tprint, nspin, nupdwn, iupdwn, lf, f, nx, lambda, nlam, desc )
---
>    subroutine eigs0( ei, tprint, nspin, nupdwn, iupdwn, lf, f, nx, lambda, nudx, desc )
20c20,23
<       USE descriptors,       ONLY : la_descriptor
---
>       USE cp_main_variables, only : nlax, nlam, la_proc
>       USE descriptors,       ONLY : nlar_ , nlac_ , ilar_ , ilac_ , lambda_node_ , la_me_ , la_n_ , &
>                                     descla_siz_ , la_npr_ , la_npc_ , la_nrl_ , la_nrlx_ , la_comm_ , &
>                                     nlax_ , la_myc_ , la_myr_
22c25
<       USE mp_global,         only : intra_bgrp_comm, root_bgrp, me_bgrp
---
>       USE mp_global,         only : intra_image_comm, root_image, me_image
27,28c30,31
<       integer, intent(in) :: nspin, nx, nudx, nupdwn(nspin), iupdwn(nspin), nlam
<       type(la_descriptor), intent(in) :: desc( 2 )
---
>       integer, intent(in) :: nspin, nx, nudx, nupdwn(nspin), iupdwn(nspin)
>       integer, intent(in) :: desc( descla_siz_ , 2 )
65c68
<          IF( desc( iss )%active_node > 0 ) THEN
---
>          IF( la_proc ) THEN
67c70
<             np = desc( iss )%npc * desc( iss )%npr
---
>             np = desc( la_npc_ , iss ) * desc( la_npr_ , iss )
73c76
<                CALL qe_pdsyevd( .false., n, desc(iss), lambda(1,1,iss), nlam, wr )
---
>                CALL qe_pdsyevd( .false., n, desc(1,iss), lambda(1,1,iss), SIZE(lambda,1), wr )
97c100
<          call mp_bcast( wr, root_bgrp, intra_bgrp_comm )
---
>          call mp_bcast( wr, root_image, intra_image_comm )
119,122c122,125
<             if( desc( iss )%active_node > 0 ) then
<                IF( desc( iss )%myc == desc( iss )%myr ) THEN
<                   ir = desc( iss )%ir
<                   nr = desc( iss )%nr
---
>             if( la_proc ) then
>                IF( desc( la_myc_ , iss ) == desc( la_myr_ , iss ) ) THEN
>                   ir = desc( ilar_ , iss )
>                   nr = desc( nlar_ , iss )
128c131
<             call mp_sum( ei( nupdwn(1), 1 ), intra_bgrp_comm )
---
>             call mp_sum( ei( nupdwn(1), 1 ), intra_image_comm )
170c173
<       USE mp_global, ONLY: me_bgrp, nproc_bgrp, intra_bgrp_comm
---
>       USE mp_global, ONLY: me_image, nproc_image, intra_image_comm
181c184
<             IF( me_bgrp < n ) THEN
---
>             IF( me_image < n ) THEN
183c186
<                 j = me_bgrp + 1
---
>                 j = me_image + 1
190c193
<                   j = j + nproc_bgrp
---
>                   j = j + nproc_image
194c197
<             CALL mp_sum(aux, intra_bgrp_comm)
---
>             CALL mp_sum(aux, intra_image_comm)
196c199
<             IF( me_bgrp < n ) THEN
---
>             IF( me_image < n ) THEN
198c201
<                 j = me_bgrp + 1
---
>                 j = me_image + 1
201c204
<                   j = j + nproc_bgrp
---
>                   j = j + nproc_image
319c322
<    SUBROUTINE cp_eigs_x( nfi, lambdap, lambda, descla )
---
>    SUBROUTINE cp_eigs_x( nfi, lambdap, lambda )
324c327
<       use electrons_base,    only: nbspx, f, nspin
---
>       use electrons_base,    only: nx => nbspx, f, nspin
328c331
<       USE descriptors,       ONLY: la_descriptor
---
>       USE cp_main_variables, only: descla
334d336
<       TYPE(la_descriptor), INTENT(IN) :: descla( : )
337c339
<          call eigs0( ei, nudx, .false. , nspin, nupdwn, iupdwn, .true. , f, nbspx, lambda, SIZE(lambda,1), descla )
---
>          call eigs0( ei, .false. , nspin, nupdwn, iupdwn, .true. , f, nx, lambda, nudx, descla )
339c341
<          call eigs0( ei, nudx, .false. , nspin, nupdwn, iupdwn, .false. , f, nbspx, lambdap, SIZE(lambdap,1), descla )
---
>          call eigs0( ei, .false. , nspin, nupdwn, iupdwn, .false. , f, nx, lambdap, nudx, descla )
Only in ../../../ffn2_tsvdw_master/CPV: eigs0.F90
Only in ../../../ffn2_tsvdw_master/CPV: eigs0.o
Only in ../../../ffn2_tsvdw_master/CPV: electric_field_module.mod
diff ./electrons.f90 ../../../ffn2_tsvdw_master/CPV/electrons.f90
15,17c15
<                                       nudx, nupdwn_bgrp, iupdwn_bgrp, nudx_bgrp, &
<                                       nbsp_bgrp, nbspx_bgrp, i2gupdwn_bgrp
< 
---
>                                       nudx
48,49c46,47
<         PUBLIC :: distribute_c, collect_c
<         PUBLIC :: distribute_b, collect_b
---
>  
> 
85,154d82
<     SUBROUTINE distribute_b( b, b_bgrp )
<       REAL(DP), INTENT(IN) :: b(:,:)
<       REAL(DP), INTENT(OUT) :: b_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2
<       DO iss = 1, nspin
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          b_bgrp(:,n1:n2) = b(:,m1:m2)
<       END DO
<       RETURN
<     END SUBROUTINE distribute_b
< !
<     SUBROUTINE collect_b( b, b_bgrp )
<       USE mp_global, ONLY : inter_bgrp_comm, mpime
<       USE mp,        ONLY : mp_sum
<       REAL(DP), INTENT(OUT) :: b(:,:)
<       REAL(DP), INTENT(IN)  :: b_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2
<       b = 0.0d0
<       DO iss = 1, nspin
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          b(:,m1:m2) = b_bgrp(:,n1:n2)
<          !write(1000+mpime,*) 'n1, n2 = ', n1, n2 ! debug
<          !write(1000+mpime,*) 'm1, m2 = ', m1, m2 ! debug
<       END DO
<       CALL mp_sum( b, inter_bgrp_comm )
<       RETURN
<     END SUBROUTINE collect_b
< 
< 
<     SUBROUTINE distribute_c( c, c_bgrp )
<       COMPLEX(DP), INTENT(IN) :: c(:,:)
<       COMPLEX(DP), INTENT(OUT) :: c_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2
<       DO iss = 1, nspin
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          c_bgrp(:,n1:n2) = c(:,m1:m2)
<       END DO
<       RETURN
<     END SUBROUTINE distribute_c
< !
<     SUBROUTINE collect_c( c, c_bgrp )
<       USE mp_global, ONLY : inter_bgrp_comm, mpime
<       USE mp,        ONLY : mp_sum
<       COMPLEX(DP), INTENT(OUT) :: c(:,:)
<       COMPLEX(DP), INTENT(IN)  :: c_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2
<       c = 0.0d0
<       DO iss = 1, nspin
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          c(:,m1:m2) = c_bgrp(:,n1:n2)
<          !write(1000+mpime,*) 'n1, n2 = ', n1, n2 ! debug
<          !write(1000+mpime,*) 'm1, m2 = ', m1, m2 ! debug
<       END DO
<       CALL mp_sum( c, inter_bgrp_comm )
<       RETURN
<     END SUBROUTINE collect_c
< 
< !  ----------------------------------------------
163c91
<      USE mp_global, ONLY: me_bgrp, nproc_bgrp
---
>      USE mp_global, ONLY: me_image, nproc_image
177,178c105,106
<        nb_l( i ) = nupdwn( i ) / nproc_bgrp
<        IF( me_bgrp < MOD( nupdwn( i ), nproc_bgrp ) ) nb_l( i ) = nb_l( i ) + 1
---
>        nb_l( i ) = nupdwn( i ) / nproc_image
>        IF( me_image < MOD( nupdwn( i ), nproc_image ) ) nb_l( i ) = nb_l( i ) + 1
195,197c123,125
<        ib_local( i ) = ( i - 1 ) / nproc_bgrp        !  local index of the i-th band 
<        ib_owner( i ) = MOD( ( i - 1 ), nproc_bgrp )  !  owner of th i-th band
<        IF( me_bgrp <= ib_owner( i ) ) THEN
---
>        ib_local( i ) = ( i - 1 ) / nproc_image        !  local index of the i-th band 
>        ib_owner( i ) = MOD( ( i - 1 ), nproc_image )  !  owner of th i-th band
>        IF( me_image <= ib_owner( i ) ) THEN
Only in ../../../ffn2_tsvdw_master/CPV: electrons.F90
Only in ../../../ffn2_tsvdw_master/CPV: electrons_module.mod
Only in .: electrons_nose.f90
Only in ../../../ffn2_tsvdw_master/CPV: electrons.o
Only in .: energies.f90
diff ./ensemble_dft.f90 ../../../ffn2_tsvdw_master/CPV/ensemble_dft.f90
109c109,110
<     USE descriptors
---
>     USE descriptors,       ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                  la_comm_ ,  la_me_ , la_nrl_
112c113
<     TYPE(la_descriptor), INTENT(IN) :: descla( nspin )
---
>     INTEGER, INTENT(IN) :: descla( descla_siz_ , nspin )
117,119c118,120
<        np = descla( is )%npc * descla( is )%npr
<        me = descla( is )%mype
<        IF( descla( is )%active_node > 0 ) THEN
---
>        np = descla( la_npc_ , is ) * descla( la_npr_ , is )
>        me = descla( la_me_ , is )
>        IF( descla( lambda_node_ , is ) > 0 ) THEN
121c122
<           DO i = 1, descla( is )%nrl
---
>           DO i = 1, descla( la_nrl_ , is )
133c134
<     USE descriptors
---
>     USE descriptors, ONLY: lambda_node_ , nlar_ , la_myr_ , la_myc_
136c137
<     TYPE(la_descriptor), INTENT(IN) :: descla( nspin )
---
>     INTEGER, INTENT(IN) :: descla(:,:)
140c141
<          IF( descla( is )%active_node > 0 ) THEN
---
>          IF( descla( lambda_node_ , is ) > 0 ) THEN
142c143
<             nr = descla( is )%nr
---
>             nr = descla( nlar_ , is )
144c145
< !            IF( descla( is )%la_myr == descla( is )%la_myc ) THEN
---
> !            IF( descla( la_myr_ , is ) == descla( la_myc_ , is ) ) THEN
255c256
<   SUBROUTINE allocate_ensemble_dft( nhsa, n, ngw, nudx, nspin, nx, nrxxs, nat, nrcx, nrlx )
---
>   SUBROUTINE allocate_ensemble_dft( nhsa, n, ngw, nudx, nspin, nx, nnrsx, nat, nlax, nrlx )
257c258
<     INTEGER, INTENT(IN) :: nhsa, n, ngw, nudx, nspin, nx, nrxxs, nat, nrcx, nrlx
---
>     INTEGER, INTENT(IN) :: nhsa, n, ngw, nudx, nspin, nx, nnrsx, nat, nlax, nrlx
263c264
<       allocate(psihpsi(nrcx,nrcx,nspin))
---
>       allocate(psihpsi(nlax,nlax,nspin))
Only in ../../../ffn2_tsvdw_master/CPV: ensemble_dft.F90
Only in ../../../ffn2_tsvdw_master/CPV: ensemble_dft.mod
Only in ../../../ffn2_tsvdw_master/CPV: ensemble_dft.o
Only in ../../../ffn2_tsvdw_master/CPV: entropy.F90
Only in ../../../ffn2_tsvdw_master/CPV: entropy.o
diff ./exch_corr.f90 ../../../ffn2_tsvdw_master/CPV/exch_corr.f90
18,20c18,20
<       use gvect,           only : ngm
<       use gvecs,           only : ngms
<       use fft_base,        only : dfftp
---
>       use gvecp,           only : ng => ngm
>       use gvecs,           only : ngs
>       use grid_dimensions, only : nr1, nr2, nr3, nnr => nnrx
23,25c23,24
<       use control_flags,   only : tpre, iverbosity
<       use core,            only : drhocg
<       use uspp,            only : nlcc_any
---
>       use control_flags,   only : tpre, iprsta
>       use core,            only : drhocg, nlcc_any
29c28
<       USE mp_global,       ONLY : intra_bgrp_comm
---
>       USE mp_global,       ONLY : intra_image_comm
33c32
<       USE cp_interfaces,   ONLY : fillgrad, denlcc
---
>       USE cp_interfaces,   ONLY : fillgrad
45,46c44,45
<       complex(DP) :: rhog( ngm, nspin )
<       complex(DP) :: sfac( ngms, nsp )
---
>       complex(DP) :: rhog( ng, nspin )
>       complex(DP) :: sfac( ngs, nsp )
51c50
<       real(DP) :: rhor( dfftp%nnr, nspin ), rhoc( dfftp%nnr )
---
>       real(DP) :: rhor( nnr, nspin ), rhoc( nnr )
72c71
<          allocate( gradr( dfftp%nnr, 3, nspin ) )
---
>          allocate( gradr( nnr, 3, nspin ) )
92,94c91,93
<          ALLOCATE( self_rho( dfftp%nnr, nspin ) )
<          ALLOCATE( self_rhog(ngm, nspin ) )
<          IF( dft_is_gradient() ) ALLOCATE( self_gradr( dfftp%nnr, 3, nspin ) )
---
>          ALLOCATE( self_rho( nnr, nspin ) )
>          ALLOCATE( self_rhog( ng, nspin ) )
>          IF( dft_is_gradient() ) ALLOCATE( self_gradr( nnr, 3, nspin ) )
113c112
<          call tpssmeta( dfftp%nnr, nspin, gradr, rhor, kedtaur, exc )
---
>          call tpssmeta( nnr, nspin, gradr, rhor, kedtaur, exc )
117c116
<          CALL exch_corr_cp(dfftp%nnr, nspin, gradr, rhor, exc)
---
>          CALL exch_corr_cp(nnr, nspin, gradr, rhor, exc)
120c119
<             CALL exch_corr_cp(dfftp%nnr, nspin, self_gradr, self_rho, self_exc)
---
>             CALL exch_corr_cp(nnr, nspin, self_gradr, self_rho, self_exc)
127,128c126,127
<       call mp_sum( exc, intra_bgrp_comm )
<       IF ( ttsic ) call mp_sum( self_exc, intra_bgrp_comm )
---
>       call mp_sum( exc, intra_image_comm )
>       IF ( ttsic ) call mp_sum( self_exc, intra_image_comm )
130,131c129,130
<       exc = exc * omega / DBLE( dfftp%nr1 * dfftp%nr2 * dfftp%nr3 )
<       IF ( ttsic ) self_exc = self_exc * omega/DBLE(dfftp%nr1 * dfftp%nr2 *dfftp%nr3 )
---
>       exc = exc * omega / DBLE( nr1 * nr2 * nr3 )
>       IF ( ttsic ) self_exc = self_exc * omega/DBLE(nr1 * nr2 *nr3 )
146c145
<                   do ir=1,dfftp%nnr
---
>                   do ir=1,nnr
153c152
<          dxc = dxc * omega / DBLE( dfftp%nr1*dfftp%nr2*dfftp%nr3 )
---
>          dxc = dxc * omega / DBLE( nr1*nr2*nr3 )
155c154
<          call mp_sum ( dxc, intra_bgrp_comm )
---
>          call mp_sum ( dxc, intra_image_comm )
168c167
<          IF( iverbosity > 2 ) THEN
---
>          IF( iprsta > 2 ) THEN
190c189
<             call mp_sum ( dexc, intra_bgrp_comm )
---
>             call mp_sum ( dexc, intra_image_comm )
224c223
<          IF( nlcc_any ) CALL  denlcc( dfftp%nnr, nspin, rhor, sfac, drhocg, dcc )
---
>          IF( nlcc_any ) CALL  denlcc( nnr, nspin, rhor, sfac, drhocg, dcc )
238c237
<                      do ir=1,dfftp%nnr
---
>                      do ir=1,nnr
243c242
<                call mp_sum ( drc, intra_bgrp_comm )
---
>                call mp_sum ( drc, intra_image_comm )
245c244
<             dxc = dxc - drc * ( 1.0d0 / nspin ) * omega / ( dfftp%nr1*dfftp%nr2*dfftp%nr3 )
---
>             dxc = dxc - drc * ( 1.0d0 / nspin ) * omega / ( nr1*nr2*nr3 )
271,272c270,273
<       use gvect, only: g
<       use gvect, only: ngm, nl, nlm
---
>       use reciprocal_vectors, only: gx
>       use recvecs_indexes, only: np, nm
>       use gvecp, only: ng => ngm
>       use grid_dimensions, only: nr1, nr2, nr3, nnr => nnrx, nr1x, nr2x, nr3x
275,276c276,277
<       USE fft_interfaces, ONLY: fwfft, invfft
<       USE fft_base,       ONLY: dfftp
---
>       USE cp_interfaces, ONLY: fwfft, invfft
>       USE fft_base,      ONLY: dfftp
281,282c282,283
<       real(DP)    :: gradr( dfftp%nnr, 3, nspin ), rhor( dfftp%nnr, nspin ), dexc( 3, 3 )
<       complex(DP) :: rhog( ngm, nspin )
---
>       real(DP)    :: gradr( nnr, 3, nspin ), rhor( nnr, nspin ), dexc( 3, 3 )
>       complex(DP) :: rhog( ng, nspin )
289,291c290,292
<       allocate(v(dfftp%nnr))
<       allocate(x(ngm))
<       allocate(vtemp(ngm))
---
>       allocate(v(nnr))
>       allocate(x(ng))
>       allocate(vtemp(ng))
301c302
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
305,306c306,307
<          do ig=1,ngm
<             x(ig)=ci*tpiba*g(1,ig)*v(nl(ig))
---
>          do ig=1,ng
>             x(ig)=ci*tpiba*gx(1,ig)*v(np(ig))
312,315c313,316
<                   do ig=1,ngm
<                      vtemp(ig) = omega*ci*CONJG(v(nl(ig)))*             &
<      &                    tpiba*(-rhog(ig,iss)*g(i,ig)*ainv(j,1)+      &
<      &                    g(1,ig)*drhog(ig,iss,i,j))
---
>                   do ig=1,ng
>                      vtemp(ig) = omega*ci*CONJG(v(np(ig)))*             &
>      &                    tpiba*(-rhog(ig,iss)*gx(i,ig)*ainv(j,1)+      &
>      &                    gx(1,ig)*drhog(ig,iss,i,j))
322c323
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
327,329c328,330
<          do ig=1,ngm
<             fp=v(nl(ig))+v(nlm(ig))
<             fm=v(nl(ig))-v(nlm(ig))
---
>          do ig=1,ng
>             fp=v(np(ig))+v(nm(ig))
>             fm=v(np(ig))-v(nm(ig))
331c332
<      &           ci*tpiba*g(2,ig)*0.5d0*CMPLX( DBLE(fp),AIMAG(fm),kind=DP)
---
>      &           ci*tpiba*gx(2,ig)*0.5d0*CMPLX( DBLE(fp),AIMAG(fm),kind=DP)
333c334
<      &           ci*tpiba*g(3,ig)*0.5d0*CMPLX(AIMAG(fp),-DBLE(fm),kind=DP)
---
>      &           ci*tpiba*gx(3,ig)*0.5d0*CMPLX(AIMAG(fp),-DBLE(fm),kind=DP)
339,341c340,342
<                   do ig=1,ngm
<                      fp=v(nl(ig))+v(nlm(ig))
<                      fm=v(nl(ig))-v(nlm(ig))
---
>                   do ig=1,ng
>                      fp=v(np(ig))+v(nm(ig))
>                      fm=v(np(ig))-v(nm(ig))
344,345c345,346
<      &                    tpiba*(-rhog(ig,iss)*g(i,ig)*ainv(j,2)+      &
<      &                    g(2,ig)*drhog(ig,iss,i,j))+                  &
---
>      &                    tpiba*(-rhog(ig,iss)*gx(i,ig)*ainv(j,2)+      &
>      &                    gx(2,ig)*drhog(ig,iss,i,j))+                  &
347,348c348,349
<      &                    (-rhog(ig,iss)*g(i,ig)*ainv(j,3)+            &
<      &                    g(3,ig)*drhog(ig,iss,i,j)))
---
>      &                    (-rhog(ig,iss)*gx(i,ig)*ainv(j,3)+            &
>      &                    gx(3,ig)*drhog(ig,iss,i,j)))
357c358
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnr
360,362c361,363
<          do ig=1,ngm
<             v(nl(ig))=x(ig)
<             v(nlm(ig))=CONJG(x(ig))
---
>          do ig=1,ng
>             v(np(ig))=x(ig)
>             v(nm(ig))=CONJG(x(ig))
365c366
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
609a611
> !$omp parallel default(shared), private(ipol,k,grup,grdw)
614d615
< !$omp parallel default(none), shared(nnr,grhor,h), private(ipol,k)
622d622
< !$omp end parallel
627d626
< !$omp parallel default(none), shared(nnr,grhor,h), private(ipol,k,grup,grdw)
638d636
< !$omp end parallel
640a639
> !$omp end parallel
Only in ../../../ffn2_tsvdw_master/CPV: exch_corr.F90
Only in ../../../ffn2_tsvdw_master/CPV: exch_corr.o
diff ./exx_cg.f90 ../../../ffn2_tsvdw_master/CPV/exx_cg.f90
3a4,5
> ! Modified from the corresponding subroutine in PARSEC, see http://parsec.ices.utexas.edu/
> ! Lingzhu Kong
12a15
>       USE smooth_grid_dimensions,  ONLY  :  nx=>nr1s, ny=>nr2s, nz=>nr3s
55,57c58,60
<          if (ipar(1).eq.0) then
<             print *, 'Iterative sovler has satisfied convergence test.'
<          else if (ipar(1).eq.-1) then
---
>        !  if (ipar(1).eq.0) then
>        !     print *, 'Iterative sovler has satisfied convergence test.'
>          if (ipar(1).eq.-1) then
66,67c69,70
<          else
<             print *, 'Iterative potver terminated. code =', ipar(1)
---
>       !   else
>       !      print *, 'Iterative potver terminated. code =', ipar(1)
70c73
< !     write (iou, *) ipar(7), DBLE(fpar(6))
---
> !     from_scratchwrite (iou, *) ipar(7), DBLE(fpar(6))
73c76
<       write (iou, *) '# retrun code = ', ipar(1),  '   cgstep = ', mvstep
---
> !      write (iou, *) '# retrun code = ', ipar(1),  '   cgstep = ', mvstep
75c78
<       write (iou, *) (fpar(i),i=1,7)
---
> !      write (iou, *) (fpar(i),i=1,7)
78,82c81,86
<       call lapmvs(pot, wk)
<       do i = 1, n
<          wk(i) = wk(i) - rho(i)
<       enddo
<       write (iou, *) '# the residual norm ', DBLE(dnrm2(n,wk,1)), DBLE(fpar(5))
---
> !     call lapmvs(pot, wk)
> !     do i = 1, n
> !        wk(i) = wk(i) - rho(i)
> !     enddo
> !     write (iou, *) '# the residual norm ', DBLE(dnrm2(n,wk,1)),
> !    +     DBLE(fpar(5))
97a102
> 
108c113,114
<       USE cp_main_variables,       ONLY  :  coeke, nord2, lap_dir_num, lap_neig
---
>       USE cp_main_variables,       ONLY  :  coeke, nord2
>       USE smooth_grid_dimensions,  ONLY  :  nx=>nr1s, ny=>nr2s, nz=>nr3s
115c121
<       REAL(DP)  tmp, p1, p2, p3, p4, p5, p6
---
>       REAL(DP)  tmp, p1, p2, p3
124c130
<       tmp = sum(coeke(0,1:3+lap_dir_num))
---
>       tmp = coeke(0, 1) + coeke(0, 2) + coeke(0, 3)
129a136,143
>       do ish = 1, nord2
>          do i = 1, n
>             ii = odtothd_in_sp(1,i)
>             jj = odtothd_in_sp(2,i)        
>             kk = odtothd_in_sp(3,i)
> 
>             p1 = p( thdtood_in_sp( ii-ish, jj,     kk))    + &
>                  p( thdtood_in_sp( ii+ish, jj,     kk))
131,165c145,146
<       select case (lap_dir_num)
<       case (0)
< 
<          do ish = 1, nord2
<             do i = 1, n
<                ii = odtothd_in_sp(1,i)
<                jj = odtothd_in_sp(2,i)        
<                kk = odtothd_in_sp(3,i)
<    
<                p1 = p( thdtood_in_sp( ii-ish, jj,     kk))    + &
<                     p( thdtood_in_sp( ii+ish, jj,     kk))
<    
<                p2 = p( thdtood_in_sp( ii,     jj-ish, kk))    + &
<                     p( thdtood_in_sp( ii,     jj+ish, kk))
<    
<                p3 = p( thdtood_in_sp( ii,     jj,     kk-ish))+ &
<                     p( thdtood_in_sp( ii,     jj,     kk+ish))
<    
<                q(i) = q(i) + coeke(ish, 1)*p1 + coeke(ish, 2)*p2 + coeke(ish, 3)*p3
<             enddo
<          enddo  
< 
<       case (1)
< 
<          do ish = 1, nord2
<             do i = 1, n
<                ii = odtothd_in_sp(1,i)
<                jj = odtothd_in_sp(2,i)
<                kk = odtothd_in_sp(3,i)
< 
<                p1 = p( thdtood_in_sp( ii-ish, jj,     kk))    + &
<                     p( thdtood_in_sp( ii+ish, jj,     kk))
< 
<                p2 = p( thdtood_in_sp( ii,     jj-ish, kk))    + &
<                     p( thdtood_in_sp( ii,     jj+ish, kk))
---
>             p2 = p( thdtood_in_sp( ii,     jj-ish, kk))    + &
>                  p( thdtood_in_sp( ii,     jj+ish, kk))
167,168c148,149
<                p3 = p( thdtood_in_sp( ii,     jj,     kk-ish))+ &
<                     p( thdtood_in_sp( ii,     jj,     kk+ish))
---
>             p3 = p( thdtood_in_sp( ii,     jj,     kk-ish))+ &
>                  p( thdtood_in_sp( ii,     jj,     kk+ish))
170,174c151
<                p4 = p( thdtood_in_sp( ii-ish*lap_neig(1,1),jj-ish*lap_neig(2,1),kk-ish*lap_neig(3,1)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(1,1),jj+ish*lap_neig(2,1),kk+ish*lap_neig(3,1)))
< 
<                q(i) = q(i) + coeke(ish, 1)*p1 + coeke(ish, 2)*p2 + coeke(ish, 3)*p3 + coeke(ish, 4)*p4
<             enddo
---
>             q(i) = q(i) + coeke(ish, 1)*p1 + coeke(ish, 2)*p2 + coeke(ish, 3)*p3
176,188c153
<       case (2)
< 
<          do ish = 1, nord2
<             do i = 1, n
<                ii = odtothd_in_sp(1,i)
<                jj = odtothd_in_sp(2,i)
<                kk = odtothd_in_sp(3,i)
< 
<                p1 = p( thdtood_in_sp( ii-ish, jj,     kk))    + &
<                     p( thdtood_in_sp( ii+ish, jj,     kk))
< 
<                p2 = p( thdtood_in_sp( ii,     jj-ish, kk))    + &
<                     p( thdtood_in_sp( ii,     jj+ish, kk))
---
>       enddo  
190,233d154
<                p3 = p( thdtood_in_sp( ii,     jj,     kk-ish))+ &
<                     p( thdtood_in_sp( ii,     jj,     kk+ish))
< 
<                p4 = p( thdtood_in_sp( ii-ish*lap_neig(1,1),jj-ish*lap_neig(2,1),kk-ish*lap_neig(3,1)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(1,1),jj+ish*lap_neig(2,1),kk+ish*lap_neig(3,1)))
< 
<                p5 = p( thdtood_in_sp( ii-ish*lap_neig(1,2),jj-ish*lap_neig(2,2),kk-ish*lap_neig(3,2)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(1,2),jj+ish*lap_neig(2,2),kk+ish*lap_neig(3,2)))
< 
<                q(i) = q(i) + coeke(ish, 1)*p1 + coeke(ish, 2)*p2 + coeke(ish, 3)*p3 &
<                            + coeke(ish, 4)*p4 + coeke(ish, 5)*p5
<             enddo
<          enddo
< 
<       case (3)
<          do ish = 1, nord2
<             do i = 1, n
<                ii = odtothd_in_sp(1,i)
<                jj = odtothd_in_sp(2,i)
<                kk = odtothd_in_sp(3,i)
< 
<                p1 = p( thdtood_in_sp( ii-ish, jj,     kk))    + &
<                     p( thdtood_in_sp( ii+ish, jj,     kk))
< 
<                p2 = p( thdtood_in_sp( ii,     jj-ish, kk))    + &
<                     p( thdtood_in_sp( ii,     jj+ish, kk))
< 
<                p3 = p( thdtood_in_sp( ii,     jj,     kk-ish))+ &
<                     p( thdtood_in_sp( ii,     jj,     kk+ish))
< 
<                p4 = p( thdtood_in_sp( ii-ish*lap_neig(1,1),jj-ish*lap_neig(1,2),kk-ish*lap_neig(1,3)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(1,1),jj+ish*lap_neig(1,2),kk+ish*lap_neig(1,3)))
< 
<                p5 = p( thdtood_in_sp( ii-ish*lap_neig(2,1),jj-ish*lap_neig(2,2),kk-ish*lap_neig(2,3)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(2,1),jj+ish*lap_neig(2,2),kk+ish*lap_neig(2,3)))
< 
<                p6 = p( thdtood_in_sp( ii-ish*lap_neig(3,1),jj-ish*lap_neig(3,2),kk-ish*lap_neig(3,3)))+ &
<                     p( thdtood_in_sp( ii+ish*lap_neig(3,1),jj+ish*lap_neig(3,2),kk+ish*lap_neig(3,3)))
< 
<                q(i) = q(i) + coeke(ish, 1)*p1 + coeke(ish, 2)*p2 + coeke(ish, 3)*p3 + &
<                              coeke(ish, 4)*p4 + coeke(ish, 5)*p5 + coeke(ish, 6)*p6
<             enddo
<          enddo
<       end select
235a157,158
> 
> !----------------------------------------------------------------------c
Only in ../../../ffn2_tsvdw_master/CPV: exx_cg.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_cg.o
diff ./exx_es.f90 ../../../ffn2_tsvdw_master/CPV/exx_es.f90
13,14c13,15
<       USE cell_base,               ONLY  : at, alat, omega
<       use cell_base,               only  : r_to_s, s_to_r, ainv, h
---
>       USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s, nr1sx, nr2sx, nr3sx,nnrsx
>       USE grid_dimensions,         ONLY  : nr1, nr2, nr3, nr1x, nr2x, nr3x, nnrx
>       USE cell_base,               ONLY  : a1, a2, a3, omega
32d32
< #ifdef __MPI
34c34
< #endif
---
> 
38,39c38,40
<       REAl(DP)    wc(3, nbsp), middle(3,neigh), alength(3)
<       REAl(DP)    ha, hb, hc, sa1, hcub
---
>       REAl(DP)    wc(3, nbsp), middle(3,neigh)
>       REAl(DP)    ha, ha2, hb, hb2, hc, hc2, sa1
>       REAl(DP)    hcub, centerx, centery, centerz
50c51
<       REAL(DP)  totalenergy, totalenergyg, tot_energy(nbsp), tmp(3), tmp2(3)
---
>       REAL(DP)  totalenergy, totalenergyg, tot_energy(nbsp)
57,63c58,64
<       nnrtot = dffts%nr1 * dffts%nr2 * dffts%nr3
<       alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat
<       alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<       alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
<       ha = alength(1) / dffts%nr1  !nr1s in the parallel case
<       hb = alength(2) / dffts%nr2  !nr2s in the parallel case
<       hc = alength(3) / dffts%nr3  !nr3s in the parallel case
---
>       nnrtot = nr1s * nr2s * nr3s
>       ha = a1(1) / nr1s  !nr1s in the parallel case
>       hb = a2(2) / nr2s  !nr1s in the parallel case
>       hc = a3(3) / nr3s  !nr1s in the parallel case
>       ha2 = ha**2
>       hb2 = hb**2
>       hc2 = hc**2
64a66,68
>       centerx = 0.5 * a1(1)
>       centery = 0.5 * a2(2)
>       centerz = 0.5 * a3(3)
67c71
<       print *, 'entering exx_es', n_exx, nfi
---
>       write(stdout,*) 'entering exx_es', n_exx, nfi
77,88c81,89
<             tmp = wc(:,ir)
<             call r_to_s(tmp,  tmp2, ainv)
< !           call pbcs(tmp2, tmp,1)
<             do i = 1, 3
<                tmp(i) = tmp2(i) - int(tmp2(i))
<                if(tmp(i) < 0)then
<                   tmp(i) = tmp(i) + 1
<                endif
<             enddo
< 
<             call s_to_r(tmp,  tmp2, h)
<             wc(:,ir) = tmp2(:)
---
>             if (wc(1, ir) < 0) then
>                wc(1,ir) = wc(1,ir) + a1(1)
>             end if
>             if (wc(2, ir) < 0) then
>                wc(2,ir) = wc(2,ir) + a2(2)
>             end if
>             if (wc(3, ir) < 0) then
>                wc(3,ir) = wc(3,ir) + a3(3)
>             end if
113c114
<       my_nxyz(:) = dffts%nr1x*dffts%nr2x*dffts%npp
---
>       my_nxyz(:) = nr1sx*nr2sx*dffts%npp
115,117c116,118
< !     print *, 'me_nbsp  = ',  my_nbsp
< !     print *, 'me_vnbsp = ', my_vnbsp
< !     print *, 'my_nxyz  = ',  my_nxyz
---
>       write(stdout,*) 'me_nbsp  = ',  my_nbsp
>       write(stdout,*) 'me_vnbsp = ', my_vnbsp
>       write(stdout,*) 'my_nxyz  = ',  my_nxyz
134a136,137
> !      print *, 'index_my_nbsp = ', index_my_nbsp
> 
146a150,151
>       write(stdout,*) 'rk_of_vobtl = ', rk_of_vobtl
> 
154a160,161
>       write(stdout,*) 'lindex_of_vobtl = ', lindex_of_vobtl
> 
175c182
<       print *, 'nj_max =', nj_max
---
>       write(stdout,*) 'nj_max =', nj_max
178c185
<       if(ierr /= 0)write(*,*)"allocation error for psi_pair"
---
>       if(ierr /= 0) write(stdout,*) "allocation error for psi_pair"
183c190
<          print *, 'iobtl =', iobtl
---
>          write(stdout,*) 'iobtl =', iobtl
187c194
< #ifdef __MPI
---
> 
193c200
<                if( gindex_of_iobtl <= nbsp)then
---
>                if( gindex_of_iobtl > nbsp)exit
216d222
<                endif
224c230
<                if( gindex_of_iobtl <= nbsp)then
---
>                if( gindex_of_iobtl > nbsp)exit
236d241
<                endif
238a244
> 
240d245
< #endif
245c250
<          if( gindex_of_iobtl <= nbsp)then
---
>          if( gindex_of_iobtl > nbsp)exit
252c257,258
<                call getmiddlewc(wc(1,gindex_of_iobtl),vwc(1,overlap3(j,gindex_of_iobtl)), middle(1,j) )
---
>                call getmiddlewc(wc(1,gindex_of_iobtl),vwc(1,overlap3(j,gindex_of_iobtl)), &
> &                               centerx, centery, centerz, a1(1), a2(2), a3(3), middle(1,j) )
255,256c261
<                call getsftv( dffts%nr1, dffts%nr2, dffts%nr3, ha, hb, hc, &
<                              middle(1, j), tran)
---
>                call getsftv( nr1s, nr2s, nr3s, ha, hb, hc, middle(1, j), tran)
273d277
<          endif
281c285
<       print *, 'leaving exx_es'
---
>       write(stdout,*) 'leaving exx_es'
291,292c295
<       USE kinds,     ONLY  : DP
<       use cell_base, ONLY  : r_to_s, ainv, at, alat
---
>       USE kinds, ONLY  : DP
296c299
<       REAL(DP) wc(3), ha, hb, hc, wclat(3), alength(3)
---
>       REAL(DP) wc(3), ha, hb, hc
300,306d302
<       alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat
<       alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<       alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
< 
<       ! convert to lattice coordinates
<       call r_to_s(wc, wclat, ainv)
< 
308c304
<       wcm(1) = INT( wclat(1)*alength(1)/ha  ) + 1
---
>       wcm(1) = INT( wc(1)/ha  ) + 1
311c307
<       wcm(2) = INT( wclat(2)*alength(2)/hb  ) + 1
---
>       wcm(2) = INT( wc(2)/hb  ) + 1
314c310
<       wcm(3) = INT( wclat(3)*alength(3)/hc  ) + 1
---
>       wcm(3) = INT( wc(3)/hc  ) + 1
327d322
<       USE fft_base,                ONLY  : dffts
329a325
>       USE smooth_grid_dimensions,  ONLY  :  nr1s, nr2s, nr3s
353,359c349,355
<          if( ii .gt. dffts%nr1) ii = ii - int(ii/dffts%nr1)*dffts%nr1
<          if( jj .gt. dffts%nr2) jj = jj - int(jj/dffts%nr2)*dffts%nr2
<          if( kk .gt. dffts%nr3) kk = kk - int(kk/dffts%nr3)*dffts%nr3
< 
<          if( ii .lt. 1) ii = ii + dffts%nr1 - int( ii/dffts%nr1 )*dffts%nr1
<          if( jj .lt. 1) jj = jj + dffts%nr2 - int( jj/dffts%nr2 )*dffts%nr2
<          if( kk .lt. 1) kk = kk + dffts%nr3 - int( kk/dffts%nr3 )*dffts%nr3
---
>          if( ii .gt. nr1s)ii = ii - nr1s
>          if( jj .gt. nr2s)jj = jj - nr2s
>          if( kk .gt. nr3s)kk = kk - nr3s
> 
>          if( ii .lt. 1)ii = ii + nr1s
>          if( jj .lt. 1)jj = jj + nr2s
>          if( kk .lt. 1)kk = kk + nr3s
370,373c366,367
<       subroutine getmiddlewc(wc1, wc2, mid)
<       USE kinds,      ONLY  : DP
<       USE cell_base,  ONLY  : r_to_s, s_to_r, h, ainv
< 
---
>       subroutine getmiddlewc(wc1, wc2, cx, cy, cz, a, b, c, mid)
>       USE kinds, ONLY  : DP
377c371
<       real(DP)  diff(3), diffs(3), mids(3)
---
>       real(DP)  cx, cy, cz, a, b, c, tmp(3), center(3),acell(3)
380a375,382
>       center(1) = cx
>       center(2) = cy
>       center(3) = cz
> 
>       acell(1) = a
>       acell(2) = b
>       acell(3) = c
>  
382,390c384,386
<          mid(i)  = wc1(i) + wc2(i)
<          diff(i) = wc1(i) - wc2(i)
<       enddo
< 
<       call r_to_s(diff, diffs, ainv)
<       call r_to_s(mid , mids , ainv)
< 
<       do i = 1, 3
<          mids (i) = 0.5d0* (mids(i) - ABS(ANINT(diffs(i))))
---
>          mid(i) = wc1(i) + wc2(i)
>          tmp(i) = wc1(i) - wc2(i)
>          mid(i) = 0.5d0*( mid(i) - INT(ABS(tmp(i))/center(i))*acell(i) )
392,393d387
< 
<       call s_to_r(mids, mid, h)
Only in ../../../ffn2_tsvdw_master/CPV: exx_es.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_es.o
Only in .: exx_ggrid.f90
diff ./exx_gs.f90 ../../../ffn2_tsvdw_master/CPV/exx_gs.f90
12a13
>       USE cp_interfaces,           ONLY  : invfft
18,19c19,21
<       USE cell_base,               ONLY  : at, omega, alat
<       USE cell_base,               ONLY  : r_to_s, s_to_r, ainv, h, pbcs
---
>       USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s, nr1sx, nr2sx, nr3sx,nnrsx
>       USE grid_dimensions,         ONLY  : nr1, nr2, nr3, nr1x, nr2x, nr3x, nnrx
>       USE cell_base,               ONLY  : a1, a2, a3, omega
21a24
>       USE recvecs_indexes,         ONLY  : np, nm
26c29
<       USE cp_main_variables,       ONLY  : n_exx
---
>       USE cp_main_variables,       ONLY  : n_exx, wcenters !Charles Swartz
38c41
< #ifdef __MPI
---
>       
40c43
< #endif
---
> 
44,46c47,50
< 
<       REAl(DP)    sa1, wannierc(3, nbsp), middle(3,neigh/2)
<       REAl(DP)    ha, hb, hc, alength(3) ,hcub
---
>       REAl(DP)    sa1, wannierc(3, nbsp)
>       REAl(DP)    ha, ha2, hb, hb2, hc, hc2
>       REAl(DP)    hcub, centerx, centery, centerz
>       REAL(DP)    middle(3,neigh/2)
59c63
<       REAL(DP)  selfe, paire(neigh/2), tmp(3), tmp2(3)
---
>       REAL(DP)  selfe, paire(neigh/2)
67,74c71,77
<       nnrtot = dffts%nr1 * dffts%nr2 * dffts%nr3
<       alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat 
<       alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<       alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
< 
<       ha = alength(1) / dffts%nr1  !nr1s in the parallel case
<       hb = alength(2) / dffts%nr2  !nr1s in the parallel case
<       hc = alength(3) / dffts%nr3  !nr1s in the parallel case
---
>       nnrtot = nr1s * nr2s * nr3s
>       ha = a1(1) / nr1s  !nr1s in the parallel case
>       hb = a2(2) / nr2s  !nr1s in the parallel case
>       hc = a3(3) / nr3s  !nr1s in the parallel case
>       ha2 = ha**2
>       hb2 = hb**2
>       hc2 = hc**2
75a79,81
>       centerx = 0.5 * a1(1)
>       centery = 0.5 * a2(2)
>       centerz = 0.5 * a3(3)
78c84
<       print *, 'entering exx_gs', n_exx, nfi, np_in_sp
---
> !      print *, 'entering exx_gs', n_exx, nfi, np_in_sp
87,89c93,97
<           do ir = 1, nbsp
<              read(407, *) wannierc(1,ir), wannierc(2,ir), wannierc(3,ir)
<           end do
---
>           !Charles Swartz
>           !do ir = 1, nbsp
>           !   read(407, *) wannierc(1,ir), wannierc(2,ir), wannierc(3,ir)
>           !end do
>           wannierc(:, :) = wcenters(:, :)
95,105c103,111
<          tmp = wannierc(:,ir)
<          call r_to_s(tmp, tmp2, ainv)
< !        call pbcs(tmp2, tmp,1)
<          do i = 1, 3
<             tmp(i) = tmp2(i) - int(tmp2(i))
<             if(tmp(i) < 0)then
<                tmp(i) = tmp(i) + 1
<             endif
<          enddo
<          call s_to_r(tmp,  tmp2, h)
<          wannierc(:,ir) = tmp2(:)
---
>          if (wannierc(1, ir) < 0) then
>             wannierc(1,ir) = wannierc(1,ir) + a1(1)
>          end if
>          if (wannierc(2, ir) < 0) then
>             wannierc(2,ir) = wannierc(2,ir) + a2(2)
>          end if
>          if (wannierc(3, ir) < 0) then
>             wannierc(3,ir) = wannierc(3,ir) + a3(3)
>          end if
123,125c129,131
<       my_nxyz(:) = dffts%nr1x*dffts%nr2x*dffts%npp
<       print *, my_nbsp
<       print *, my_nxyz
---
>       my_nxyz(:) = nr1sx*nr2sx*dffts%npp
> !      print *, my_nbsp
> !      print *, my_nxyz
145c151
<       print *, 'index_my_nbsp = ', index_my_nbsp
---
> !      print *, 'index_my_nbsp = ', index_my_nbsp
154c160
<               print *, 'lrk_of_iobtl=', proc-1, rk_of_obtl(iobtl) 
---
> !              print *, 'lrk_of_iobtl=', proc-1, rk_of_obtl(iobtl) 
160c166
<       print *, 'rk_of_obtl = ', rk_of_obtl
---
> !      print *, 'rk_of_obtl = ', rk_of_obtl
170c176
<       print *, 'lindex_of_obtl = ', lindex_of_obtl
---
> !     print *, 'lindex_of_obtl = ', lindex_of_obtl
198,199c204
<          call getsftv ( dffts%nr1,dffts%nr2,dffts%nr3, ha, hb, hc, &
<                         wannierc(1, gindex_of_iobtl), tran)
---
>          call getsftv(nr1s, nr2s, nr3s, ha, hb, hc, wannierc(1, gindex_of_iobtl), tran)
202a208
>          v(:) = 0.d0
212c218,219
<          write(6,*)iobtl, 'self energy' , selfe
---
> !         write(6,*)iobtl, 'self energy' , selfe
> 
222c229
<       call exx_index_pair(wannierc, overlap3, njj, nj_max)
---
>       call exx_index_pair(wannierc, overlap3, njj,  centerx,  centery,  centerz, nj_max )
229a237,238
>       allocate(vpsiforj_trcv(nnrtot))
> 
237c246
< #ifdef __MPI
---
> 
286d294
< #endif
293c301
<          print *,'gindex_of_iobtl = ', gindex_of_iobtl 
---
> !         print *,'gindex_of_iobtl = ', gindex_of_iobtl 
303c311,312
<                call getmiddlewc(wannierc(1,gindex_of_iobtl),wannierc(1,overlap3(j,gindex_of_iobtl)), middle(1,j) )
---
>                call getmiddlewc(wannierc(1,gindex_of_iobtl),wannierc(1,overlap3(j,gindex_of_iobtl)), &
> &                               centerx, centery, centerz, a1(1), a2(2), a3(3), middle(1,j) )
306,307c315
<                call getsftv( dffts%nr1, dffts%nr2, dffts%nr3, ha, hb, hc, &
<                              middle(1, j), tran)
---
>                call getsftv( nr1s, nr2s, nr3s, ha, hb, hc, middle(1, j), tran)
322,323c330,331
<          print *, 'pair energy  follows '
<          write(*,'(5f15.8)')(paire(j),j=1,njj( gindex_of_iobtl ))
---
> !         print *, 'pair energy  follows '
> !         write(*,'(5f15.8)')(paire(j),j=1,njj( gindex_of_iobtl ))
336,337d343
<          allocate(vpsiforj_trcv(nnrtot))
< #ifdef __MPI
375,376d380
< #endif
<          deallocate( vpsiforj_trcv )
385c389
< #ifdef __MPI
---
> 
390c394
< #endif
---
> 
393c397
<       write(stdout, '(a, f12.6)')'    EXX Energy' , exx
---
>       write(stdout, '(a, f20.10)')'    EXX Energy' , exx
396c400
<       call redistwfr( vpsig, vpsil, my_nxyz, my_nbsp, intra_image_comm, -1 )
---
>       call redistwfr ( vpsig, vpsil, my_nxyz, my_nbsp, intra_image_comm, -1 )
399c403
<       print *, 'leaving exx_gs'
---
> !      print *, 'leaving exx_gs'
402a407
>       deallocate( vpsiforj_trcv )
Only in ../../../ffn2_tsvdw_master/CPV: exx_gs.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_gs.o
diff ./exx_pair.f90 ../../../ffn2_tsvdw_master/CPV/exx_pair.f90
3a4
> !  Lingzhu Kong
10c11
<       USE cell_base,             ONLY  : h, ainv, r_to_s, s_to_r
---
>       USE cell_base,             ONLY  : a1, a2, a3
20,21c21,22
<       INTEGER     i, j, ii, ierr
<       REAl(DP)    ri(3), rj(3), ris(3), rjs(3) , rijs(3), rij(3), distance
---
>       INTEGER     i, j, ierr
>       REAl(DP)    centerx, centery, centerz, xi, yi, zi, xj, yj, zj, xij, yij, zij, distance
25c26,30
< !     print *, 'entering exx_index_pair_nv', dis_cutoff, neigh, vnbsp
---
>       print *, 'entering exx_index_pair_nv', dis_cutoff, neigh, vnbsp
>       centerx = 0.5 * a1(1)
>       centery = 0.5 * a2(2)
>       centerz = 0.5 * a3(3)
> 
31,36c36,38
< 
<          do ii = 1, 3
<             ri(ii) = wc( ii, i )
<          enddo
< 
<          call r_to_s(ri, ris, ainv)
---
>          xi = wc( 1, i )
>          yi = wc( 2, i )
>          zi = wc( 3, i )
39,52c41,47
< 
<             do ii = 1, 3
<                rj(ii) = vwc(ii,j)
<             enddo
< 
<             call r_to_s(rj, rjs, ainv)
< 
<             do ii = 1, 3
<                rijs(ii) = rjs(ii) - ris(ii) - ANINT(rjs(ii) - ris(ii))
<             enddo
< 
<             call s_to_r(rijs, rij, h)
< 
<             distance = sqrt( rij(1)*rij(1) + rij(2)*rij(2) + rij(3) *rij(3) )
---
>             xj = vwc(1,j)
>             yj = vwc(2,j)
>             zj = vwc(3,j)
>             xij = xj - xi - INT( (xj-xi)/centerx )*a1(1) 
>             yij = yj - yi - INT( (yj-yi)/centery )*a2(2)  
>             zij = zj - zi - INT( (zj-zi)/centerz )*a3(3) 
>             distance = sqrt( xij*xij + yij*yij + zij*zij)
69a65
>       print *, 'leave exx_index_pair_nv', nj
81c77
<      SUBROUTINE exx_index_pair(wannierc, overlap3, nj, nj_max )
---
>      SUBROUTINE exx_index_pair(wannierc, overlap3, nj,  centerx,  centery,  centerz, nj_max )
85c81
<       USE cell_base,               ONLY  : ainv, h, r_to_s, s_to_r
---
>       USE cell_base,               ONLY  : a1, a2, a3
91c87
<       REAl(DP),INTENT(IN)    ::    wannierc(3, nbsp)
---
>       REAl(DP),INTENT(IN)    ::    wannierc(3, nbsp), centerx,  centery,  centerz
97,98c93,94
<       INTEGER     i, j, k, ii, jj, ip, ir, ierr, num, num1, nj_avg
<       REAl(DP)    ri(3), rj(3), rij(3), ris(3), rjs(3), rijs(3)
---
>       INTEGER     i, j, k,jj, ip, ir, ierr, num, num1, nj_avg
>       REAl(DP)    xi, yi, zi, xj, yj, zj, xij, yij, zij
117,118c113,114
<          print *, "nbsp is",nbsp
<          print *, "nupdwn, iupdwn",nupdwn_(1), nupdwn_(2),iupdwn_(1), iupdwn_(2)
---
> !         print *, "nbsp is",nbsp
> !         print *, "nupdwn, iupdwn",nupdwn_(1), nupdwn_(2),iupdwn_(1), iupdwn_(2)
125,127c121,123
<          do ii = 1, 3
<             ri(ii) = wannierc( ii, i )
<          enddo
---
>          xi = wannierc( 1, i )
>          yi = wannierc( 2, i )
>          zi = wannierc( 3, i )
129,130d124
<          call r_to_s(ri, ris, ainv)
< 
143,154c137,143
<                do ii = 1, 3
<                   rj(ii) = wannierc(ii, j)
<                enddo
<                call r_to_s(rj, rjs, ainv)
< 
<                do ii = 1, 3
<                   rijs(ii) = rjs(ii) - ris(ii) - ANINT(rjs(ii) - ris(ii))
<                enddo
< 
<                call s_to_r(rijs, rij, h)
< 
<                distance(j) = sqrt( rij(1)*rij(1) + rij(2)*rij(2) + rij(3) *rij(3) )
---
>                xj = wannierc(1, j)
>                yj = wannierc(2, j)
>                zj = wannierc(3, j)
>                xij = xj - xi - INT( (xj-xi)/centerx )*a1(1) 
>                yij = yj - yi - INT( (yj-yi)/centery )*a2(2)  
>                zij = zj - zi - INT( (zj-zi)/centerz )*a3(3) 
>                distance(j) = sqrt( xij*xij + yij*yij + zij*zij)
216c205
<      print *,"pair num  and num1 is",num,num1
---
> !     print *,"pair num  and num1 is",num,num1
229c218
< !      open(unit=20,file='pair.dat',status='unknown',form='formatted')
---
>        open(unit=20,file='pair.dat',status='unknown',form='formatted')
231c220
<           write(*, '(8I7)')(overlap3(j,i),j=1, nj(i))
---
>           write(20, '(8I7)')(overlap3(j,i),j=1, nj(i))
233c222
< !      close(20)
---
>        close(20)
251,252c240,241
<      print *,"nj_max and nj_avg are ",nj_max, nj_avg/nbsp
<      write(*,'(10I5)')(nj(i),i=1, nbsp)
---
> !     print *,"nj_max and nj_avg are ",nj_max, nj_avg/nbsp
> !     write(*,'(10I5)')(nj(i),i=1, nbsp)
Only in ../../../ffn2_tsvdw_master/CPV: exx_pair.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_pair.o
diff ./exx_psi.f90 ../../../ffn2_tsvdw_master/CPV/exx_psi.f90
9c9
<        USE fft_interfaces,           ONLY  : invfft
---
>        USE cp_interfaces,           ONLY  : invfft
11a12
>        USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s, nr1sx, nr2sx, nr3sx,nnrsx
15a17
>        USE gvecs,                   ONLY  : nms, nps
35,36c37,38
<        IF(nproc_image >= dffts%nr3x) THEN
<          sizefft=dffts%nnr
---
>        IF(nproc_image >= nr3sx)THEN
>          sizefft=dffts%nnrx
38c40
<          sizefft=dffts%npp(me)*dffts%nr1x*dffts%nr2x
---
>          sizefft=dffts%npp(me)*nr1sx*nr2sx
44,46c46,48
<        print *, "dffts%nnr is", dffts%nnr
<        print *, "nbsp and ngw is",nbsp,ngw
<        print *, "nrs is", dffts%nr1x, dffts%nr2x, dffts%nr3x
---
> !       print *, "dffts%nnrx is", dffts%nnrx
> !       print *, "nbsp and ngw is",nbsp,ngw
> !       print *, "nrs is", nr1sx, nr2sx, nr3sx
53c55
<               call c2psi( psis, dffts%nnr, c(1,i), ca(1), ngw, 2)
---
>               call c2psi( psis, nnrsx, c(1,i), ca(1), ngw, 2)
55c57
<               call c2psi( psis, dffts%nnr, c(1,i), c(1, i+1), ngw, 2)
---
>               call c2psi( psis, nnrsx, c(1,i), c(1, i+1), ngw, 2)
Only in ../../../ffn2_tsvdw_master/CPV: exx_psi.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_psi.o
diff ./exx_setup.f90 ../../../ffn2_tsvdw_master/CPV/exx_setup.f90
5a6,7
> !
> ! Adapted from PARSEC by Lingzhu Kong. http://parsec.ices.utexas.edu/
10,12c12,14
<       USE kinds,      ONLY  : DP
<       USE cell_base,  ONLY  : at, alat, h, s_to_r
<       USE fft_base,   ONLY  : dffts
---
>       USE kinds,                   ONLY  : DP
>       USE cell_base,               ONLY  : a1, a2, a3
>       USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s
19c21
<       REAL(DP)  s(3),r(3),dist, alength(3)
---
>       REAL(DP)  x,y,z, dist, centerx, centery, centerz, hx, hy, hz
22,26c24,31
<       alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat
<       alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<       alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
< 
< !     print *, 'alength and step = ', alength, step
---
> ! works for orthogonal cell only
>       hx = a1(1) / nr1s  !nr1s in the parallel case
>       hy = a2(2) / nr2s  !nr1s in the parallel case
>       hz = a3(3) / nr3s  !nr1s in the parallel case
> 
>       centerx = 0.5d0 * nr1s * hx 
>       centery = 0.5d0 * nr2s * hy
>       centerz = 0.5d0 * nr3s * hz
30,39c35,42
<        do k = 1, dffts%nr3
<           do j = 1, dffts%nr2
<              do i =1, dffts%nr1
<             
<                 s(1) = DBLE(i)/DBLE(dffts%nr1) - 0.5d0
<                 s(2) = DBLE(j)/DBLE(dffts%nr2) - 0.5d0
<                 s(3) = DBLE(k)/DBLE(dffts%nr3) - 0.5d0
< 
<                 call s_to_r(s, r, h)
<                 dist = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
---
>        do k = 1,nr3s
>           do j = 1, nr2s
>              do i =1, nr1s
>              
>                 x = i * hx -centerx
>                 y = j * hy -centery
>                 z = k * hz -centerz
>                 dist = sqrt(x*x + y*y + z*z)
59,60c62,63
<      USE cell_base,               ONLY  : at, alat, h, s_to_r
<      USE fft_base,                ONLY  : dffts
---
>      USE cell_base,               ONLY  : a1, a2, a3
>      USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s
73,75d75
<      use cp_main_variables,       ONLY  : lap_neig, lap_dir_num, &
<                                           lap_dir_step, b_lap, lap_dir
< 
85c85
<      real(DP) factor
---
>      real(DP) hx, hy, hz, factor
90c90
<        real(DP)  s(3),r(3),dist, alength(3), step(3)
---
>        real(DP)  x,y,z, dist, centerx, centery, centerz
96,103c96,103
<       alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat
<       alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<       alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
< 
<       step(1) = alength(1) / dffts%nr1
<       step(2) = alength(2) / dffts%nr2
<       step(3) = alength(3) / dffts%nr3
<  
---
>       hx = a1(1) / nr1s
>       hy = a2(2) / nr2s
>       hz = a3(3) / nr3s
> 
>       centerx = 0.5d0 * nr1s * hx
>       centery = 0.5d0 * nr2s * hy
>       centerz = 0.5d0 * nr3s * hz
> 
107,109c107,109
<        do k = 1, dffts%nr3
<           do j = 1, dffts%nr2
<              do i =1, dffts%nr1
---
>        do k = 1,nr3s
>           do j = 1, nr2s
>              do i =1, nr1s
116,121c116,119
<                 s(1) = DBLE(i)/DBLE(dffts%nr1) - 0.5d0
<                 s(2) = DBLE(j)/DBLE(dffts%nr2) - 0.5d0
<                 s(3) = DBLE(k)/DBLE(dffts%nr3) - 0.5d0
< 
<                 call s_to_r(s, r, h)
<                 dist = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
---
>                 x = i * hx -centerx
>                 y = j * hy -centery
>                 z = k * hz -centerz
>                 dist = sqrt(x*x + y*y + z*z)
130,132c128,131
<                    xx_in_sp(npsp) = r(1)
<                    yy_in_sp(npsp) = r(2)
<                    zz_in_sp(npsp) = r(3)
---
> 
>                    xx_in_sp(npsp) = x
>                    yy_in_sp(npsp) = y
>                    zz_in_sp(npsp) = z
141,143c140,142
<                    xx_in_sp(tmp) = r(1)
<                    yy_in_sp(tmp) = r(2)
<                    zz_in_sp(tmp) = r(3)
---
>                    xx_in_sp(tmp) = x
>                    yy_in_sp(tmp) = y
>                    zz_in_sp(tmp) = z
151c150
<        write(6,*)' npsp in exx_setup =', npsp, npsp2
---
> !       write(6,*)' npsp in exx_setup =', npsp, npsp2
165,170d163
< ! non-orthogonal grids
< 
<       call exx_ggrid(h,step,1.d-8)
< !========================================================================
< 
< !========================================================================
179,191c172,175
< !  Renormalize coekes with respect to the grid spacing. First to the
< !  new directions for non-orthogonal grid.
<        if(lap_dir_num > 0) then
<           write(6,*) ' lap_dir_num > 0', lap_dir_num
<           do i = 1,lap_dir_num
<              coeke(:,3+i) = -b_lap(3+i)*coeke(:,1)/(lap_dir_step(i)**2*factor)
<           end do
<        end if
< 
<        do i = 3, 1, -1
<           coeke(:,i) = -b_lap(i)*coeke(:,1)/(step(i)*step(i)*factor)
<        enddo
< 
---
> !      renormalize coekes with respect to the grid spacing
>        coeke(:,3) = -coeke(:,1)/(hz*hz*factor)
>        coeke(:,2) = -coeke(:,1)/(hy*hy*factor)
>        coeke(:,1) = -coeke(:,1)/(hx*hx*factor)
197c181
<        end
---
>       end
201c185,187
<      subroutine exx_setup_nscf( nnrtot, lpole, clm, factor, wc, vwc, nbsp, vnbsp )
---
> 
> 
>    subroutine exx_setup_nscf( nnrtot, lpole, clm, factor, wc, vwc, nbsp, vnbsp )
204,205c190,191
<      USE cell_base,               ONLY  : at, alat, h, s_to_r 
<      USE fft_base,                ONLY  : dffts
---
>      USE cell_base,               ONLY  : a1, a2, a3
>      USE smooth_grid_dimensions,  ONLY  : nr1s, nr2s, nr3s
216c202,203
<      USE cp_main_variables,       ONLY  : thdtood
---
>      USE cp_main_variables,       ONLY  : thdtood, &
>                                           wcenters, vwcenters !Charles Swartz
218,219d204
<      use cp_main_variables,       ONLY  : lap_neig, lap_dir_num, &
<                                           lap_dir_step, b_lap, lap_dir
228c213
<      real(DP) factor, wc(3, nbsp), vwc(3, vnbsp)
---
>      real(DP) hx, hy, hz, factor, wc(3, nbsp), vwc(3, vnbsp)
237c222
<        real(DP)  s(3), r(3),dist, alength(3), step(3)
---
>        real(DP)  x,y,z, dist, centerx, centery, centerz
245,252c230,237
<        alength(1) = sqrt( at(1,1)**2 + at(2,1)**2 + at(3,1)**2 ) * alat
<        alength(2) = sqrt( at(1,2)**2 + at(2,2)**2 + at(3,2)**2 ) * alat
<        alength(3) = sqrt( at(1,3)**2 + at(2,3)**2 + at(3,3)**2 ) * alat
<  
<        step(1) = alength(1) / dffts%nr1
<        step(2) = alength(2) / dffts%nr2
<        step(3) = alength(3) / dffts%nr3
<  
---
>       hx = a1(1) / nr1s 
>       hy = a2(2) / nr2s
>       hz = a3(3) / nr3s
> 
>       centerx = 0.5d0 * nr1s * hx
>       centery = 0.5d0 * nr2s * hy
>       centerz = 0.5d0 * nr3s * hz
> 
256,258c241,243
<        do k = 1, dffts%nr3
<           do j = 1, dffts%nr2
<              do i =1, dffts%nr1
---
>        do k = 1,nr3s
>           do j = 1, nr2s
>              do i =1, nr1s
265,271c250,254
<                 s(1) = DBLE(i)/DBLE(dffts%nr1) - 0.5d0
<                 s(2) = DBLE(j)/DBLE(dffts%nr2) - 0.5d0
<                 s(3) = DBLE(k)/DBLE(dffts%nr3) - 0.5d0
< 
<                 call s_to_r(s, r, h)
<                 dist = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
< 
---
>                 x = i * hx -centerx
>                 y = j * hy -centery
>                 z = k * hz -centerz
>                 dist = sqrt(x*x + y*y + z*z)
>              
279,281c262,264
<                    xx_in_sp(npsp) = r(1)
<                    yy_in_sp(npsp) = r(2)
<                    zz_in_sp(npsp) = r(3)
---
>                    xx_in_sp(npsp) = x
>                    yy_in_sp(npsp) = y
>                    zz_in_sp(npsp) = z
290,292c273,275
<                    xx_in_sp(tmp) = r(1)
<                    yy_in_sp(tmp) = r(2)
<                    zz_in_sp(tmp) = r(3)
---
>                    xx_in_sp(tmp) = x
>                    yy_in_sp(tmp) = y
>                    zz_in_sp(tmp) = z
312,313d294
<        call exx_ggrid(h,step,1.d-8)
< 
323,334c304,307
< !  Renormalize coekes with respect to the grid spacing. First to the
< !  new directions for non-orthogonal grid.
<        if(lap_dir_num > 0) then
<           write(6,*) ' lap_dir_num > 0', lap_dir_num
<           do i = 1,lap_dir_num
<              coeke(:,3+i) = -b_lap(3+i)*coeke(:,1)/(lap_dir_step(i)**2*factor)
<           end do
<        end if
< 
<        do i = 3, 1, -1
<           coeke(:,i) = -b_lap(i)*coeke(:,1)/(step(i)*step(i)*factor)
<        enddo
---
> !      renormalize coekes with respect to the grid spacing
>        coeke(:,3) = -coeke(:,1)/(hz*hz*factor)
>        coeke(:,2) = -coeke(:,1)/(hy*hy*factor)
>        coeke(:,1) = -coeke(:,1)/(hx*hx*factor)
339c312
<        call getwc(wc, vwc, vnbsp, nbsp)
---
>        call getwc(wc, vwc, vnbsp, nbsp, a1(1), a2(2), a3(3))
345c318
<        subroutine getwc(wc, vwc, vnbsp, nbsp)
---
>        subroutine getwc(wc, vwc, vnbsp, nbsp, a1, a2, a3)
347c320,321
<        USE cell_base,               ONLY  : h, ainv, s_to_r, r_to_s, pbcs
---
>        USE cp_main_variables,       ONLY  : wcenters, vwcenters !Charles Swartz
>        USE io_global,               ONLY  : stdout
351,352c325,326
<        INTEGER     vnbsp, nbsp, i, ir
<        REAl(DP)    wc(3, nbsp), vwc(3, vnbsp), tmp(3)
---
>        INTEGER     vnbsp, nbsp, ir
>        REAl(DP)    wc(3, nbsp), vwc(3, vnbsp), a1, a2, a3
355,365c329,331
<           read(407, *) tmp(1), tmp(2), tmp(3)
<           call r_to_s(tmp,wc(:,ir), ainv)
< !         call pbcs(wc(:,ir),tmp,1)
<           do i = 1, 3
<              tmp(i) = wc(i,ir) - int( wc(i,ir))
<              if(tmp(i) < 0)then
<                 tmp(i) = tmp(i) + 1
<              endif
<           enddo
< 
<           call s_to_r(tmp,wc(:,ir), h)
---
>           !Charles Swartz
>           !read(407, *) wc(1,ir), wc(2,ir), wc(3,ir)
>           wc(:,:) = wcenters(:,:)
369,379c335,337
<           read(408,*)tmp(1), tmp(2), tmp(3)
<           call r_to_s(tmp, vwc(:,ir), ainv)
< !         call pbcs(  vwc(:,ir), tmp, 1)
<           do i = 1, 3
<              tmp(i) = vwc(i,ir) - int( vwc(i,ir))
<              if(tmp(i) < 0)then
<                 tmp(i) = tmp(i) + 1
<              endif
<           enddo
< 
<           call s_to_r(tmp, vwc(:,ir), h)
---
>           !Charles Swartz
>           !read(408,*)vwc(1,ir), vwc(2,ir), vwc(3,ir)
>           vwc(:,:) = vwcenters(:,:)
380a339,362
> 
>        do ir = 1, vnbsp
>           if (vwc(1, ir) < 0) then
>              vwc(1,ir) = vwc(1,ir) + a1
>           end if
>           if (vwc(2, ir) < 0) then
>              vwc(2,ir) = vwc(2,ir) + a2
>           end if
>           if (vwc(3, ir) < 0) then
>              vwc(3,ir) = vwc(3,ir) + a3
>           end if
>        end do
> 
>        do ir = 1, nbsp
>           if (wc(1, ir) < 0) then
>              wc(1,ir) = wc(1,ir) + a1
>           end if
>           if (wc(2, ir) < 0) then
>              wc(2,ir) = wc(2,ir) + a2
>           end if
>           if (wc(3, ir) < 0) then
>              wc(3,ir) = wc(3,ir) + a3
>           end if
>        end do
Only in ../../../ffn2_tsvdw_master/CPV: exx_setup.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_setup.o
diff ./exx_vofr.f90 ../../../ffn2_tsvdw_master/CPV/exx_vofr.f90
6a7
> ! Adapted from PARSEC by Lingzhu Kong,  http://parsec.ices.utexas.edu/
10c11
<       USE fft_base,                ONLY  :  dffts
---
>       USE smooth_grid_dimensions,  ONLY  :  nr1s, nr2s, nr3s
40a42
>        v_in_sp = 0.d0
53,55c55,57
<           if( ii .gt. dffts%nr1) ii = ii - dffts%nr1
<           if( jj .gt. dffts%nr2) jj = jj - dffts%nr2
<           if( kk .gt. dffts%nr3) kk = kk - dffts%nr3
---
>           if( ii .gt. nr1s)ii = ii - nr1s
>           if( jj .gt. nr2s)jj = jj - nr2s
>           if( kk .gt. nr3s)kk = kk - nr3s
57,59c59,61
<           if( ii .lt. 1) ii = ii + dffts%nr1
<           if( jj .lt. 1) jj = jj + dffts%nr2
<           if( kk .lt. 1) kk = kk + dffts%nr3
---
>           if( ii .lt. 1)ii = ii + nr1s
>           if( jj .lt. 1)jj = jj + nr2s
>           if( kk .lt. 1)kk = kk + nr3s
99,101c101,103
<           if( ii .gt. dffts%nr1) ii = ii - dffts%nr1
<           if( jj .gt. dffts%nr2) jj = jj - dffts%nr2
<           if( kk .gt. dffts%nr3) kk = kk - dffts%nr3
---
>           if( ii .gt. nr1s)ii = ii - nr1s
>           if( jj .gt. nr2s)jj = jj - nr2s
>           if( kk .gt. nr3s)kk = kk - nr3s
103,105c105,107
<           if( ii .lt. 1) ii = ii + dffts%nr1
<           if( jj .lt. 1) jj = jj + dffts%nr2
<           if( kk .lt. 1) kk = kk + dffts%nr3
---
>           if( ii .lt. 1)ii = ii + nr1s
>           if( jj .lt. 1)jj = jj + nr2s
>           if( kk .lt. 1)kk = kk + nr3s
292c294
<        USE cp_main_variables,       ONLY  :  np_in_sp, np_in_sp2, nord2,coeke, lap_dir_num, lap_neig
---
>        USE cp_main_variables,       ONLY  :  np_in_sp, np_in_sp2, nord2,coeke
297c299
<        REAL(DP) rho(np_in_sp), v_in_sp( 1:np_in_sp+np_in_sp2 )
---
>        REAL(DP) rho(np_in_sp), v_in_sp( 1:np_in_sp+np_in_sp2 ), two
299,330c301
< 
< 
<        select case (lap_dir_num)
<        case (0)
< 
<        DO ip = 1, np_in_sp
< 
< !(i,j,k) is within the first sphere
<           i = odtothd_in_sp(1,ip)
<           j = odtothd_in_sp(2,ip)
<           k = odtothd_in_sp(3,ip)
< 
<           DO ish  = 1, nord2
< 
<              ipp = thdtood_in_sp( i+ish, j,     k     )
<              ipm = thdtood_in_sp( i-ish, j,     k     )
<              jpp = thdtood_in_sp( i,     j+ish, k     )
<              jpm = thdtood_in_sp( i,     j-ish, k     )
<              kpp = thdtood_in_sp( i,     j,     k+ish )
<              kpm = thdtood_in_sp( i,     j,     k-ish )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipm)
<              IF(jpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpp)
<              IF(jpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpm)
<              IF(kpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpp)
<              IF(kpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpm)
< 
<           ENDDO
<        ENDDO
< 
<       case (1)
---
>        two = 2.d0
354,359d324
<              ipp = thdtood_in_sp( i+ish*lap_neig(1,1),j+ish*lap_neig(2,1),k+ish*lap_neig(3,1) )
<              ipm = thdtood_in_sp( i-ish*lap_neig(1,1),j-ish*lap_neig(2,1),k-ish*lap_neig(3,1) )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipm)
< 
362,444d326
< 
<       case (2)
<        DO ip = 1, np_in_sp
< 
< !(i,j,k) is within the first sphere
<           i = odtothd_in_sp(1,ip)
<           j = odtothd_in_sp(2,ip)
<           k = odtothd_in_sp(3,ip)
< 
<           DO ish  = 1, nord2
< 
<              ipp = thdtood_in_sp( i+ish, j,     k     )
<              ipm = thdtood_in_sp( i-ish, j,     k     )
<              jpp = thdtood_in_sp( i,     j+ish, k     )
<              jpm = thdtood_in_sp( i,     j-ish, k     )
<              kpp = thdtood_in_sp( i,     j,     k+ish )
<              kpm = thdtood_in_sp( i,     j,     k-ish )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipm)
<              IF(jpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpp)
<              IF(jpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpm)
<              IF(kpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpp)
<              IF(kpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpm)
< 
<              ipp = thdtood_in_sp( i+ish*lap_neig(1,1),j+ish*lap_neig(2,1),k+ish*lap_neig(3,1) )
<              ipm = thdtood_in_sp( i-ish*lap_neig(1,1),j-ish*lap_neig(2,1),k-ish*lap_neig(3,1) )
< 
<              jpp = thdtood_in_sp( i+ish*lap_neig(1,2),j+ish*lap_neig(2,2),k+ish*lap_neig(3,2) )
<              jpm = thdtood_in_sp( i-ish*lap_neig(1,2),j-ish*lap_neig(2,2),k-ish*lap_neig(3,2) )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipm)
<              IF(jpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,5)*v_in_sp(jpp)
<              IF(jpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,5)*v_in_sp(jpm)
< 
<           ENDDO
<        ENDDO
< 
<       case (3)
<        DO ip = 1, np_in_sp
< 
< !(i,j,k) is within the first sphere
<           i = odtothd_in_sp(1,ip)
<           j = odtothd_in_sp(2,ip)
<           k = odtothd_in_sp(3,ip)
< 
<           DO ish  = 1, nord2
< 
<              ipp = thdtood_in_sp( i+ish, j,     k     )
<              ipm = thdtood_in_sp( i-ish, j,     k     )
<              jpp = thdtood_in_sp( i,     j+ish, k     )
<              jpm = thdtood_in_sp( i,     j-ish, k     )
<              kpp = thdtood_in_sp( i,     j,     k+ish )
<              kpm = thdtood_in_sp( i,     j,     k-ish )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,1)*v_in_sp(ipm)
<              IF(jpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpp)
<              IF(jpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,2)*v_in_sp(jpm)
<              IF(kpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpp)
<              IF(kpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,3)*v_in_sp(kpm)
< 
<              ipp = thdtood_in_sp( i+ish*lap_neig(1,1),j+ish*lap_neig(1,2),k+ish*lap_neig(1,3) )
<              ipm = thdtood_in_sp( i-ish*lap_neig(1,1),j-ish*lap_neig(1,2),k-ish*lap_neig(1,3) )
< 
<              jpp = thdtood_in_sp( i+ish*lap_neig(2,1),j+ish*lap_neig(2,2),k+ish*lap_neig(2,3) )
<              jpm = thdtood_in_sp( i-ish*lap_neig(2,1),j-ish*lap_neig(2,2),k-ish*lap_neig(2,3) )
< 
<              kpp = thdtood_in_sp( i+ish*lap_neig(3,1),j+ish*lap_neig(3,2),k+ish*lap_neig(3,3) )
<              kpm = thdtood_in_sp( i-ish*lap_neig(3,1),j-ish*lap_neig(3,2),k-ish*lap_neig(3,3) )
< 
<              IF(ipp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipp)
<              IF(ipm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,4)*v_in_sp(ipm)
<              IF(jpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,5)*v_in_sp(jpp)
<              IF(jpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,5)*v_in_sp(jpm)
<              IF(kpp .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,6)*v_in_sp(kpp)
<              IF(kpm .gt. np_in_sp) rho(ip) = rho(ip) - coeke(ish,6)*v_in_sp(kpm)
< 
<           ENDDO
<        ENDDO
< 
<       endselect
Only in ../../../ffn2_tsvdw_master/CPV: exx_vofr.F90
Only in ../../../ffn2_tsvdw_master/CPV: exx_vofr.o
diff ./fft.f90 ../../../ffn2_tsvdw_master/CPV/fft.f90
9a10
> !  Last modified July 2009 by Paolo Giannozzi
11a13,205
> 
> 
> !-----------------------------------------------------------------------
>   subroutine invfft_x( grid_type, f, dfft, ia )
> !-----------------------------------------------------------------------
> ! grid_type = 'Dense'
> !   inverse fourier transform of potentials and charge density
> !   on the dense grid . On output, f is overwritten
> ! grid_type = 'Smooth'
> !   inverse fourier transform of  potentials and charge density
> !   on the smooth grid . On output, f is overwritten
> ! grid_type = 'Wave'
> !   inverse fourier transform of  wave functions
> !   on the smooth grid . On output, f is overwritten
> ! grid_type = 'Box'
> !   not-so-parallel 3d fft for box grid, implemented only for sign=1
> !   G-space to R-space, output = \sum_G f(G)exp(+iG*R)
> !   The array f (overwritten on output) is NOT distributed:
> !   a copy is present on each processor.
> !   The fft along z  is done on the entire grid.
> !   The fft along xy is done only on planes that have components on the
> !   dense grid for each processor. Note that the final array will no
> !   longer be the same on all processors.
> !
> 
> !
>       USE kinds,         ONLY: DP
>       use fft_base,      only: dfftp, dffts, dfftb
>       use fft_scalar,    only: cfft3d, cfft3ds, cft_b
>       use fft_parallel,  only: tg_cft3s
>       USE fft_types,     only: fft_dlay_descriptor
>       use mp_global,     only: use_task_groups
> 
>       IMPLICIT none
> 
>       TYPE(fft_dlay_descriptor), INTENT(IN) :: dfft
>       INTEGER, OPTIONAL, INTENT(IN) :: ia
>       CHARACTER(LEN=*), INTENT(IN) :: grid_type
>       COMPLEX(DP) :: f(:)
>       !
>       INTEGER :: imin3, imax3, np3
> 
>       IF( grid_type == 'Dense' ) THEN
>          IF( dfft%nr1  /= dfftp%nr1  .OR. dfft%nr2  /= dfftp%nr2  .OR. dfft%nr3  /= dfftp%nr3 .OR. &
>              dfft%nr1x /= dfftp%nr1x .OR. dfft%nr2x /= dfftp%nr2x .OR. dfft%nr3x /= dfftp%nr3x ) &
>             CALL errore( ' invfft ', ' inconsistent descriptor for Dense fft ' , 1 )
>          call start_clock( 'fft' )
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          IF( dfft%nr1  /= dffts%nr1  .OR. dfft%nr2  /= dffts%nr2  .OR. dfft%nr3  /= dffts%nr3 .OR. &
>              dfft%nr1x /= dffts%nr1x .OR. dfft%nr2x /= dffts%nr2x .OR. dfft%nr3x /= dffts%nr3x ) &
>             CALL errore( ' invfft ', ' inconsistent descriptor for Smooth fft ' , 1 )
>          call start_clock( 'ffts' )
>       ELSE IF( grid_type == 'Wave' ) THEN
>          IF( dfft%nr1  /= dffts%nr1  .OR. dfft%nr2  /= dffts%nr2  .OR. dfft%nr3  /= dffts%nr3 .OR. &
>              dfft%nr1x /= dffts%nr1x .OR. dfft%nr2x /= dffts%nr2x .OR. dfft%nr3x /= dffts%nr3x ) &
>             CALL errore( ' invfft ', ' inconsistent descriptor for Wave fft ' , 1 )
>          call start_clock('fftw')
>       ELSE IF( grid_type == 'Box' ) THEN
>          IF( dfft%nr1  /= dfftb%nr1  .OR. dfft%nr2  /= dfftb%nr2  .OR. dfft%nr3  /= dfftb%nr3 .OR. &
>              dfft%nr1x /= dfftb%nr1x .OR. dfft%nr2x /= dfftb%nr2x .OR. dfft%nr3x /= dfftb%nr3x ) &
>             CALL errore( ' invfft ', ' inconsistent descriptor for Box fft ' , 1 )
>          call start_clock( 'fftb' )
>       ELSE 
>          call errore( ' invfft ', ' unknown grid: '//grid_type , 1 )
>       END IF
> 
> #if defined __PARA && !defined __USE_3D_FFT
> 
>       IF( grid_type == 'Box' ) THEN
>          imin3 = dfftb%imin3( ia )
>          imax3 = dfftb%imax3( ia )
>          np3   = dfftb%np3( ia )   ! imax3 - imin3 + 1
>       END IF
>       
>       IF( grid_type == 'Dense' ) THEN
>          call tg_cft3s( f, dfftp, 1 )
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call tg_cft3s( f, dffts, 1 )
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call tg_cft3s( f, dffts, 2, use_task_groups )
>       ELSE IF( grid_type == 'Box' .AND. np3 > 0 ) THEN
>          call cft_b( f, dfftb%nr1, dfftb%nr2, dfftb%nr3, dfftb%nr1x, dfftb%nr2x, dfftb%nr3x, imin3, imax3, 1 )
>       END IF
> 
> #else
> 
>       IF( grid_type == 'Dense' ) THEN
>          call cfft3d( f, dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, dfftp%nr3x, 1)
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call cfft3d( f, dffts%nr1, dffts%nr2, dffts%nr3, dffts%nr1x, dffts%nr2x, dffts%nr3x, 1)
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call cfft3ds( f, dffts%nr1, dffts%nr2, dffts%nr3, dffts%nr1x, dffts%nr2x, dffts%nr3x, 1, dffts%isind, dffts%iplw )
>       ELSE IF( grid_type == 'Box' ) THEN
>          call cfft3d( f, dfftb%nr1, dfftb%nr2, dfftb%nr3, dfftb%nr1x, dfftb%nr2x, dfftb%nr3x, 1)
>       END IF
> 
> #endif
> 
>       IF( grid_type == 'Dense' ) THEN
>          call stop_clock( 'fft' )
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call stop_clock( 'ffts' )
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call stop_clock('fftw')
>       ELSE IF( grid_type == 'Box' ) THEN
>          call stop_clock( 'fftb' )
>       END IF
> !
>       return
>       end subroutine invfft_x
> 
> 
> 
> !-----------------------------------------------------------------------
>       subroutine fwfft_x( grid_type, f, dfft )
> !-----------------------------------------------------------------------
> ! grid_type = 'Dense'
> !   forward fourier transform of potentials and charge density 
> !   on the dense grid . On output, f is overwritten
> ! grid_type = 'Smooth'
> !   forward fourier transform of potentials and charge density
> !   on the smooth grid . On output, f is overwritten
> ! grid_type = 'Wave'
> !   forward fourier transform of  wave functions
> !   on the smooth grid . On output, f is overwritten
> ! 
>       USE kinds,         ONLY: DP
>       use fft_base,      only: dfftp, dffts
>       use fft_scalar,    only: cfft3d, cfft3ds
>       use fft_parallel,  only: tg_cft3s
>       USE fft_types,     only: fft_dlay_descriptor
>       use mp_global,     only: use_task_groups
> 
>       implicit none
> 
>       TYPE(fft_dlay_descriptor), INTENT(IN) :: dfft
>       CHARACTER(LEN=*), INTENT(IN) :: grid_type
>       COMPLEX(DP) :: f(:)
> 
>       IF( grid_type == 'Dense' ) THEN
>          IF( dfft%nr1  /= dfftp%nr1  .OR. dfft%nr2  /= dfftp%nr2  .OR. dfft%nr3  /= dfftp%nr3 .OR. &
>              dfft%nr1x /= dfftp%nr1x .OR. dfft%nr2x /= dfftp%nr2x .OR. dfft%nr3x /= dfftp%nr3x ) &
>             CALL errore( ' fwfft ', ' inconsistent descriptor for Dense fft ' , 1 )
>          call start_clock( 'fft' )
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          IF( dfft%nr1  /= dffts%nr1  .OR. dfft%nr2  /= dffts%nr2  .OR. dfft%nr3  /= dffts%nr3 .OR. &
>              dfft%nr1x /= dffts%nr1x .OR. dfft%nr2x /= dffts%nr2x .OR. dfft%nr3x /= dffts%nr3x ) &
>             CALL errore( ' fwfft ', ' inconsistent descriptor for Smooth fft ' , 1 )
>          call start_clock( 'ffts' )
>       ELSE IF( grid_type == 'Wave' ) THEN
>          IF( dfft%nr1  /= dffts%nr1  .OR. dfft%nr2  /= dffts%nr2  .OR. dfft%nr3  /= dffts%nr3 .OR. &
>              dfft%nr1x /= dffts%nr1x .OR. dfft%nr2x /= dffts%nr2x .OR. dfft%nr3x /= dffts%nr3x ) &
>             CALL errore( ' fwfft ', ' inconsistent descriptor for Wave fft ' , 1 )
>          call start_clock( 'fftw' )
>       ELSE
>          call errore( ' fwfft ', ' unknown grid: '//grid_type , 1 )
>       END IF
> 
> #if defined __PARA && !defined __USE_3D_FFT
> 
>       IF( grid_type == 'Dense' ) THEN
>          call tg_cft3s(f,dfftp,-1)
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call tg_cft3s(f,dffts,-1)
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call tg_cft3s(f,dffts,-2, use_task_groups )
>       END IF
> 
> #else 
> 
>       IF( grid_type == 'Dense' ) THEN
>          call cfft3d( f, dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, dfftp%nr3x, -1)
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call cfft3d( f, dffts%nr1, dffts%nr2, dffts%nr3, dffts%nr1x, dffts%nr2x, dffts%nr3x, -1)
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call cfft3ds( f, dffts%nr1, dffts%nr2, dffts%nr3, dffts%nr1x, dffts%nr2x, dffts%nr3x, -1, dffts%isind, dffts%iplw )
>       END IF
> 
> #endif
> 
>       IF( grid_type == 'Dense' ) THEN
>          call stop_clock( 'fft' )
>       ELSE IF( grid_type == 'Smooth' ) THEN
>          call stop_clock( 'ffts' )
>       ELSE IF( grid_type == 'Wave' ) THEN
>          call stop_clock( 'fftw' )
>       END IF
> 
>       return
>       end subroutine fwfft_x
> 
> 
> 
17c211
<        use gvecs, only: nlsm, nls
---
>        use gvecs, only: nms, nps
47c241
<                psi( nls( ig ) ) = c( ig )
---
>                psi( nps( ig ) ) = c( ig )
53,54c247,248
<                psi( nlsm( ig ) ) = CONJG( c( ig ) )
<                psi( nls( ig ) ) = c( ig )
---
>                psi( nms( ig ) ) = CONJG( c( ig ) )
>                psi( nps( ig ) ) = c( ig )
60,61c254,255
<                psi( nlsm( ig ) ) = CONJG( c( ig ) ) + ci * conjg( ca( ig ) )
<                psi( nls( ig ) ) = c( ig ) + ci * ca( ig )
---
>                psi( nms( ig ) ) = CONJG( c( ig ) ) + ci * conjg( ca( ig ) )
>                psi( nps( ig ) ) = c( ig ) + ci * ca( ig )
79,80c273,274
<        use gvect, only: nlm, nl
<        use gvecs, only: nlsm, nls
---
>        use recvecs_indexes, only: nm, np
>        use gvecs, only: nms, nps
101c295
<              !   psi( nls( ig ) ) = rho( ig )
---
>              !   psi( nps( ig ) ) = rho( ig )
105,106c299,300
<                psi( nlsm( ig ) ) = CONJG( rho( ig ) )
<                psi( nls( ig ) ) = rho( ig )
---
>                psi( nms( ig ) ) = CONJG( rho( ig ) )
>                psi( nps( ig ) ) = rho( ig )
116,117c310,311
<                psi( nlm( ig ) ) = CONJG( rho( ig ) )
<                psi( nl( ig ) ) = rho( ig )
---
>                psi( nm( ig ) ) = CONJG( rho( ig ) )
>                psi( np( ig ) ) = rho( ig )
133,134c327,328
<        use gvect, only: nlm, nl
<        use gvecs, only: nlsm, nls
---
>        use recvecs_indexes, only: nm, np
>        use gvecs, only: nms, nps
163c357
<                c( ig ) = psi( nls( ig ) )
---
>                c( ig ) = psi( nps( ig ) )
173,174c367,368
<                ca(ig) = psi( nlsm( ig ) )
<                c (ig) = psi( nls( ig ) )
---
>                ca(ig) = psi( nms( ig ) )
>                c (ig) = psi( nps( ig ) )
183c377
<                c( ig ) = psi( nl( ig ) )
---
>                c( ig ) = psi( np( ig ) )
193,194c387,388
<                ca(ig) = psi( nlm( ig ) )
<                c (ig) = psi( nl( ig ) )
---
>                ca(ig) = psi( nm( ig ) )
>                c (ig) = psi( np( ig ) )
210,211c404,405
<        use gvect, only: nlm, nl
<        use gvecs, only: nlsm, nls
---
>        use recvecs_indexes, only: nm, np
>        use gvecs, only: nms, nps
227c421
<                 rho( ig ) = psi( nls( ig ) )
---
>                 rho( ig ) = psi( nps( ig ) )
233c427
<                rho( ig ) = psi( nl( ig ) )
---
>                rho( ig ) = psi( np( ig ) )
256,258c450,455
<       USE kinds, ONLY: dp
<       USE fft_base, ONLY: dfftp, dfftb
<       USE mp_global, ONLY: me_bgrp
---
>       USE grid_dimensions, ONLY: nr1, nr2, nr3, &
>             nr1x, nr2x, nnr => nnrx
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, &
>             nr1bx, nr2bx, nnrb => nnrbx
>       USE fft_base, ONLY: dfftp
>       USE mp_global, ONLY: me_image
262,263c459,460
<       REAL(dp), INTENT(in):: qv(2,dfftb%nnr)
<       COMPLEX(dp), INTENT(inout):: vr(dfftp%nnr)
---
>       REAL(8), INTENT(in):: qv(2,nnrb)
>       COMPLEX(8), INTENT(inout):: vr(nnr)
270c467
<       me = me_bgrp + 1
---
>       me = me_image + 1
272c469
<       DO ir3=1,dfftb%nr3
---
>       DO ir3=1,nr3b
274,275c471,472
<          ibig3=1+MOD(ibig3-1,dfftp%nr3)
<          IF(ibig3.LT.1.OR.ibig3.GT.dfftp%nr3)                                 &
---
>          ibig3=1+MOD(ibig3-1,nr3)
>          IF(ibig3.LT.1.OR.ibig3.GT.nr3)                                 &
279c476
<             DO ir2=1,dfftb%nr2
---
>             DO ir2=1,nr2b
281,282c478,479
<                ibig2=1+MOD(ibig2-1,dfftp%nr2)
<                IF(ibig2.LT.1.OR.ibig2.GT.dfftp%nr2)                           &
---
>                ibig2=1+MOD(ibig2-1,nr2)
>                IF(ibig2.LT.1.OR.ibig2.GT.nr2)                           &
284c481
<                DO ir1=1,dfftb%nr1
---
>                DO ir1=1,nr1b
286,287c483,484
<                   ibig1=1+MOD(ibig1-1,dfftp%nr1)
<                   IF(ibig1.LT.1.OR.ibig1.GT.dfftp%nr1)                        &
---
>                   ibig1=1+MOD(ibig1-1,nr1)
>                   IF(ibig1.LT.1.OR.ibig1.GT.nr1)                        &
289,291c486,487
<                   ibig=ibig1+(ibig2-1)*dfftp%nr1x+(ibig3-1)*dfftp%nr1x*dfftp%nr2x
<                   ir=ir1+(ir2-1)*dfftb%nr1x+(ir3-1)*dfftb%nr1x*dfftb%nr2x
< !$omp critical
---
>                   ibig=ibig1+(ibig2-1)*nr1x+(ibig3-1)*nr1x*nr2x
>                   ir=ir1+(ir2-1)*nr1bx+(ir3-1)*nr1bx*nr2bx
293d488
< !$omp end critical
310,312c505,510
<       USE kinds, ONLY: dp
<       USE fft_base, ONLY: dfftp, dfftb
<       USE mp_global, ONLY: me_bgrp
---
>       USE grid_dimensions, ONLY: nr1, nr2, nr3, &
>             nr1x, nr2x, nnr => nnrx
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, &
>             nr1bx, nr2bx, nnrb => nnrbx
>       USE fft_base, ONLY: dfftp
>       USE mp_global, ONLY: me_image
317,318c515,516
<       COMPLEX(dp), INTENT(in):: qv(dfftb%nnr)
<       COMPLEX(dp), INTENT(inout):: v(dfftp%nnr)
---
>       COMPLEX(8), INTENT(in):: qv(nnrb)
>       COMPLEX(8), INTENT(inout):: v(nnr)
323c521
<       me = me_bgrp + 1
---
>       me = me_image + 1
325c523
<       DO ir3=1,dfftb%nr3
---
>       DO ir3=1,nr3b
327,328c525,526
<          ibig3=1+MOD(ibig3-1,dfftp%nr3)
<          IF(ibig3.LT.1.OR.ibig3.GT.dfftp%nr3)                                 &
---
>          ibig3=1+MOD(ibig3-1,nr3)
>          IF(ibig3.LT.1.OR.ibig3.GT.nr3)                                 &
332c530
<             DO ir2=1,dfftb%nr2
---
>             DO ir2=1,nr2b
334,335c532,533
<                ibig2=1+MOD(ibig2-1,dfftp%nr2)
<                IF(ibig2.LT.1.OR.ibig2.GT.dfftp%nr2)                           &
---
>                ibig2=1+MOD(ibig2-1,nr2)
>                IF(ibig2.LT.1.OR.ibig2.GT.nr2)                           &
337c535
<                DO ir1=1,dfftb%nr1
---
>                DO ir1=1,nr1b
339,340c537,538
<                   ibig1=1+MOD(ibig1-1,dfftp%nr1)
<                   IF(ibig1.LT.1.OR.ibig1.GT.dfftp%nr1)                        &
---
>                   ibig1=1+MOD(ibig1-1,nr1)
>                   IF(ibig1.LT.1.OR.ibig1.GT.nr1)                        &
342,343c540,541
<                   ibig=ibig1+(ibig2-1)*dfftp%nr1x+(ibig3-1)*dfftp%nr1x*dfftp%nr2x
<                   ir=ir1+(ir2-1)*dfftb%nr1x+(ir3-1)*dfftb%nr1x*dfftb%nr2x
---
>                   ibig=ibig1+(ibig2-1)*nr1x+(ibig3-1)*nr1x*nr2x
>                   ir=ir1+(ir2-1)*nr1bx+(ir3-1)*nr1bx*nr2bx
364,366c562,567
<       USE kinds, ONLY: dp
<       USE fft_base, ONLY: dfftp, dfftb
<       USE mp_global, ONLY: me_bgrp
---
>       USE grid_dimensions, ONLY: nr1, nr2, nr3, &
>             nr1x, nr2x, nnr => nnrx
>       USE smallbox_grid_dimensions, ONLY: nr1b, nr2b, nr3b, &
>             nr1bx, nr2bx, nnrb => nnrbx
>       USE fft_base, ONLY: dfftp
>       USE mp_global, ONLY: me_image
369c570
<       REAL(dp), INTENT(in):: qv(2,dfftb%nnr), vr(dfftp%nnr)
---
>       REAL(8), INTENT(in):: qv(2,nnrb), vr(nnr)
377c578
<       me = me_bgrp + 1
---
>       me = me_image + 1
381c582
<       DO ir3=1,dfftb%nr3
---
>       DO ir3=1,nr3b
383c584
<          ibig3=1+MOD(ibig3-1,dfftp%nr3)
---
>          ibig3=1+MOD(ibig3-1,nr3)
386c587
<             DO ir2=1,dfftb%nr2
---
>             DO ir2=1,nr2b
388,389c589,590
<                ibig2=1+MOD(ibig2-1,dfftp%nr2)
<                DO ir1=1,dfftb%nr1
---
>                ibig2=1+MOD(ibig2-1,nr2)
>                DO ir1=1,nr1b
391,393c592,594
<                   ibig1=1+MOD(ibig1-1,dfftp%nr1)
<                   ibig=ibig1 + (ibig2-1)*dfftp%nr1x + (ibig3-1)*dfftp%nr1x*dfftp%nr2x
<                   ir  =ir1 + (ir2-1)*dfftb%nr1x + (ir3-1)*dfftb%nr1x*dfftb%nr2x
---
>                   ibig1=1+MOD(ibig1-1,nr1)
>                   ibig=ibig1 + (ibig2-1)*nr1x + (ibig3-1)*nr1x*nr2x
>                   ir  =ir1 + (ir2-1)*nr1bx + (ir3-1)*nr1bx*nr2bx
412c613
<       use mp_global, only: me_bgrp
---
>       use mp_global, only: me_image
421c622
<       me = me_bgrp + 1
---
>       me = me_image + 1
Only in ../../../ffn2_tsvdw_master/CPV: fft.F90
Only in ../../../ffn2_tsvdw_master/CPV: fft.o
diff ./forces.f90 ../../../ffn2_tsvdw_master/CPV/forces.f90
11a12,15
> 
> 
> 
> !
25,26c29,31
<       USE control_flags,          ONLY: iprint
<       USE gvecs,                  ONLY: nlsm, nls
---
>       USE control_flags,          ONLY: iprint, lwfpbe0, lwfpbe0nscf   ! changed by Lingzhu Kong
>       USE gvecs,                  ONLY: nms, nps
>       USE cvan,                   ONLY: ish
28c33,35
<       USE uspp_param,             ONLY: nhm, nh, ish
---
>       USE uspp_param,             ONLY: nhm, nh
>       USE smooth_grid_dimensions, ONLY: nr1s, nr2s, nr3s, &
>                                         nr1sx, nr2sx, nr3sx, nnrsx
34d40
<       USE funct,                  ONLY: dft_is_meta
36,39c42,46
<       USE fft_interfaces,         ONLY: fwfft, invfft
<       USE mp_global,              ONLY: me_bgrp
<       USE control_flags,          ONLY: lwfpbe0, lwfpbe0nscf  ! Lingzhu Kong
<       USE cp_main_variables,      ONLY: exx_potential         ! Lingzhu Kong
---
>       USE funct,                  ONLY: dft_is_meta
>       USE cp_interfaces,          ONLY: fwfft, invfft
>       USE mp_global,              ONLY: nogrp, me_image, ogrp_comm, &
>                                         use_task_groups
>       USE cp_main_variables,      ONLY: vpsig=>exx_potential   
54a62
>       !
60a69
>       REAL(DP)    :: tmp1, tmp2                                 ! Lingzhu Kong
64,65c73
<       REAL(DP)    :: tmp1, tmp2                      ! Lingzhu Kong
<       REAL(DP),    ALLOCATABLE :: exx_a(:), exx_b(:) ! Lingzhu Kong      
---
>       REAL(DP),    ALLOCATABLE :: exx_a(:), exx_b(:)       
72,73c80,83
<          allocate( exx_a( dffts%nnr ) )
<          allocate( exx_b( dffts%nnr ) )
---
>          allocate( exx_a( nnrsx ) )
>          allocate( exx_b( nnrsx ) )
>          exx_a = 0.d0
>          exx_b = 0.d0
76,78c86,88
<       IF( dffts%have_task_groups ) THEN
<          nogrp_ = dffts%nogrp
<          ALLOCATE( psi( dffts%tg_nnr * dffts%nogrp ) )
---
>       IF( use_task_groups ) THEN
>          nogrp_ = nogrp
>          ALLOCATE( psi( dffts%nnrx * nogrp ) )
81c91
<          ALLOCATE( psi( dffts%nnr ) )
---
>          ALLOCATE( psi( nnrsx ) )
106,107c116,117
<                psi(nlsm(ig)+igoff) = conjg( c(ig,idx+i-1) - ci * c(ig,idx+i) )
<                psi(nls(ig)+igoff) =        c(ig,idx+i-1) + ci * c(ig,idx+i)
---
>                psi(nms(ig)+igoff) = conjg( c(ig,idx+i-1) - ci * c(ig,idx+i) )
>                psi(nps(ig)+igoff) =        c(ig,idx+i-1) + ci * c(ig,idx+i)
111c121
<          igoff = igoff + dffts%tg_nnr
---
>          igoff = igoff + dffts%nnrx
127c137
<       IF( dffts%have_task_groups ) THEN
---
>       IF( use_task_groups ) THEN
129,131d138
< !===============================================================================
<          !Lingzhu Kong
<          IF( lwfpbe0 .or. lwfpbe0nscf )THEN
133,146c140
<             DO ir = 1, dffts%nr1x*dffts%nr2x*dffts%tg_npp( me_bgrp + 1 )
<                tmp1 = v(ir,iss1) * DBLE( psi(ir) )+exx_potential(ir,i/nogrp_+1)
<                tmp2 = v(ir,iss2) * AIMAG(psi(ir) )+exx_potential(ir,i/nogrp_+2)
<                psi(ir) = CMPLX( tmp1, tmp2, kind=DP)
<             END DO
< !$omp end parallel do 
<          ELSE
< !$omp parallel do 
<             DO ir = 1, dffts%nr1x*dffts%nr2x*dffts%tg_npp( me_bgrp + 1 )
<                psi(ir) = CMPLX ( v(ir,iss1) * DBLE( psi(ir) ), &
<                                  v(ir,iss2) *AIMAG( psi(ir) ) ,kind=DP)
<             END DO
< !$omp end parallel do 
<          ENDIF
---
>          DO ir = 1, nr1sx * nr2sx * dffts%tg_npp( me_image + 1 )
147a142,153
> !Lingzhu Kong
>             write(6,*)'task_groups is not implemented for pbe0 '
>             STOP
> !           tmp1 = v(ir,iss1) * DBLE( psi(ir) )+vpsig(ir,i/nogrp+1)
> !           tmp2 = v(ir,iss2) * AIMAG(psi(ir) )+vpsig(ir,i/nogrp+2)
> !           psi(ir) = CMPLX( tmp1, tmp2, kind=DP)
> 
>             psi(ir) = CMPLX ( v(ir,iss1) * DBLE( psi(ir) ), &
>                               v(ir,iss2) *AIMAG( psi(ir) ) ,kind=DP)
> !===============================================================================
>          END DO
> !$omp end parallel do 
151a158
> !$omp parallel do 
156,157c163,166
<                   exx_a(:) = exx_potential(:, n)
<                   exx_b(:) = 0.0d0
---
>                   DO ir = 1, nr1sx * nr2sx * dffts%npp( me_image + 1 )
>                      exx_a(ir) = vpsig(ir,i)
>                      exx_b(ir) = 0.0d0
>                   ENDDO
159,160c168,171
<                   exx_a(:) = exx_potential(:, i)
<                   exx_b(:) = exx_potential(:, i+1)
---
>                   DO ir = 1, nr1sx * nr2sx * dffts%npp( me_image + 1 )
>                      exx_a(ir) = vpsig( ir, i )
>                      exx_b(ir) = vpsig( ir, i + 1)
>                   ENDDO
162,163c173,174
< !$omp parallel do 
<                DO ir=1,dffts%nnr
---
> 
>                DO ir=1,nnrsx
168d178
< !$omp end parallel do 
170,173c180,181
< !$omp parallel do 
<                DO ir=1,dffts%nnr
<                   psi(ir)=CMPLX ( v(ir,iss1)* DBLE(psi(ir)), &
<                                  v1(ir,iss2)*AIMAG(psi(ir)) ,kind=DP)
---
>                DO ir=1,nnrsx
>                   psi(ir)=CMPLX(v(ir,iss1)* DBLE(psi(ir)), v1(ir,iss2)*AIMAG(psi(ir)), kind=DP)
175d182
< !$omp end parallel do 
176a184,189
> !           DO ir=1,nnrsx
> !              psi(ir)=CMPLX ( v(ir,iss1)* DBLE(psi(ir)), &
> !                             v1(ir,iss2)*AIMAG(psi(ir)) ,kind=DP)
> !           END DO
> !===============================================================================
> !$omp end parallel do 
179,182c192,223
<             DO ir=1,dffts%nnr
<                psi(ir)=CMPLX( v(ir,iss1)* DBLE(psi(ir)), &
<                               v(ir,iss2)*AIMAG(psi(ir)) ,kind=DP)
<             END DO
---
> !===============================================================================
> !Lingzhu Kong
>             IF( lwfpbe0 .or. lwfpbe0nscf )then
>                IF ( (mod(n,2).ne.0 ) .and. (i.eq.n) ) THEN
>                   DO ir = 1, nr1sx * nr2sx * dffts%npp( me_image + 1 )
>                      exx_a(ir) = vpsig(ir, i)
>                      exx_b(ir) = 0.0d0
>                   ENDDO
>                ELSE
>                   DO ir = 1, nr1sx * nr2sx * dffts%npp( me_image + 1 )
>                      exx_a(ir) = vpsig( ir, i)
>                      exx_b(ir) = vpsig( ir, i+1)
>                   ENDDO
>                ENDIF
> 
>                DO ir=1,nnrsx
>                   tmp1 = v(ir,iss1)* DBLE(psi(ir))+exx_a(ir)
>                   tmp2 = v(ir,iss2)*AIMAG(psi(ir))+exx_b(ir)
>                   psi(ir)=CMPLX( tmp1, tmp2, kind=DP )
>                END DO
> 
>             ELSE
>                DO ir=1,nnrsx
>                   psi(ir)=CMPLX(v(ir,iss1)* DBLE(psi(ir)), v(ir,iss2)*AIMAG(psi(ir)), kind=DP )
>                END DO
>             ENDIF
> 
> !           DO ir=1,nnrsx
> !              psi(ir)=CMPLX( v(ir,iss1)* DBLE(psi(ir)), &
> !                             v(ir,iss2)*AIMAG(psi(ir)) ,kind=DP)
> !           END DO
> !===============================================================================
197,201d237
< !$omp parallel default(none) &
< !$omp          private( eig_offset, igno, fi, fip, idx, fp, fm, ig ) &
< !$omp          shared( nogrp_ , f, ngw, psi, df, da, c, tpiba2, tens, dffts, me_bgrp, &
< !$omp                  i, n, ggp, nls, nlsm )
< 
215,216c251,252
<             IF( dffts%have_task_groups ) THEN
< !$omp do 
---
>             IF( use_task_groups ) THEN
> !$omp parallel do private( fp, fm )
218,219c254,255
<                   fp= psi(nls(ig)+eig_offset) +  psi(nlsm(ig)+eig_offset)
<                   fm= psi(nls(ig)+eig_offset) -  psi(nlsm(ig)+eig_offset)
---
>                   fp= psi(nps(ig)+eig_offset) +  psi(nms(ig)+eig_offset)
>                   fm= psi(nps(ig)+eig_offset) -  psi(nms(ig)+eig_offset)
225c261
< !$omp end do
---
> !$omp end parallel do
228c264
< !$omp do 
---
> !$omp parallel do private( fp, fm )
230,231c266,267
<                   fp= psi(nls(ig)) + psi(nlsm(ig))
<                   fm= psi(nls(ig)) - psi(nlsm(ig))
---
>                   fp= psi(nps(ig)) + psi(nms(ig))
>                   fm= psi(nps(ig)) - psi(nms(ig))
235c271
< !$omp end do
---
> !$omp end parallel do
239c275
<          eig_offset = eig_offset + dffts%nr3x * dffts%nsw(me_bgrp+1)
---
>          eig_offset = eig_offset + nr3sx * dffts%nsw(me_image+1)
245d280
< !$omp end parallel 
261,264d295
< !$omp parallel default(none) &
< !$omp          private(iv,jv,ivoff,jvoff,dd,dv,inl,jnl,is,isa,ism,igrp,idx,fi,fip) &
< !$omp          shared( nogrp_ , f, ngw, deeq, bec, af, aa, i, n, nsp, na, nh, dvan, tens, ish, iss1, iss2 )
<          !
278a310,311
> !$omp parallel default(shared), private(iv,jv,ivoff,jvoff,dd,dv,inl,jnl,is,isa,ism)
>                !
311a345,346
> !$omp end parallel
>       
317,318d351
< 
< !$omp end parallel
327,328c360
< !
<       if (lwfpbe0 .or. lwfpbe0nscf) DEALLOCATE(exx_a, exx_b) ! Lingzhu Kong
---
> 
329a362,368
> 
> !==================================================
> !Lingzhu Kong
>       if(lwfpbe0 .or. lwfpbe0nscf)then
>           DEALLOCATE(exx_a, exx_b)
>       end if
> !==================================================
Only in ../../../ffn2_tsvdw_master/CPV: forces.F90
Only in ../../../ffn2_tsvdw_master/CPV: forces_good.f90
Only in ../../../ffn2_tsvdw_master/CPV: forces.o
diff ./fpmdpp.f90 ../../../ffn2_tsvdw_master/CPV/fpmdpp.f90
30c30
<   USE mp,            ONLY : mp_start
---
>   USE mp,            ONLY : mp_start, mp_env
81,82c81,83
<   !  initialize mpi
<   CALL mp_start( nproc, mpime, world )
---
>   !  see cprstart.f90 for the meaning of the following 4 calls
>   CALL mp_start()
>   CALL mp_env( nproc, mpime, world )
172d172
< 
173a174,175
> 
>      !CALL iotk_scan_begin( dunit, "IONS", FOUND = found )
Only in ../../../ffn2_tsvdw_master/CPV: fpmdpp.F90
Only in ../../../ffn2_tsvdw_master/CPV: fpmdpp.o
diff ./fromscra.f90 ../../../ffn2_tsvdw_master/CPV/fromscra.f90
12c12
<     USE control_flags,        ONLY : tranp, trane, iverbosity, tpre, tcarpar,  &
---
>     USE control_flags,        ONLY : tranp, trane, iprsta, tpre, tcarpar,  &
18,19c18,19
<     USE ions_base,            ONLY : na, nsp, randpos, zv, ions_vel
<     USE ions_base,            ONLY : cdmi, nat, iforce
---
>     USE ions_base,            ONLY : na, nsp, randpos, zv, ions_vel, pmass
>     USE ions_base,            ONLY : taui, cdmi, nat, iforce
23c23,24
<                                      cell_force, velh, at, alat
---
>                                      cell_force, boxdimensions, velh, a1,  &
>                                      a2, a3, b1, b2, b3
26,27c27,28
<     use electrons_base,       ONLY : nbsp, f, nspin, nupdwn, iupdwn, nbsp_bgrp, nbspx_bgrp, nbspx
<     USE electrons_module,     ONLY : occn_info, distribute_c, collect_c, distribute_b, collect_b
---
>     use electrons_base,       ONLY : nbsp, f, nspin, nupdwn, iupdwn
>     USE electrons_module,     ONLY : occn_info
31c32
<     USE uspp,                 ONLY : vkb, becsum, deeq, nkb, okvan, nlcc_any
---
>     USE uspp,                 ONLY : vkb, becsum, deeq, nkb, okvan
33c34
<     USE core,                 ONLY : rhoc
---
>     USE core,                 ONLY : nlcc_any, rhoc
35,38c36,39
<     USE gvecs,                ONLY : ngms
<     USE gvect,                ONLY : ngm, gg
<     USE gvect,                ONLY : gstart, mill, eigts1, eigts2, eigts3
<     USE uspp_param,           ONLY : nvb
---
>     USE gvecs,                ONLY : ngs
>     USE gvecp,                ONLY : ngm
>     USE reciprocal_vectors,   ONLY : gstart, mill_l, gx
>     USE cvan,                 ONLY : nvb
45c46
<                                      strucf, phfacs, nlfh, vofrho, nlfl_bgrp, prefor
---
>                                      strucf, phfacs, nlfh
47,48c48,49
<     USE cp_interfaces,        ONLY : compute_stress, dotcsc, calbec_bgrp, caldbec_bgrp
<     USE cp_interfaces,        ONLY : print_lambda, nlfq_bgrp, setval_lambda
---
>     USE cp_interfaces,        ONLY : compute_stress
>     USE cp_interfaces,        ONLY : print_lambda
50c51
<     USE orthogonalize_base,   ONLY : updatc, calphi_bgrp
---
>     USE orthogonalize_base,   ONLY : updatc, calphi
53,54c54,55
<     USE wavefunctions_module, ONLY : c0_bgrp, cm_bgrp, phi_bgrp
<     USE fft_base,             ONLY : dfftp
---
>     USE wavefunctions_module, ONLY : c0, cm, phi => cp
>     USE grid_dimensions,      ONLY : nr1, nr2, nr3
56,57c57,58
<     USE cp_main_variables,    ONLY : descla, bephi, becp_bgrp, nfi, &
<                                      sfac, eigr, taub, irb, eigrb, bec_bgrp, &
---
>     USE cp_main_variables,    ONLY : setval_lambda, descla, bephi, becp, becdr, nfi, &
>                                      sfac, eigr, ei1, ei2, ei3, bec, taub, irb, eigrb, &
59,61c60,63
<                                      vpot, ht0, edft, becdr_bgrp, dbec, drhor, drhog
<     USE mp_global,            ONLY : np_ortho, me_ortho, ortho_comm, mpime, inter_bgrp_comm, nbgrp
<     USE mp,                   ONLY : mp_sum
---
>                                      vpot, ht0, edft, nlax
>     USE mp_global,            ONLY : np_ortho, me_ortho, ortho_comm
>     USE small_box,            ONLY : ainvb
>     USE cdvan,                ONLY : dbec
65a68
>     COMPLEX(DP), ALLOCATABLE :: c2(:), c3(:)
109c112
<     CALL phfacs( eigts1, eigts2, eigts3, eigr, mill, atoms0%taus, dfftp%nr1, dfftp%nr2, dfftp%nr3, atoms0%nat )
---
>     CALL phfacs( ei1, ei2, ei3, eigr, mill_l, atoms0%taus, nr1, nr2, nr3, atoms0%nat )
111c114
<     CALL strucf( sfac, eigts1, eigts2, eigts3, mill, ngms )
---
>     CALL strucf( sfac, ei1, ei2, ei3, mill_l, ngs )
114,115c117,118
<        CALL initbox ( tau0, alat, at, ainv, taub, irb )
<        CALL phbox( taub, iverbosity, eigrb )
---
>        CALL initbox ( tau0, taub, irb, ainv, a1, a2, a3 )
>        CALL phbox( taub, eigrb, ainvb )
120c123
<     CALL wave_rand_init( cm_bgrp )
---
>     CALL wave_rand_init( cm, nbsp, 1 )
132c135,139
<     CALL gram_bgrp( vkb, bec_bgrp, nkb, cm_bgrp, ngw )
---
>     DO iss = 1, nspin_wfc
>        !
>        CALL gram( vkb, bec, nkb, cm(1,iupdwn(iss)), ngw, nupdwn(iss) )
>        !
>     END DO
134c141
<     IF( force_pairing ) cm_bgrp(:,iupdwn(2):iupdwn(2)+nupdwn(2)-1) = cm_bgrp(:,1:nupdwn(2))
---
>     IF( force_pairing ) cm(:,iupdwn(2):iupdwn(2)+nupdwn(2)-1) = cm(:,1:nupdwn(2))
136c143
<     if( iverbosity > 2 ) CALL dotcsc( eigr, cm_bgrp, ngw, nbsp )
---
>     if( iprsta >= 3 ) CALL dotcsc( eigr, cm, ngw, nbsp )
153a161
> 
163c171
<        CALL calbec_bgrp ( 1, nsp, eigr, cm_bgrp, bec_bgrp )
---
>        CALL calbec ( 1, nsp, eigr, cm, bec )
165c173
<        if ( tstress ) CALL caldbec_bgrp( eigr, cm_bgrp, dbec, descla )
---
>        if ( tstress ) CALL caldbec( ngw, nkb, nbsp, 1, nsp, eigr, cm, dbec )
167c175
<        CALL rhoofr( nfi, cm_bgrp, irb, eigrb, bec_bgrp, dbec, becsum, rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin6 )
---
>        CALL rhoofr ( nfi, cm(:,:), irb, eigrb, bec, becsum, rhor, rhog, rhos, enl, denl, ekin, dekin6 )
178c186,187
<     IF( .NOT. tcg ) THEN
---
> 
>        IF( .NOT. tcg ) THEN
180,197c189,197
<       IF( tens ) THEN
<         CALL compute_entropy( entropy, f(1), nspin )
<         entropy = entropy * nbsp
<       END IF
<       !
<       vpot = rhor
<       !
<       CALL vofrho( nfi, vpot, drhor, rhog, drhog, rhos, rhoc, tfirst, tlast, &
<      &  eigts1, eigts2, eigts3, irb, eigrb, sfac, tau0, fion )
< 
<       IF( tefield ) THEN
<         CALL berry_energy( enb, enbi, bec_bgrp, cm_bgrp, fion ) 
<         etot = etot + enb + enbi
<       END IF
<       IF( tefield2 ) THEN
<         CALL berry_energy2( enb, enbi, bec_bgrp, cm_bgrp, fion )
<         etot = etot + enb + enbi
<       END IF
---
>          IF( tens ) THEN
>            CALL compute_entropy( entropy, f(1), nspin )
>            entropy = entropy * nbsp
>          END IF
>          !
>          vpot = rhor
>          !
>          CALL vofrho( nfi, vpot, rhog, rhos, rhoc, tfirst, tlast, &
>         &  ei1, ei2, ei3, irb, eigrb, sfac, tau0, fion )
199c199,206
<       CALL compute_stress( stress, detot, h, omega )
---
>          IF( tefield ) THEN
>            CALL berry_energy( enb, enbi, bec, cm(:,:), fion ) 
>            etot = etot + enb + enbi
>          END IF
>          IF( tefield2 ) THEN
>            CALL berry_energy2( enb, enbi, bec, cm(:,:), fion )
>            etot = etot + enb + enbi
>          END IF
201c208,210
<       if( iverbosity > 2 ) &
---
>          CALL compute_stress( stress, detot, h, omega )
> 
>          if(iprsta.gt.2) &
204,291c213,303
<       CALL newd( vpot, irb, eigrb, becsum, fion )
<       !
<       IF( force_pairing ) THEN
<          !
<          CALL runcp_uspp_force_pairing( nfi, fccc, ccc, ema0bg, dt2bye, rhos,&
<                     bec_bgrp, cm_bgrp, c0_bgrp, ei_unp, fromscra = .TRUE. )
<          !
<          CALL setval_lambda( lambda(:,:,2), nupdwn(1), nupdwn(1), 0.d0, descla(1) )
<          !
<       ELSE
<          !
<          CALL runcp_uspp( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec_bgrp, cm_bgrp, c0_bgrp, fromscra = .TRUE. )
<          !
<       ENDIF
<       !
<       !     nlfq needs deeq bec
<       !
<       IF( ttforce ) THEN
<          CALL nlfq_bgrp( cm_bgrp, eigr, bec_bgrp, becdr_bgrp, fion )
<       END IF
<       !
<       !     calphi calculates phi
<       !     the electron mass rises with g**2
<       !
<       CALL calphi_bgrp( cm_bgrp, ngw, bec_bgrp, nkb, vkb, phi_bgrp, nbspx_bgrp, ema0bg )
<       !
<       IF( force_pairing ) &
<          &   phi_bgrp( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) =    phi_bgrp( :, 1:nupdwn(2))
< 
<       if( tortho ) then
<          CALL ortho( eigr, c0_bgrp, phi_bgrp, lambda, descla, bigr, iter, ccc, bephi, becp_bgrp )
<       else
<          CALL gram_bgrp( vkb, bec_bgrp, nkb, c0_bgrp, ngw )
<       endif
<       !
<       IF ( ttforce ) THEN
<          CALL nlfl_bgrp( bec_bgrp, becdr_bgrp, lambda, descla, fion )
<       END IF
< 
<       if ( iverbosity > 2 ) CALL print_lambda( lambda, descla, nbsp, 9, ccc )
< 
<       !
<       if ( tstress ) CALL nlfh( stress, bec_bgrp, dbec, lambda, descla )
<       !
<       IF ( tortho ) THEN
<          CALL updatc( ccc, lambda, phi_bgrp, bephi, becp_bgrp, bec_bgrp, c0_bgrp, descla )
<       END IF
<       !
<       IF( force_pairing ) THEN
<          !
<          c0_bgrp ( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) = c0_bgrp( :, 1:nupdwn(2))
<          phi_bgrp( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) = phi_bgrp( :, 1:nupdwn(2))
<          lambda(:,:,2) = lambda(:,:,1)
<          !
<       ENDIF
<       !
<       !
<       CALL calbec_bgrp ( nvb+1, nsp, eigr, c0_bgrp, bec_bgrp )
<       !
<       if ( tstress ) CALL caldbec_bgrp( eigr, cm_bgrp, dbec, descla )
< 
<       if ( iverbosity > 2 ) CALL dotcsc( eigr, c0_bgrp, ngw, nbsp_bgrp )
<       !
<       xnhp0 = 0.0d0
<       xnhpm = 0.0d0
<       vnhp  = 0.0d0
<       fionm = 0.0d0
<       !
<       CALL ions_vel( vels, taus, tausm, na, nsp, delt )
<       !
<       xnhh0(:,:) = 0.0d0
<       xnhhm(:,:) = 0.0d0
<       vnhh (:,:) = 0.0d0
<       velh (:,:) = ( h(:,:) - hold(:,:) ) / delt
<       !
<       CALL elec_fakekine( ekincm, ema0bg, emass, c0_bgrp, cm_bgrp, ngw, nbsp_bgrp, 1, delt )
< 
<       xnhe0 = 0.0d0
<       xnhem = 0.0d0
<       vnhe  = 0.0d0
< 
<       lambdam = lambda
<       !
<     ELSE 
<        !
<        c0_bgrp = cm_bgrp
<        !
<     END IF
---
>          CALL newd( vpot, irb, eigrb, becsum, fion )
>          !
>          IF( force_pairing ) THEN
>             !
>             CALL runcp_uspp_force_pairing( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec, cm, &
>         &                 c0, ei_unp, fromscra = .TRUE. )
>             !
>             CALL setval_lambda( lambda(:,:,2), nupdwn(1), nupdwn(1), 0.d0, descla(:,1) )
>             !
>          ELSE
>             !
>             CALL runcp_uspp( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec, cm, c0, fromscra = .TRUE. )
>             !
>          ENDIF
>          !
>          !     nlfq needs deeq bec
>          !
>          if( ttforce ) CALL nlfq( cm, eigr, bec, becdr, fion )
>          !
>          !     calphi calculates phi
>          !     the electron mass rises with g**2
>          !
>          CALL calphi( cm, ngw, bec, nkb, vkb, phi, nbsp, ema0bg )
>          !
>          IF( force_pairing ) &
>          &   phi( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) =    phi( :, 1:nupdwn(2))
> 
> 
>          if( tortho ) then
>             CALL ortho( eigr, c0, phi, ngw, lambda, descla, &
>                         bigr, iter, ccc, bephi, becp, nbsp, nspin, nupdwn, iupdwn )
>          else
>             CALL gram( vkb, bec, nkb, c0, ngw, nbsp )
>          endif
>          !
>          !
>          if ( ttforce ) CALL nlfl( bec, becdr, lambda, fion )
> 
>          if ( iprsta >= 3 ) CALL print_lambda( lambda, nbsp, 9, ccc )
> 
>          if ( tstress ) CALL nlfh( stress, bec, dbec, lambda )
>          !
>          IF ( tortho ) THEN
>             DO iss = 1, nspin_wfc
>                i1 = (iss-1)*nlax+1
>                i2 = iss*nlax
>                CALL updatc( ccc, nbsp, lambda(:,:,iss), SIZE(lambda,1), phi, SIZE(phi,1), &
>                             bephi(:,i1:i2), SIZE(bephi,1), becp, bec, c0, nupdwn(iss), iupdwn(iss), &
>                             descla(:,iss) )
>             END DO
>          END IF
>          !
>          IF( force_pairing ) THEN
>             !
>             c0 ( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) =  c0( :, 1:nupdwn(2))
>             phi( :, iupdwn(2):(iupdwn(2)+nupdwn(2)-1) ) = phi( :, 1:nupdwn(2))
>             lambda(:,:,2) = lambda(:,:,1)
>             !
>          ENDIF
>          !
>          CALL calbec ( nvb+1, nsp, eigr, c0, bec )
> 
>          if ( tstress ) CALL caldbec( ngw, nkb, nbsp, 1, nsp, eigr, cm, dbec )
> 
>          if ( iprsta >= 3 ) CALL dotcsc( eigr, c0, ngw, nbsp )
>          !
>          xnhp0 = 0.0d0
>          xnhpm = 0.0d0
>          vnhp  = 0.0d0
>          fionm = 0.0d0
>          !
>          CALL ions_vel( vels, taus, tausm, na, nsp, delt )
>          !
>          xnhh0(:,:) = 0.0d0
>          xnhhm(:,:) = 0.0d0
>          vnhh (:,:) = 0.0d0
>          velh (:,:) = ( h(:,:) - hold(:,:) ) / delt
>          !
>          CALL elec_fakekine( ekincm, ema0bg, emass, c0, cm, ngw, nbsp, 1, delt )
> 
>          xnhe0 = 0.0d0
>          xnhem = 0.0d0
>          vnhe  = 0.0d0
> 
>          lambdam = lambda
>          !
>        ELSE 
>           !
>           c0 = cm
>           !
>        END IF
Only in ../../../ffn2_tsvdw_master/CPV: fromscra.F90
Only in ../../../ffn2_tsvdw_master/CPV: fromscra.o
diff ./gradrho.f90 ../../../ffn2_tsvdw_master/CPV/gradrho.f90
2c2
< ! Copyright (C) 2002-2020 Quantum ESPRESSO grouo
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
19,21c19,27
<       use gvect, only: ngm, nl, nlm, g
<       USE fft_interfaces, ONLY: invfft
<       USE fft_base,       ONLY: dfftp
---
>       use gvecp, only: ng => ngm
>       use reciprocal_vectors
>       use recvecs_indexes
>       USE cp_interfaces, ONLY: fwfft, invfft
>       USE fft_base,           ONLY: dfftp
>       use grid_dimensions, only : nr1, nr2, nr3, nr1x, nr2x, nr3x,      &
>      &                            nnr=> nnrx
> !      use grid_dimensions, only: nr1, nr2, nr3, &
> !            nr1x, nr2x, nr3x, nnr => nnrx
26c32
<       complex(kind=8) rhog(ngm,nspin)
---
>       complex(kind=8) rhog(ng,nspin)
28,30c34,36
<       real(kind=8)    drho(3,dfftp%nnr), d2rho(3,dfftp%nnr),     &
<      &                dxdyrho(dfftp%nnr), dxdzrho(dfftp%nnr),    &
<      &                dydzrho(dfftp%nnr)
---
>       real(kind=8)    drho(3,nnr), d2rho(3,nnr),     &
>      &                dxdyrho(nnr), dxdzrho(nnr),    &
>      &                dydzrho(nnr)
37,38c43,44
<       allocate(v(dfftp%nnr))
<       allocate(w(dfftp%nnr))
---
>       allocate(v(nnr))
>       allocate(w(nnr))
40c46
<       do ir = 1,dfftp%nnr
---
>       do ir = 1,nnr
51c57
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnr
55,59c61,65
<          do ig=1,ngm
<             v(nl(ig)) =      ci*tpiba*g(1,ig)*rhog(ig,iss)
<             v(nlm(ig))=conjg(ci*tpiba*g(1,ig)*rhog(ig,iss))
<             w(nl(ig)) =      -1.d0*tpiba**2*g(1,ig)**2*rhog(ig,iss)
<             w(nlm(ig))=conjg(-1.d0*tpiba**2*g(1,ig)**2*rhog(ig,iss))
---
>          do ig=1,ng
>             v(np(ig))=      ci*tpiba*gx(1,ig)*rhog(ig,iss)
>             v(nm(ig))=conjg(ci*tpiba*gx(1,ig)*rhog(ig,iss))
>             w(np(ig))=      -1.d0*tpiba**2*gx(1,ig)**2*rhog(ig,iss)
>             w(nm(ig))=conjg(-1.d0*tpiba**2*gx(1,ig)**2*rhog(ig,iss))
63c69
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
68c74
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnr
72,80c78,86
<          do ig=1,ngm
<             v(nl(ig))= tpiba*(      ci*g(2,ig)*rhog(ig,iss)-           &
<      &                                 g(3,ig)*rhog(ig,iss) )
<             v(nlm(ig))=tpiba*(conjg(ci*g(2,ig)*rhog(ig,iss))+          &
<      &                              ci*conjg(ci*g(3,ig)*rhog(ig,iss)))
<             w(nl(ig))= -1.d0*tpiba**2*(      g(2,ig)**2*rhog(ig,iss) + &
<      &                                 ci*g(3,ig)**2*rhog(ig,iss) )
<             w(nlm(ig))=-1.d0*tpiba**2*(conjg(g(2,ig)**2*rhog(ig,iss))+ &
<      &                           ci*conjg(g(3,ig)**2*rhog(ig,iss)))
---
>          do ig=1,ng
>             v(np(ig))= tpiba*(      ci*gx(2,ig)*rhog(ig,iss)-           &
>      &                                 gx(3,ig)*rhog(ig,iss) )
>             v(nm(ig))= tpiba*(conjg(ci*gx(2,ig)*rhog(ig,iss))+          &
>      &                              ci*conjg(ci*gx(3,ig)*rhog(ig,iss)))
>             w(np(ig))= -1.d0*tpiba**2*(      gx(2,ig)**2*rhog(ig,iss) + &
>      &                                 ci*gx(3,ig)**2*rhog(ig,iss) )
>             w(nm(ig))= -1.d0*tpiba**2*(conjg(gx(2,ig)**2*rhog(ig,iss))+ &
>      &                           ci*conjg(gx(3,ig)**2*rhog(ig,iss)))
84c90
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
91c97
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnr
94,96c100,102
<          do ig=1,ngm
<             v(nl(ig)) = -1.d0*tpiba**2*g(1,ig)*g(2,ig)*rhog(ig,iss)
<             v(nlm(ig))=conjg(v(nl(ig)))
---
>          do ig=1,ng
>             v(np(ig))= -1.d0*tpiba**2*gx(1,ig)*gx(2,ig)*rhog(ig,iss)
>             v(nm(ig))=conjg(v(np(ig)))
99c105
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
103c109
<          do ig=1,dfftp%nnr
---
>          do ig=1,nnr
106,111c112,117
<          do ig=1,ngm
<             v(nl(ig))= -1.d0*tpiba**2*(g(1,ig)*g(3,ig)*rhog(ig,iss) + &
<      &                              ci*g(2,ig)*g(3,ig)*rhog(ig,iss) )
<             v(nlm(ig))=-1.d0*tpiba**2*                                  &
<      &                          (conjg(g(1,ig)*g(3,ig)*rhog(ig,iss))+ &
<      &                        ci*conjg(g(2,ig)*g(3,ig)*rhog(ig,iss)))
---
>          do ig=1,ng
>             v(np(ig))= -1.d0*tpiba**2*(gx(1,ig)*gx(3,ig)*rhog(ig,iss) + &
>      &                              ci*gx(2,ig)*gx(3,ig)*rhog(ig,iss) )
>             v(nm(ig))= -1.d0*tpiba**2*                                  &
>      &                          (conjg(gx(1,ig)*gx(3,ig)*rhog(ig,iss))+ &
>      &                        ci*conjg(gx(2,ig)*gx(3,ig)*rhog(ig,iss)))
114c120
<          do ir=1,dfftp%nnr
---
>          do ir=1,nnr
Only in ../../../ffn2_tsvdw_master/CPV: gradrho.F90
Only in ../../../ffn2_tsvdw_master/CPV: gradrho.o
Only in .: gram.f90
diff ./gtable.f90 ../../../ffn2_tsvdw_master/CPV/gtable.f90
2c2
< ! Copyright (C) 2002-2010 Quantum ESPRESSO groups
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
22c22
<   use kinds, only: dp
---
> 
24c24
<   use gvect, only: mill
---
>   use reciprocal_vectors, only: mill_l
27c27
<   use mp_global, only: intra_bgrp_comm 
---
>   use mp_global, only: intra_image_comm 
34c34
<   real(dp) :: test
---
>   real(8) :: test
39,41c39,41
<      i = mill(1,ig)
<      j = mill(2,ig)
<      k = mill(3,ig)
---
>      i = mill_l(1,ig)
>      j = mill_l(2,ig)
>      k = mill_l(3,ig)
49c49
<         if(mill(1,jg).eq.i .and. mill(2,jg).eq.j .and. mill(3,jg).eq.k) then
---
>         if(mill_l(1,jg).eq.i .and. mill_l(2,jg).eq.j .and. mill_l(3,jg).eq.k) then
57c57
<            if(-mill(1,jg).eq.i .and. -mill(2,jg).eq.j .and. -mill(3,jg).eq.k) then
---
>            if(-mill_l(1,jg).eq.i .and. -mill_l(2,jg).eq.j .and. -mill_l(3,jg).eq.k) then
69,71c69,71
<      i = -mill(1,ig)
<      j = -mill(2,ig)
<      k = -mill(3,ig)
---
>      i = -mill_l(1,ig)
>      j = -mill_l(2,ig)
>      k = -mill_l(3,ig)
79c79
<         if (-mill(1,jg).eq.i .and. -mill(2,jg).eq.j .and. -mill(3,jg).eq.k)then
---
>         if (-mill_l(1,jg).eq.i .and. -mill_l(2,jg).eq.j .and. -mill_l(3,jg).eq.k)then
87c87
<            if(mill(1,jg).eq.i .and. mill(2,jg).eq.j .and. mill(3,jg).eq.k)then
---
>            if(mill_l(1,jg).eq.i .and. mill_l(2,jg).eq.j .and. mill_l(3,jg).eq.k)then
99c99
<   call mp_sum(test, intra_bgrp_comm)
---
>   call mp_sum(test, intra_image_comm)
116d115
<   use kinds, only: dp
118c117
<   use gvect, only: mill
---
>   use reciprocal_vectors, only: mill_l
121c120
<   use mp_global, only: intra_bgrp_comm
---
>   use mp_global, only: intra_image_comm
130c129
<   real(dp) :: test
---
>   real(8) :: test
135,137c134,136
<      i = mill(1,ig)
<      j = mill(2,ig)
<      k = mill(3,ig)
---
>      i = mill_l(1,ig)
>      j = mill_l(2,ig)
>      k = mill_l(3,ig)
144c143
<         if(i.eq.mill(1,jg).and. j.eq.mill(2,jg) .and. k.eq.mill(3,jg))then
---
>         if(i.eq.mill_l(1,jg).and. j.eq.mill_l(2,jg) .and. k.eq.mill_l(3,jg))then
147c146
<         else if(i.eq.-mill(1,jg).and. j.eq.-mill(2,jg) .and. k.eq.-mill(3,jg))then
---
>         else if(i.eq.-mill_l(1,jg).and. j.eq.-mill_l(2,jg) .and. k.eq.-mill_l(3,jg))then
159,161c158,160
<      i = mill(1,ig)
<      j = mill(2,ig)
<      k = mill(3,ig)
---
>      i = mill_l(1,ig)
>      j = mill_l(2,ig)
>      k = mill_l(3,ig)
168c167
<         if(i.eq.mill(1,jg).and. j.eq.mill(2,jg) .and. k.eq.mill(3,jg))then
---
>         if(i.eq.mill_l(1,jg).and. j.eq.mill_l(2,jg) .and. k.eq.mill_l(3,jg))then
171c170
<         else if(i.eq.-mill(1,jg).and. j.eq.-mill(2,jg) .and. k.eq.-mill(3,jg))then
---
>         else if(i.eq.-mill_l(1,jg).and. j.eq.-mill_l(2,jg) .and. k.eq.-mill_l(3,jg))then
182c181
<   call mp_sum(test, intra_bgrp_comm)
---
>   call mp_sum(test, intra_image_comm)
194,195c193,194
<   USE gvecw,              ONLY : ngw, ngw_g
<   USE gvect,              ONLY : ig_l2g, mill_g, mill
---
>   USE gvecw,              ONLY : ngw, ngwt
>   USE reciprocal_vectors, ONLY : ig_l2g, mill_g, mill_l
198c197
<   USE mp_global,          ONLY : me_bgrp, nproc_bgrp, intra_bgrp_comm
---
>   USE mp_global,          ONLY : me_image, nproc_image, intra_image_comm
209c208
<      if(ig_l2g(ig) > ngw_g) then
---
>      if(ig_l2g(ig) > ngwt) then
213c212
<      whose_is_g(ig_l2g(ig))=me_bgrp+1
---
>      whose_is_g(ig_l2g(ig))=me_image+1
215c214
<   call mp_sum(whose_is_g,intra_bgrp_comm)
---
>   call mp_sum(whose_is_g,intra_image_comm)
216a216
>   
220c220
<   allocate ( mill_g(3,ngw_g) )
---
>   allocate ( mill_g(3,ngwt) )
222c222
<      mill_g(:,ig_l2g(ig)) = mill(:,ig)
---
>      mill_g(:,ig_l2g(ig)) = mill_l(:,ig)
224c224
<   call mp_sum(mill_g,intra_bgrp_comm)
---
>   call mp_sum(mill_g,intra_image_comm)
226d225
<   
233,237c232,235
<   USE efield_module,      ONLY : ctable_missing_1, ctable_missing_2,  &
<                                  whose_is_g,n_g_missing_p, &
<                                  ctable_missing_rev_1,ctable_missing_rev_2 
<   USE gvecw,              ONLY : ngw, ngw_g
<   USE gvect, ONLY : ig_l2g, mill_g, mill, gstart
---
>   USE efield_module, ONLY : ctable_missing_1,ctable_missing_2, whose_is_g,n_g_missing_p,&
>                           &      ctable_missing_rev_1,ctable_missing_rev_2 
>   USE gvecw,              ONLY : ngw, ngwt
>   USE reciprocal_vectors, ONLY : ig_l2g, mill_g, mill_l, gstart
240c238
<   USE mp_global,          ONLY : me_bgrp, nproc_bgrp, intra_bgrp_comm
---
>   USE mp_global,          ONLY : me_image, nproc_image, intra_image_comm, world_comm
242a241
> 
247c246
<   INTEGER :: nfound_proc(nproc_bgrp,2)
---
>   INTEGER :: nfound_proc(nproc_image,2)
252c251,253
<   allocate( igg_found(ngw_g,2,nproc_bgrp), ig_send(ngw_g,2,nproc_bgrp) )
---
> 
> 
>   allocate(igg_found(ngwt,2, nproc_image),ig_send(ngwt,2,nproc_image))
261,263c262,264
<         i = mill(1,ig)
<         j = mill(2,ig)
<         k = mill(3,ig)
---
>         i = mill_l(1,ig)
>         j = mill_l(2,ig)
>         k = mill_l(3,ig)
267c268
<         do igg=1,ngw_g
---
>         do igg=1,ngwt
269c270
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
277c278
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
290,292c291,293
<         i = -mill(1,ig)
<         j = -mill(2,ig)
<         k = -mill(3,ig)
---
>         i = -mill_l(1,ig)
>         j = -mill_l(2,ig)
>         k = -mill_l(3,ig)
296c297
<         do igg=1,ngw_g
---
>         do igg=1,ngwt
298c299
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
306c307
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
317,319d317
< ! determine the largest nfound for processor and set it as dimension
< ! for ctable_missing and ctable_missing_rev
< ! copy ig_send to ctable_missing
321c319,322
<      call mp_sum(nfound_max, intra_bgrp_comm)
---
> !determine the largest nfound for processor and set it as dimensione for ctable_missing and ctable_missing_rev
> !copy ig_send to ctable_missing
> 
>      call mp_sum(nfound_max, intra_image_comm)
326c327
<      call mp_max(n_g_missing_p(ipol), intra_bgrp_comm)
---
>      call mp_max(n_g_missing_p(ipol), intra_image_comm)
330c331
<         allocate(ctable_missing_1(n_g_missing_p(ipol),2,nproc_bgrp))
---
>         allocate(ctable_missing_1(n_g_missing_p(ipol),2,nproc_image))
332c333
<         do ip=1,nproc_bgrp
---
>         do ip=1,nproc_image
337c338
<         allocate(ctable_missing_2(n_g_missing_p(ipol),2,nproc_bgrp))
---
>         allocate(ctable_missing_2(n_g_missing_p(ipol),2,nproc_image))
339c340
<         do ip=1,nproc_bgrp
---
>         do ip=1,nproc_image
348,349c349,350
<      allocate(igg_found_snd(n_g_missing_p(ipol),2,nproc_bgrp))
<      allocate(igg_found_rcv(n_g_missing_p(ipol),2,nproc_bgrp))
---
>      allocate(igg_found_snd(n_g_missing_p(ipol),2,nproc_image))
>      allocate(igg_found_rcv(n_g_missing_p(ipol),2,nproc_image))
351c352
<      do ip=1,nproc_bgrp
---
>      do ip=1,nproc_image
357c358
<      call mp_alltoall( igg_found_snd, igg_found_rcv, intra_bgrp_comm )
---
>      call mp_alltoall( igg_found_snd, igg_found_rcv, intra_image_comm )
360c361
<         allocate(ctable_missing_rev_1(n_g_missing_p(ipol),2,nproc_bgrp))
---
>         allocate(ctable_missing_rev_1(n_g_missing_p(ipol),2,nproc_image))
363c364
<         allocate(ctable_missing_rev_2(n_g_missing_p(ipol),2,nproc_bgrp))
---
>         allocate(ctable_missing_rev_2(n_g_missing_p(ipol),2,nproc_image))
371c372
<      do ip=1,nproc_bgrp
---
>      do ip=1,nproc_image
432c433
<      call mp_sum(nfound_max, intra_bgrp_comm)
---
>      call mp_sum(nfound_max, intra_image_comm)
451,452c452,453
<   USE gvecw,              ONLY : ngw, ngw_g
<   USE gvect, ONLY : ig_l2g, mill_g, mill, gstart
---
>   USE gvecw,              ONLY : ngw, ngwt
>   USE reciprocal_vectors, ONLY : ig_l2g, mill_g, mill_l, gstart
455c456
<   USE mp_global,          ONLY : me_bgrp, nproc_bgrp, intra_bgrp_comm
---
>   USE mp_global,          ONLY : me_image, nproc_image, intra_image_comm, world_comm
463c464
<   INTEGER :: nfound_proc(nproc_bgrp,2)
---
>   INTEGER :: nfound_proc(nproc_image,2)
470c471
<   allocate( igg_found(ngw_g,2,nproc_bgrp), ig_send(ngw_g,2,nproc_bgrp))
---
>   allocate(igg_found(ngwt,2, nproc_image),ig_send(ngwt,2,nproc_image))
481,483c482,484
<         i = mill(1,ig)
<         j = mill(2,ig)
<         k = mill(3,ig)
---
>         i = mill_l(1,ig)
>         j = mill_l(2,ig)
>         k = mill_l(3,ig)
487c488
<         do igg=1,ngw_g
---
>         do igg=1,ngwt
489c490
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
497c498
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
510,512c511,513
<         i = mill(1,ig)
<         j = mill(2,ig)
<         k = mill(3,ig)
---
>         i = mill_l(1,ig)
>         j = mill_l(2,ig)
>         k = mill_l(3,ig)
516c517
<         do igg=1,ngw_g
---
>         do igg=1,ngwt
518c519
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
526c527
<               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_bgrp) then
---
>               if(whose_is_g(igg) /= -1 .and. whose_is_g(igg) /= me_image) then
541c542
<      call mp_sum(nfound_max, intra_bgrp_comm)
---
>      call mp_sum(nfound_max, intra_image_comm)
546c547
<      call mp_max(n_g_missing_m(ipol), intra_bgrp_comm)
---
>      call mp_max(n_g_missing_m(ipol), intra_image_comm)
550c551
<         allocate(ctabin_missing_1(n_g_missing_m(ipol),2,nproc_bgrp))
---
>         allocate(ctabin_missing_1(n_g_missing_m(ipol),2,nproc_image))
552c553
<         do ip=1,nproc_bgrp
---
>         do ip=1,nproc_image
557c558
<         allocate(ctabin_missing_2(n_g_missing_m(ipol),2,nproc_bgrp))
---
>         allocate(ctabin_missing_2(n_g_missing_m(ipol),2,nproc_image))
559c560
<         do ip=1,nproc_bgrp
---
>         do ip=1,nproc_image
568,569c569,570
<      allocate(igg_found_snd(n_g_missing_m(ipol),2,nproc_bgrp))
<      allocate(igg_found_rcv(n_g_missing_m(ipol),2,nproc_bgrp))
---
>      allocate(igg_found_snd(n_g_missing_m(ipol),2,nproc_image))
>      allocate(igg_found_rcv(n_g_missing_m(ipol),2,nproc_image))
571c572
<      do ip=1,nproc_bgrp
---
>      do ip=1,nproc_image
577c578
<      CALL mp_alltoall( igg_found_snd, igg_found_rcv, intra_bgrp_comm )
---
>      CALL mp_alltoall( igg_found_snd, igg_found_rcv, intra_image_comm )
580c581
<         allocate(ctabin_missing_rev_1(n_g_missing_m(ipol),2,nproc_bgrp))
---
>         allocate(ctabin_missing_rev_1(n_g_missing_m(ipol),2,nproc_image))
583c584
<         allocate(ctabin_missing_rev_2(n_g_missing_m(ipol),2,nproc_bgrp))
---
>         allocate(ctabin_missing_rev_2(n_g_missing_m(ipol),2,nproc_image))
591c592
<      do ip=1,nproc_bgrp
---
>      do ip=1,nproc_image
652c653
<      call mp_sum(nfound_max, intra_bgrp_comm)
---
>      call mp_sum(nfound_max, intra_image_comm)
Only in ../../../ffn2_tsvdw_master/CPV: gtable.F90
Only in ../../../ffn2_tsvdw_master/CPV: gtable.o
Only in .: gvecw.f90
diff ./init.f90 ../../../ffn2_tsvdw_master/CPV/init.f90
2c2
< ! Copyright (C) 2002-2010 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
22,47c22,47
<       USE kinds,                ONLY: dp
<       USE constants,            ONLY: tpi
<       use io_global,            only: stdout, ionode
<       use control_flags,        only: gamma_only, iverbosity
<       use cell_base,            only: ainv, at, omega, alat
<       use small_box,            only: small_box_set
<       use smallbox_grid_dim,    only: smallbox_grid_init,smallbox_grid_info
<       USE grid_subroutines,     ONLY: realspace_grids_init, realspace_grids_info
<       use ions_base,            only: nat
<       USE recvec_subs,          ONLY: ggen
<       USE gvect,                ONLY: mill_g, eigts1,eigts2,eigts3, gg, &
<                                       ecutrho, gcutm, gvect_init
<       use gvecs,                only: gcutms, gvecs_init
<       use gvecw,                only: gkcut, gvecw_init, g2kin_init
<       USE smallbox_subs,        ONLY: ggenb
<       USE fft_base,             ONLY: dfftp, dffts, dfftb
<       USE fft_scalar,           ONLY: cft_b_omp_init
<       USE stick_set,            ONLY: pstickset
<       USE control_flags,        ONLY: tdipole, gamma_only
<       USE berry_phase,          ONLY: berry_setup
<       USE electrons_module,     ONLY: bmeshset
<       USE electrons_base,       ONLY: distribute_bands
<       USE problem_size,         ONLY: cpsizes
<       USE mp_global,            ONLY: me_bgrp, root_bgrp, nproc_bgrp, nbgrp, my_bgrp_id, intra_bgrp_comm
<       USE mp_global,            ONLY: get_ntask_groups
<       USE uspp,                 ONLY: okvan, nlcc_any
---
>       use io_global,                only: stdout, ionode
>       use control_flags,            only: gamma_only
>       use grid_dimensions,          only: nr1, nr2, nr3, nr1x, nr2x, nr3x, nnr => nnrx
>       use cell_base,                only: ainv, a1, a2, a3
>       use cell_base,                only: omega, alat
>       use small_box,                only: a1b, a2b, a3b, omegab, ainvb, tpibab, small_box_set
>       use small_box,                only: alatb, b1b, b2b, b3b
>       use smallbox_grid_dimensions, only: nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, nnrb => nnrbx
>       use smooth_grid_dimensions,   only: nr1s, nr2s, nr3s, nr1sx, nr2sx, nr3sx, nnrsx
>       USE grid_subroutines,         ONLY: realspace_grids_init, realspace_grids_para
>       USE reciprocal_vectors,       ONLY: mill_g, g2_g, bi1, bi2, bi3
>       USE recvecs_subroutines,      ONLY: recvecs_init
>       use gvecw,                    only: gcutw, gkcut
>       use gvecp,                    only: ecut => ecutp, gcut => gcutp
>       use gvecs,                    only: gcuts
>       use gvecb,                    only: gcutb
>       USE fft_base,                 ONLY: dfftp, dffts
>       USE stick_base,               ONLY: pstickset
>       USE control_flags,            ONLY: tdipole
>       USE berry_phase,              ONLY: berry_setup
>       USE electrons_module,         ONLY: bmeshset
>       USE problem_size,             ONLY: cpsizes
>       USE mp_global,                ONLY: use_task_groups
>       USE task_groups,              ONLY: task_groups_init
>       USE core,                     ONLY: nlcc_any
>       USE uspp,                     ONLY: okvan
52,54c52,54
<       real(dp) :: rat1, rat2, rat3
<       real(dp) :: bg(3,3), tpiba2 
<       integer :: ng_, ngs_, ngm_ , ngw_ , nogrp_
---
>       real(8) :: rat1, rat2, rat3
>       real(8) :: b1(3), b2(3), b3(3)
>       integer :: ng_ , ngs_ , ngm_ , ngw_
56,57d55
< 
<       tpiba2 = ( tpi / alat ) ** 2
68a67,73
> 
>       !
>       ! ... Initialize (global) real and compute global reciprocal dimensions
>       !
> 
>       CALL realspace_grids_init( alat, a1, a2, a3, gcut, gcuts, ng_ , ngs_ )
> 
71c76,78
<       ! ... note that at are in alat units
---
>       !
> 
>       call recips( a1, a2, a3, b1, b2, b3 )
73c80
<       call recips( at(1,1), at(1,2), at(1,3), bg(1,1), bg(1,2), bg(1,3) )
---
>       !     Store the base vectors used to generate the reciprocal space
75,76c82,84
<       !     bg(:,1), bg(:,2), bg(:,3) are the basis vectors, in
<       !     2pi/alat units, generating the reciprocal lattice
---
>       bi1 = b1
>       bi2 = b2
>       bi3 = b3
78c86,87
<       ! ... Initialize FFT real-space grids and small box grid
---
>       !     Change units:  b1, b2, b3  are the 3 basis vectors generating 
>       !     the reciprocal lattice in 2pi/alat units
80,81c89,96
<       CALL realspace_grids_init( dfftp, dffts, at, bg, gcutm, gcutms)
<       CALL smallbox_grid_init( dfftp, dfftb )
---
>       !      Normally if a1, a2 and a3 are in cartesian coordinates
>       !      and in a.u. units the corresponding bs are in cartesian
>       !      coordinate too and in unit of 2 PI / a.u.
>       !      now bring b1, b2 and b3 in units of 2 PI / alat
> 
>       b1 = b1 * alat
>       b2 = b2 * alat
>       b3 = b3 * alat
88,90c103,105
<         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 1,at(:,1)*alat,bg(:,1)
<         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 2,at(:,2)*alat,bg(:,2)
<         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 3,at(:,3)*alat,bg(:,3)
---
>         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 1,a1,b1
>         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 2,a2,b2
>         WRITE( stdout,'(3X,I1,1X,3f10.4,10x,3f10.4)') 3,a3,b3
92a108
> 
95,97c111,113
<          ainv(1,i)=bg(i,1)/alat
<          ainv(2,i)=bg(i,2)/alat
<          ainv(3,i)=bg(i,3)/alat
---
>          ainv(1,i)=b1(i)/alat
>          ainv(2,i)=b2(i)/alat
>          ainv(3,i)=b3(i)/alat
109d124
<       ! ... pstickset lso sets the local real-space grid dimensions
111d125
<       nogrp_ = get_ntask_groups()
113,114c127,129
<       CALL pstickset( gamma_only, bg, gcutm, gkcut, gcutms, &
<         dfftp, dffts, ngw_ , ngm_ , ngs_ , me_bgrp, root_bgrp, nproc_bgrp, intra_bgrp_comm, nogrp_ )
---
>       CALL pstickset( dfftp, dffts, alat, a1, a2, a3, gcut, gkcut, gcuts, &
>         nr1, nr2, nr3, nr1x, nr2x, nr3x, nr1s, nr2s, nr3s, nr1sx, nr2sx,   &
>         nr3sx, ngw_ , ngm_ , ngs_ )
121,122c136
<       CALL gvect_init ( ngm_ , intra_bgrp_comm )
<       CALL gvecs_init ( ngs_ , intra_bgrp_comm )
---
>       CALL recvecs_init( ngm_ , ngw_ , ngs_ )
124d137
<       ! ... Print real-space grid dimensions
126,127c139
<       CALL realspace_grids_info ( dfftp, dffts, nproc_bgrp )
<       CALL smallbox_grid_info ( dfftb )
---
>       ! ... Initialize (local) real space dimensions
129c141
<       ! ... generate g-space vectors (dense and smooth grid)
---
>       CALL realspace_grids_para( dfftp, dffts )
131,135d142
< #ifdef __LOWMEM
<       CALL ggen( gamma_only, at, bg, intra_bgrp_comm )
< #else
<       CALL ggen( gamma_only, at, bg )
< #endif
137c144
<       ! ... allocate and generate (modified) kinetic energy
---
>       ! ... generate g-space
139,140c146,147
<       CALL gvecw_init ( ngw_ , intra_bgrp_comm )
<       CALL g2kin_init ( gg, tpiba2 )
---
>       call ggencp( b1, b2, b3, nr1, nr2, nr3, nr1s, nr2s, nr3s, gcut, gcuts, gkcut, gamma_only )
> 
146a154
> 
149a158
>       if( allocated( g2_g ) )   deallocate( g2_g )
152c161
<       !     allocate spaces for phases e^{-iG*tau_s}
---
>       !     generation of little box g-vectors
154,160c163
<       allocate( eigts1(-dfftp%nr1:dfftp%nr1,nat) )
<       allocate( eigts2(-dfftp%nr2:dfftp%nr2,nat) )
<       allocate( eigts3(-dfftp%nr3:dfftp%nr3,nat) )
<       !
<       !     small boxes
<       !
<       IF ( dfftb%nr1 > 0 .AND. dfftb%nr2 > 0 .AND. dfftb%nr3 > 0 ) THEN
---
>       IF ( nr1b > 0 .AND. nr2b > 0 .AND. nr3b > 0 ) THEN
162c165
<          !  set the small box parameters
---
>          !  sets the small box parameters
164,172c167,174
<          rat1 = DBLE( dfftb%nr1 ) / DBLE( dfftp%nr1 )
<          rat2 = DBLE( dfftb%nr2 ) / DBLE( dfftp%nr2 )
<          rat3 = DBLE( dfftb%nr3 ) / DBLE( dfftp%nr3 )
<          !
<          CALL small_box_set( alat, omega, at, rat1, rat2, rat3, tprint = .TRUE. )
<          !
<          !  generate small-box G-vectors, initialize FFT tables
<          !
<          CALL ggenb ( ecutrho, iverbosity )
---
>          rat1 = DBLE( nr1b ) / DBLE( nr1 )
>          rat2 = DBLE( nr2b ) / DBLE( nr2 )
>          rat3 = DBLE( nr3b ) / DBLE( nr3 )
>          CALL small_box_set( alat, omega, a1, a2, a3, rat1, rat2, rat3 )
> 
>          !  now set gcutb
> 
>          gcutb = ecut / tpibab / tpibab
174,176c176,177
< #if defined __OPENMP && defined __FFTW 
<          CALL cft_b_omp_init( dfftb%nr1, dfftb%nr2, dfftb%nr3 )
< #endif
---
>          CALL ggenb ( b1b, b2b, b3b, nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, gcutb )
> 
183,186d183
<       ! ... distribute bands
< 
<       CALL distribute_bands( nbgrp, my_bgrp_id )
< 
192a190,198
>       IF( use_task_groups ) THEN
>         !
>         !  Initialize task groups.
>         !  Note that this call modify dffts adding task group data.
>         !
>         CALL task_groups_init( dffts )
>         !
>       END IF
>       !
210c216
<       use mp_global,        only: nproc_bgrp, me_bgrp, intra_bgrp_comm, root_bgrp
---
>       use mp_global,        only: nproc_image
212,214c218,219
<       use ions_base,        only: na, nsp, nat, tau_srt, ind_srt, if_pos, atm,&
<                                   amass
<       use cell_base,        only: at, alat, r_to_s, cell_init, deth
---
>       use ions_base,        only: na, nsp, nat, tau_srt, ind_srt, if_pos, atm, na, pmass
>       use cell_base,        only: a1, a2, a3, r_to_s, cell_init, deth
222,225c227,228
<       USE cp_main_variables,ONLY: ht0, htm, taub
<       USE atoms_type_module,ONLY: atoms_type
<       USE cp_interfaces,    ONLY: newinit
<       USE constants,        ONLY: amu_au
---
>       USE cp_main_variables,     ONLY: ht0, htm, taub
>       USE atoms_type_module,     ONLY: atoms_type
234c237
<       REAL(DP), ALLOCATABLE :: pmass(:), taus_srt( :, : )
---
>       REAL(DP), ALLOCATABLE :: taus_srt( :, : )
248,249c251,252
<       CALL cell_init( alat, at, ht0 )
<       CALL cell_init( alat, at, htm )
---
>       CALL cell_init( ht0, a1, a2, a3 )
>       CALL cell_init( htm, a1, a2, a3 )
257c260
<       ALLOCATE( taus_srt( 3, nat ), pmass(nsp) )
---
>       ALLOCATE( taus_srt( 3, nat ) )
261d263
<       pmass (:) = amass(1:nsp) * amu_au
264c266
<       DEALLOCATE( pmass, taus_srt )
---
>       DEALLOCATE( taus_srt )
270c272
<       CALL fft_box_allocate( dfftb, me_bgrp, root_bgrp, nproc_bgrp, intra_bgrp_comm, nat )
---
>       CALL fft_box_allocate( dfftb, nproc_image, nat )
301c303
<         ! geometry is set to the cell parameters read from stdin
---
>         ! geometry is set to the cell parameters read from stdin ( a1, a2, a3 )
304,306c306,308
<             h(i,1) = at(i,1)*alat
<             h(i,2) = at(i,2)*alat
<             h(i,3) = at(i,3)*alat
---
>             h(i,1) = a1(i)
>             h(i,2) = a2(i)
>             h(i,3) = a3(i)
315c317
<       call newinit( ht0%hmat, iverbosity = 2 )
---
>       call newinit( ht0%hmat )
328c330
<     subroutine newinit_x( h, iverbosity )
---
>     subroutine newinit( h )
332c334
<       !     at, ainv, and corresponding quantities for small boxes
---
>       !     a1,a2,a3, ainv, and corresponding quantities for small boxes
336,343c338
<       USE constants,             ONLY : tpi
<       USE cell_base,             ONLY : at, bg, omega, alat, tpiba2, &
<                                         cell_base_reinit
<       USE gvecw,                 ONLY : g2kin_init
<       USE gvect,                 ONLY : g, gg, ngm, mill
<       USE fft_base,              ONLY : dfftp, dfftb
<       USE small_box,             ONLY : small_box_set
<       USE smallbox_subs,         ONLY : gcalb
---
>       USE cell_base,             ONLY : a1, a2, a3, omega, alat, cell_base_reinit
348,349c343,346
<       REAL(DP), INTENT(IN) :: h(3,3)
<       INTEGER,  INTENT(IN) :: iverbosity
---
>       REAL(DP) :: h(3,3)
>       INTEGER   :: i, j
> 
>       ! local
351,352c348
<       REAL(DP) :: rat1, rat2, rat3
<       INTEGER :: ig, i1, i2, i3
---
>       REAL(DP) :: gmax, b1(3), b2(3), b3(3)
354c350
<       !WRITE( stdout, "(4x,'h from newinit')" )
---
>       !WRITE( stdout, 344 ) 
356c352
<       !   WRITE( stdout, '(3(4x,f12.7)' ) (h(i,j),j=1,3)
---
>       !   WRITE( stdout, 345 ) (h(i,j),j=1,3)
363,371c359
<       !  re-calculate G-vectors and kinetic energy
<       !
<       do ig=1,ngm
<          i1=mill(1,ig)
<          i2=mill(2,ig)
<          i3=mill(3,ig)
<          g(:,ig)=i1*bg(:,1)+i2*bg(:,2)+i3*bg(:,3)
<          gg(ig)=g(1,ig)**2 + g(2,ig)**2 + g(3,ig)**2
<       enddo
---
>       call recips( a1, a2, a3, b1, b2, b3 )
373,375c361
<       call g2kin_init ( gg, tpiba2 )
<       !
<       IF ( dfftb%nr1 == 0 .OR. dfftb%nr2 == 0 .OR. dfftb%nr3 == 0 ) RETURN
---
>       call gcal( alat, b1, b2, b3, gmax )
379,384c365
<       rat1 = DBLE( dfftb%nr1 ) / DBLE( dfftp%nr1 )
<       rat2 = DBLE( dfftb%nr2 ) / DBLE( dfftp%nr2 )
<       rat3 = DBLE( dfftb%nr3 ) / DBLE( dfftp%nr3 )
<       CALL small_box_set( alat, omega, at, rat1, rat2, rat3, tprint = ( iverbosity > 1 ) )
<       !
<       call gcalb ( )
---
>       call newgb( a1, a2, a3, omega, alat )
387c368,370
<     end subroutine newinit_x
---
>  344  format(4x,'h from newinit')
>  345  format(3(4x,f12.7))
>     end subroutine newinit
Only in ../../../ffn2_tsvdw_master/CPV: init.F90
Only in ../../../ffn2_tsvdw_master/CPV: init.o
diff ./init_run.f90 ../../../ffn2_tsvdw_master/CPV/init_run.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 Quantum ESPRESSO group
17,18c17,25
<   USE control_flags,            ONLY : nbeg, nomore, lwf, iverbosity, iprint, &
<                                        ndr, ndw, tfor, tprnfor, tpre, force_pairing
---
>   USE control_flags,            ONLY : nbeg, nomore, lwf, iprsta, iprint, &
>                                        ndr, tfor, tprnfor, tpre, &
>                                        force_pairing, newnfi, tnewnfi, ndw, &
>                                        lwfpbe0nscf, lwfpbe0  ! Lingzhu Kong
> !==============================================================================
> !Charles Swartz
>   USE input_parameters,         ONLY : ts_vdw
>   USE tsvdw_module,             ONLY : tsvdw_initialize
> !==============================================================================
20c27
<   USE ions_base,                ONLY : na, nax, nat, nsp, iforce, amass, ityp, cdms
---
>   USE ions_base,                ONLY : na, nax, nat, nsp, iforce, pmass, ityp, cdms
24,29c31,37
<   USE gvecw,                    ONLY : ngw, ngw_g, ggp
<   USE smallbox_gvec,                    ONLY : ngb
<   USE gvecs,                    ONLY : ngms
<   USE gvect,                    ONLY : ngm
<   USE gvect,       ONLY : gstart
<   USE fft_base,                 ONLY : dfftp, dffts
---
>   USE gvecw,                    ONLY : ngw, ecutw, ngwt, ggp
>   USE gvecb,                    ONLY : ngb
>   USE gvecs,                    ONLY : ngs
>   USE gvecp,                    ONLY : ngm
>   USE reciprocal_vectors,       ONLY : gzero
>   USE grid_dimensions,          ONLY : nnrx, nr1, nr2, nr3
>   USE fft_base,                 ONLY : dfftp
33c41,43
<   USE wavefunctions_module,     ONLY : c0_bgrp, cm_bgrp, phi_bgrp
---
>   USE smooth_grid_dimensions,   ONLY : nnrsx
>   USE wavefunctions_module,     ONLY : c0, cm, cp, cv0  ! cv0 added by Lingzhu Kong
>   USE cdvan,                    ONLY : dbec, drhovan
41,43c51,53
<                                        alat, celldm, at, bg
<   USE cp_main_variables,        ONLY : lambda, lambdam, lambdap, ema0bg, &
<                                        sfac, eigr, taub, &
---
>                                        alat, celldm, a1, a2, a3, b1, b2, b3
>   USE cp_main_variables,        ONLY : lambda, lambdam, lambdap, ema0bg, bec,  &
>                                        sfac, eigr, ei1, ei2, ei3, taub, &
47c57,59
<   USE cp_main_variables,        ONLY : allocate_mainvar, descla
---
>   USE cp_main_variables,        ONLY : allocate_mainvar, nlax, descla, nrlx, nlam, &
>                                        wcenters, vwcenters ! added Charles Swartz
>   USE wannier_base,             ONLY : vnbsp ! vnbsp added by Lingzhu Kong
52d63
<   USE electrons_base,           ONLY : nbspx_bgrp
53a65
>   USE gvecp,                    ONLY : ecutp
61a74
>   USE cp_restart,               ONLY : cp_read_wfc_Kong            ! Lingzhu Kong
68c81
<   USE io_global,                ONLY : ionode, stdout
---
>   USE io_global,                ONLY : ionode, stdout, ionode_id
71c84
<   USE xml_io_base,              ONLY : restart_dir, create_directory, change_directory
---
>   USE xml_io_base,              ONLY : restart_dir, create_directory
73,81c86,89
<   USE ions_base,                ONLY : ions_reference_positions, cdmi
<   USE mp_global,                ONLY : nimage, my_image_id, nbgrp, me_image, intra_image_comm
<   USE mp,                       ONLY : mp_barrier
<   USE wrappers
<   USE ldaU_cp
<   USE control_flags,            ONLY : lwfpbe0nscf  ! Lingzhu Kong
<   USE wavefunctions_module,     ONLY : cv0          ! Lingzhu Kong
<   USE wannier_base,             ONLY : vnbsp        ! Lingzhu Kong
<   USE cp_restart,               ONLY : cp_read_wfc_Kong  ! Lingzhu Kong
---
>   USE step_constraint,          ONLY : step_con
>   USE ions_base,                ONLY : ions_reference_positions, cdmi, taui
>   USE ldau
>   USE mp,                       ONLY : mp_bcast
87,88d94
<   REAL(DP)           :: a1(3), a2(3), a3(3)
<   LOGICAL            :: ftest
95,117d100
<   IF( nimage > 1 ) THEN
<      !
<      ! ... When bgrps are used, open a directory for each one
<      !
<      WRITE( dirname, FMT = '( I5.5 )' ) my_image_id
<      tmp_dir = TRIM( tmp_dir ) // '/' // TRIM( dirname )
<      CALL create_directory( tmp_dir )
<      !CALL change_directory( tmp_dir )
<      IF( me_image == 0 ) THEN
<         INQUIRE( FILE='plumed.dat', EXIST=ftest )
<         IF( ftest ) THEN
<           i = f_link( '../../plumed.dat', TRIM(tmp_dir)//'/'//'plumed.dat' )
<         END IF 
<      END IF
<      CALL mp_barrier( intra_image_comm )
<      !
<   END IF
< 
<   CALL plugin_initialization()
< 
<   IF( nbgrp > 1 .AND. force_pairing ) &
<      CALL errore( ' init_run ', ' force_pairing with parallelization over bands not implemented yet ', 1 )
<   !
144c127
<   !     allocate and initialize local and nonlocal potentials
---
>   !     allocate and initialize nonlocal potentials
147,148d129
<   CALL allocate_local_pseudo( ngms, nsp )
<   !
155,158c136,153
<   CALL allocate_mainvar( ngw, ngw_g, ngb, ngms, ngm, dfftp%nr1,dfftp%nr2,dfftp%nr3, dfftp%nr1x, &
<                          dfftp%nr2x, dfftp%npl, dfftp%nnr, dffts%nnr, nat, nax, nsp,   &
<                          nspin, nbsp, nbspx, nupdwn, nkb, gstart, nudx, &
<                          tpre, nbspx_bgrp )
---
>   CALL allocate_mainvar( ngw, ngwt, ngb, ngs, ngm, nr1, nr2, nr3, dfftp%nr1x, &
>                          dfftp%nr2x, dfftp%npl, nnrx, nnrsx, nat, nax, nsp,   &
>                          nspin, nbsp, nbspx, nupdwn, nkb, gzero, nudx, &
>                          tpre )
>   !
>   CALL allocate_local_pseudo( ngs, nsp )
>   !
>   !----------------------------------------------------------------------------
>   !Charles Swartz
>   !
>   !=======================================================================
>   !     Initialization of the TS-vdW code (RAD)
>   !=======================================================================
>   !
>   IF (ts_vdw.EQV..TRUE.) THEN   
>     CALL tsvdw_initialize()     
>   END IF
>   !----------------------------------------------------------------------------
163,165c158,160
<   ALLOCATE( c0_bgrp( ngw, nbspx ) )
<   ALLOCATE( cm_bgrp( ngw, nbspx ) )
<   ALLOCATE( phi_bgrp( ngw, nbspx ) )
---
>   ALLOCATE( c0( ngw, nbspx ) )
>   ALLOCATE( cm( ngw, nbspx ) )
>   ALLOCATE( cp( ngw, nbspx ) )
167c162
<   IF ( iverbosity > 2 ) THEN
---
>   IF ( iprsta > 2 ) THEN
176,178c171,173
<   IF( iverbosity < 1 ) iprint_stdout = 100 * iprint
<   IF( iverbosity ==1 ) iprint_stdout = 10 * iprint
<   IF( iverbosity > 1 ) iprint_stdout = iprint
---
>   IF( iprsta < 1 ) iprint_stdout = 100 * iprint
>   IF( iprsta ==1 ) iprint_stdout = 10 * iprint
>   IF( iprsta > 1 ) iprint_stdout = iprint
191a187,190
>   IF ( tpre ) THEN
>      ALLOCATE( dbec( nkb, 2*nlam, 3, 3 ) )
>      ALLOCATE( drhovan( nhm*(nhm+1)/2, nat, nspin, 3, 3 ) )
>   END IF
196,199c195
<      CALL errore( ' init_run ', 'ensemble_dft not implimented for metaGGA', 1 )
<   !
<   IF ( dft_is_meta() .AND. nbgrp > 1 ) &
<      CALL errore( ' init_run ', 'band parallelization not implimented for metaGGA', 1 )
---
>      CALL errore( 'cprmain ', 'ensemble_dft not implimented for metaGGA', 1 )
203,205c199,201
<      ALLOCATE( crosstaus( dffts%nnr, 6, nspin ) )
<      ALLOCATE( dkedtaus(  dffts%nnr, 3, 3, nspin ) )
<      ALLOCATE( gradwfc(   dffts%nnr, 3 ) )
---
>      ALLOCATE( crosstaus( nnrsx, 6, nspin ) )
>      ALLOCATE( dkedtaus(  nnrsx, 3, 3, nspin ) )
>      ALLOCATE( gradwfc(   nnrsx, 3 ) )
209,213c205
<   IF ( lwf ) THEN
<      IF( nbgrp > 1 ) &
<         CALL errore( ' init_run ', ' wannier with band paralleliztion not implemented ', 1 )
<      CALL allocate_wannier( nbsp, dffts%nnr, nspin, ngm )
<   END IF
---
>   IF ( lwf ) CALL allocate_wannier( nbsp, nnrsx, nspin, ngm )
215,220c207,208
<   IF ( tens .OR. tcg ) THEN
<      IF( nbgrp > 1 ) &
<         CALL errore( ' init_run ', ' ensemble_dft with band paralleliztion not implemented ', 1 )
<      CALL allocate_ensemble_dft( nkb, nbsp, ngw, nudx, nspin, nbspx, dffts%nnr, nat, &
<                                  MAXVAL(descla(:)%nrcx), MAXVAL(descla(:)%nrlx) )
<   END IF
---
>   IF ( tens .OR. tcg ) &
>      CALL allocate_ensemble_dft( nkb, nbsp, ngw, nudx, nspin, nbspx, nnrsx, nat, nlax, nrlx )
222,226c210
<   IF ( tcg ) THEN 
<      IF( nbgrp > 1 ) &
<         CALL errore( ' init_run ', ' cg with band paralleliztion not implemented ', 1 )
<      CALL allocate_cg( ngw, nbspx,nkbus )
<   END IF
---
>   IF ( tcg ) CALL allocate_cg( ngw, nbspx,nkbus )
228,237c212,213
<   IF ( tefield ) THEN
<      IF( nbgrp > 1 ) &
<         CALL errore( ' init_run ', ' efield with band paralleliztion not implemented ', 1 )
<      CALL allocate_efield( ngw, ngw_g, nbspx, nhm, nax, nsp )
<   END IF
<   IF ( tefield2 ) THEN
<      IF( nbgrp > 1 ) &
<         CALL errore( ' init_run ', ' efield with band paralleliztion not implemented ', 1 )
<      CALL allocate_efield2( ngw, nbspx, nhm, nax, nsp )
<   END IF
---
>   IF ( tefield ) CALL allocate_efield( ngw, ngwt, nbspx, nhm, nax, nsp )
>   IF ( tefield2 ) CALL allocate_efield2( ngw, nbspx, nhm, nax, nsp )
254,257c230,233
<   IF(lwfpbe0nscf) cv0=( 0.D0, 0.D0 )    ! Lingzhu Kong
<   cm_bgrp  = ( 0.D0, 0.D0 )
<   c0_bgrp  = ( 0.D0, 0.D0 )
<   phi_bgrp = ( 0.D0, 0.D0 )
---
>   IF(lwfpbe0nscf)cv0= ( 0.D0, 0.D0 )    !Lingzhu Kong
>   cm = ( 0.D0, 0.D0 )
>   c0 = ( 0.D0, 0.D0 )
>   cp = ( 0.D0, 0.D0 )
264,266c240
<   a1(:)=at(:,1)*alat; a2(:)=at(:,2)*alat; a3(:)=at(:,3)*alat 
<   IF ( lwf ) CALL wannier_startup( ibrav, alat, a1, a2, a3, &
<                                    bg(:,1), bg(:,2), bg(:,3) )
---
>   IF ( lwf ) CALL wannier_startup( ibrav, alat, a1, a2, a3, b1, b2, b3 )
273,275c247,251
<   !
<   CALL ldaU_init()
<   !
---
> 
>   step_con = .FALSE.
> 
>   CALL ldau_init()
> 
292,294c268,275
<      !======================================================================
<      ! Kong, read the valence orbitals
<      IF(lwfpbe0nscf) THEN
---
>      i = 1 
>     !======================================================================
>                        !Kong, read the valence orbitals
> 
>      !Charles Swartz (needs to be made into own subroutine, but that needs
>      ! modules for the exx files)
> 
>      IF(lwfpbe0nscf)THEN
295a277,288
>         !Charles Swartz
>         if(ionode) then
>             do i=1, nbsp,1
>                read(407, *) wcenters(1,i), wcenters(2,i), wcenters(3,i)
>             enddo
>             do i=1,vnbsp,1
>                read(408, *) vwcenters(1,i), vwcenters(2,i), vwcenters(3,i)
>             enddo
> 
>          endif
>          CALL mp_bcast( wcenters, ionode_id )
>          CALL mp_bcast( vwcenters, ionode_id )
297,299c290,305
<      !======================================================================
<      i = 1  
<      CALL readfile( i, h, hold, nfi, c0_bgrp, cm_bgrp, taus,   &
---
> 
>     !Charles Swartz
>      If(lwfpbe0) then
>         if(ionode) then
>             do i=1,nbsp,1
>             read(407,*) wcenters(1,i), wcenters(2, i), wcenters(3, i)
>             enddo
>          endif
> 
>      CALL mp_bcast( wcenters, ionode_id )
>      endif
>     !======================================================================
> 
> 
>     !======================================================================
>      CALL readfile( i, h, hold, nfi, c0, cm, taus,   &
323a330,331
>   IF ( tnewnfi ) nfi = newnfi 
>   !
328c336
<   CALL ions_cofmass( taus, amass, na, nsp, cdms )
---
>   CALL ions_cofmass( taus, pmass, na, nsp, cdms )
Only in ../../../ffn2_tsvdw_master/CPV: init_run.F90
Only in ../../../ffn2_tsvdw_master/CPV: init_run.o
diff ./inner_loop_cold.f90 ../../../ffn2_tsvdw_master/CPV/inner_loop_cold.f90
12c12
<                           sfac, c0, bec, dbec, firstiter, vpot )
---
>                           sfac, c0, bec, firstiter, vpot )
21a22,28
>       USE control_flags,  ONLY: iprint, thdyn, tpre, iprsta, &
>                                 tfor, taurdr, &
>                                 tprnfor, ndr, ndw, nbeg, nomore, &
>                                 tsde, tortho, tnosee, tnosep, trane, &
>                                 tranp, tsdp, tcp, tcap, ampre, &
>                                 amprp, tnoseh
>       USE core,           ONLY: nlcc_any
25,26c32
<                                 nelt, nx => nbspx, n => nbsp, ispin , &
<                                 f_bgrp,nupdwn_bgrp,iupdwn_bgrp
---
>                                 nelt, nx => nbspx, n => nbsp, ispin 
33,35c39,41
<       USE gvect,          ONLY: ngm
<       USE gvecs,          ONLY: ngms
<       USE smallbox_gvec,  ONLY: ngb
---
>       USE gvecp,          ONLY: ngm
>       USE gvecs,          ONLY: ngs
>       USE gvecb,          ONLY: ngb
37,39c43,49
<       USE gvect,          ONLY: gstart
<       USE uspp_param,     ONLY: nvb, ish
<       USE ions_base,      ONLY: na, nat, nsp
---
>       USE reciprocal_vectors, &
>                           ONLY: gstart
>       USE cvan,           ONLY: nvb, ish
>       USE ions_base,      ONLY: na, nat, pmass, nax, nsp, rcmax
>       USE grid_dimensions, &
>                           ONLY: nnr => nnrx, nr1, nr2, nr3
>       USE cell_base,      ONLY: ainv, a1, a2, a3
41c51,55
<       USE fft_base,       ONLY: dfftp, dffts
---
>       USE cell_base,      ONLY: h, hold, deth, wmass, tpiba2
>       USE smooth_grid_dimensions, &
>                           ONLY: nnrsx, nr1s, nr2s, nr3s
>       USE smallbox_grid_dimensions, &
>                           ONLY: nnrb => nnrbx, nr1b, nr2b, nr3b
43,44c57,59
<       USE io_global,      ONLY: stdout, ionode, ionode_id
<       USE mp_global,      ONLY: intra_bgrp_comm, leg_ortho
---
>       USE io_global,      ONLY: io_global_start, stdout, ionode, &
>                                 ionode_id
>       USE mp_global,      ONLY: intra_image_comm, leg_ortho
45a61,62
>       !USE derho
>       USE cdvan
47c64
<                                 rhovan => becsum, deeq, nlcc_any
---
>                                 rhovan => becsum, deeq
53c70
<       USE cp_interfaces,  ONLY: rhoofr, dforce, protate, vofrho, calbec
---
>       USE cp_interfaces,  ONLY: rhoofr, dforce, protate
55,56c72,75
<       USE cp_main_variables, ONLY: descla, drhor, drhog
<       USE descriptors,       ONLY: descla_init , la_descriptor
---
>       USE cp_main_variables, ONLY: distribute_lambda, descla, nlax, collect_lambda
>       USE descriptors,       ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                    descla_init , la_comm_ , ilar_ , ilac_ , nlar_ , &
>                                    nlac_ , la_myr_ , la_myc_ , la_nx_ , la_n_ , la_me_ , la_nrl_
70d88
<       REAL(kind=DP)               :: dbec( nhsa, n, 3, 3 )
76,77c94,95
<       REAL(kind=DP)               :: rhor( dfftp%nnr, nspin )
<       REAL(kind=DP)               :: vpot( dfftp%nnr, nspin )
---
>       REAL(kind=DP)               :: rhor( nnr, nspin )
>       REAL(kind=DP)               :: vpot( nnr, nspin )
79,84c97,102
<       REAL(kind=DP)               :: rhos( dffts%nnr, nspin )
<       REAL(kind=DP)               :: rhoc( dfftp%nnr )
<       COMPLEX(kind=DP)            :: ei1( dfftp%nr1:dfftp%nr1, nat )
<       COMPLEX(kind=DP)            :: ei2( dfftp%nr2:dfftp%nr2, nat )
<       COMPLEX(kind=DP)            :: ei3( dfftp%nr3:dfftp%nr3, nat )
<       COMPLEX(kind=DP)            :: sfac( ngms, nsp )
---
>       REAL(kind=DP)               :: rhos( nnrsx, nspin )
>       REAL(kind=DP)               :: rhoc( nnr )
>       COMPLEX(kind=DP)            :: ei1( nr1:nr1, nat )
>       COMPLEX(kind=DP)            :: ei2( nr2:nr2, nat )
>       COMPLEX(kind=DP)            :: ei3( nr3:nr3, nat )
>       COMPLEX(kind=DP)            :: sfac( ngs, nsp )
98c116
<       TYPE(la_descriptor) :: desc_ip
---
>       INTEGER :: desc_ip( descla_siz_ )
104c122
<       allocate(c0hc0(MAXVAL( descla(:)%nrcx ),MAXVAL( descla(:)%nrcx ),nspin))
---
>       allocate(c0hc0(nlax,nlax,nspin))
119a138
> 
123,124c142,143
<         CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, dbec, rhovan, &
<                      rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin6 )
---
>         CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, rhovan, &
>                      rhor, rhog, rhos, enl, denl, ekin, dekin6 )
130c149
<         CALL vofrho( nfi, vpot, drhor, rhog, drhog, rhos, rhoc, tfirst, &
---
>         CALL vofrho( nfi, vpot, rhog, rhos, rhoc, tfirst, &
135c154
<      END IF
---
>       END IF
138a158
>     
152c172
<             CALL dforce( i, bec, betae, c0, h0c0(:,i), h0c0(:,i+1), rhos, dffts%nnr, ispin, f, n, nspin )
---
>             CALL dforce( i, bec, betae, c0, h0c0(:,i), h0c0(:,i+1), rhos, nnrsx, ispin, f, n, nspin )
165,166c185,186
<             np(1) = descla( is )%npr
<             np(2) = descla( is )%npc
---
>             np(1) = descla( la_npr_ , is )
>             np(2) = descla( la_npc_ , is )
173c193
<                   CALL descla_init( desc_ip, descla( is )%n, descla( is )%nx, np, coor_ip, descla( is )%comm, 1 )
---
>                   CALL descla_init( desc_ip, descla( la_n_ , is ), descla( la_nx_ , is ), np, coor_ip, descla( la_comm_ , is ), 1 )
175,178c195,198
<                   nr = desc_ip%nr
<                   nc = desc_ip%nc
<                   ir = desc_ip%ir
<                   ic = desc_ip%ic
---
>                   nr = desc_ip( nlar_ )
>                   nc = desc_ip( nlac_ )
>                   ir = desc_ip( ilar_ )
>                   ic = desc_ip( ilac_ )
180c200,201
<                   CALL GRID2D_RANK( 'R', desc_ip%npr, desc_ip%npc, desc_ip%myr, desc_ip%myc, root )
---
>                   CALL GRID2D_RANK( 'R', desc_ip( la_npr_ ), desc_ip( la_npc_ ), &
>                                     desc_ip( la_myr_ ), desc_ip( la_myc_ ), root )
200c221
<                   CALL mp_root_sum( mtmp, c0hc0(1:nr,1:nc,is), root, intra_bgrp_comm )
---
>                   CALL mp_root_sum( mtmp, c0hc0(1:nr,1:nc,is), root, intra_image_comm )
202,203c223,224
< !                  IF( coor_ip(1) == descla( is )%myr .AND. &
< !                      coor_ip(2) == descla( is )%myc .AND. descla( is )%active_node > 0 ) THEN
---
> !                  IF( coor_ip(1) == descla( la_myr_ , is ) .AND. &
> !                      coor_ip(2) == descla( la_myc_ , is ) .AND. descla( lambda_node_ , is ) > 0 ) THEN
218c239
<                  sfac, c0, bec, dbec, firstiter,psihpsi,c0hc0,1.d0,atot1, vpot)
---
>                  sfac, c0, bec, firstiter,psihpsi,c0hc0,1.d0,atot1, vpot)
223c244
<                  sfac, c0, bec, dbec, firstiter,psihpsi,c0hc0,lambdap,atotl, vpot)
---
>                  sfac, c0, bec, firstiter,psihpsi,c0hc0,lambdap,atotl, vpot)
252,255d272
<          
<          do is=1,nspin
<             f_bgrp(iupdwn_bgrp(is):iupdwn_bgrp(is)+nupdwn_bgrp(is)-1)=f(1:nupdwn_bgrp(is))
<          enddo
262,263c279,280
<          CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, dbec, rhovan, &
<                      rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin6 )
---
>          CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, rhovan, &
>                      rhor, rhog, rhos, enl, denl, ekin, dekin6 )
269c286
<          CALL vofrho( nfi, vpot, drhor, rhog, drhog, rhos, rhoc, tfirst, &
---
>          CALL vofrho( nfi, vpot, rhog, rhos, rhoc, tfirst, &
313c330
<                           sfac, c0, bec, dbec, firstiter,c0hc0,c1hc1,lambda,  &
---
>                           sfac, c0, bec, firstiter,c0hc0,c1hc1,lambda,  &
321a339,345
>       USE control_flags,  ONLY: iprint, thdyn, tpre, iprsta, &
>                                 tfor, taurdr, &
>                                 tprnfor, ndr, ndw, nbeg, nomore, &
>                                 tsde, tortho, tnosee, tnosep, trane, &
>                                 tranp, tsdp, tcp, tcap, ampre, &
>                                 amprp, tnoseh
>       USE core,           ONLY: nlcc_any
325,326c349
<                                 nelt, nx => nbspx, n => nbsp, ispin ,&
<                                 f_bgrp,nupdwn_bgrp,iupdwn_bgrp
---
>                                 nelt, nx => nbspx, n => nbsp, ispin 
329,332c352,355
<                                  c0diag, becdiag, z0t
<       USE gvect,          ONLY: ngm
<       USE gvecs,          ONLY: ngms
<       USE smallbox_gvec,  ONLY: ngb
---
>                                  c0diag, becdiag
>       USE gvecp,          ONLY: ngm
>       USE gvecs,          ONLY: ngs
>       USE gvecb,          ONLY: ngb
334,336c357,363
<       USE gvect,          ONLY: gstart
<       USE uspp_param,     ONLY: nvb, ish, nh
<       USE ions_base,      ONLY: na, nat, nsp
---
>       USE reciprocal_vectors, &
>                           ONLY: gstart
>       USE cvan,           ONLY: nvb, ish
>       USE ions_base,      ONLY: na, nat, pmass, nax, nsp, rcmax
>       USE grid_dimensions, &
>                           ONLY: nnr => nnrx, nr1, nr2, nr3
>       USE cell_base,      ONLY: ainv, a1, a2, a3
337a365,369
>       USE cell_base,      ONLY: h, hold, deth, wmass, tpiba2
>       USE smooth_grid_dimensions, &
>                           ONLY: nnrsx, nr1s, nr2s, nr3s
>       USE smallbox_grid_dimensions, &
>                           ONLY: nnrb => nnrbx, nr1b, nr2b, nr3b
339c371,373
<       USE io_global,      ONLY: stdout, ionode, ionode_id
---
>       USE io_global,      ONLY: io_global_start, stdout, ionode, &
>                                 ionode_id
>       USE mp_global,      ONLY: intra_image_comm
340a375,376
>       !USE derho
>       USE cdvan
342c378,379
<                                 rhovan => becsum, deeq, nlcc_any
---
>                                 rhovan => becsum, deeq
>       USE uspp_param,     ONLY: nh
346,348c383,384
<       use cp_interfaces,  only: rhoofr, dforce, vofrho
<       USE cp_main_variables, ONLY: descla, drhor, drhog
<       USE fft_base,       ONLY: dfftp, dffts
---
>       use cp_interfaces,  only: rhoofr, dforce
>       USE cp_main_variables, ONLY: descla, nlax, nrlx
360d395
<       REAL(kind=DP)               :: dbec( nhsa, n, 3, 3 )
366,367c401,402
<       REAL(kind=DP)               :: rhor( dfftp%nnr, nspin )
<       REAL(kind=DP)               :: vpot( dfftp%nnr, nspin )
---
>       REAL(kind=DP)               :: rhor( nnr, nspin )
>       REAL(kind=DP)               :: vpot( nnr, nspin )
369,374c404,409
<       REAL(kind=DP)               :: rhos( dffts%nnr, nspin )
<       REAL(kind=DP)               :: rhoc( dfftp%nnr )
<       COMPLEX(kind=DP)            :: ei1( dfftp%nr1:dfftp%nr1, nat )
<       COMPLEX(kind=DP)            :: ei2( dfftp%nr2:dfftp%nr2, nat )
<       COMPLEX(kind=DP)            :: ei3( dfftp%nr3:dfftp%nr3, nat )
<       COMPLEX(kind=DP)            :: sfac( ngms, nsp )
---
>       REAL(kind=DP)               :: rhos( nnrsx, nspin )
>       REAL(kind=DP)               :: rhoc( nnr )
>       COMPLEX(kind=DP)            :: ei1( nr1:nr1, nat )
>       COMPLEX(kind=DP)            :: ei2( nr2:nr2, nat )
>       COMPLEX(kind=DP)            :: ei3( nr3:nr3, nat )
>       COMPLEX(kind=DP)            :: sfac( ngs, nsp )
376,377c411,412
<       REAL(kind=DP), INTENT(in)   :: c0hc0(MAXVAL(descla(:)%nrcx),MAXVAL(descla(:)%nrcx),nspin)
<       REAL(kind=DP), INTENT(in)   :: c1hc1(MAXVAL(descla(:)%nrcx),MAXVAL(descla(:)%nrcx),nspin)
---
>       REAL(kind=DP), INTENT(in)   :: c0hc0(nlax,nlax,nspin)
>       REAL(kind=DP), INTENT(in)   :: c1hc1(nlax,nlax,nspin)
390c425
<       allocate(clhcl(MAXVAL( descla(:)%nrcx ),MAXVAL( descla(:)%nrcx ),nspin))
---
>       allocate(clhcl(nlax,nlax,nspin))
393c428
<       allocate(zauxt(MAXVAL(descla(:)%nrlx),nudx,nspin))
---
>       allocate(zauxt(nrlx,nudx,nspin))
409,411d443
<        do is=1,nspin
<           f_bgrp(iupdwn_bgrp(is):iupdwn_bgrp(is)+nupdwn_bgrp(is)-1)=f(1:nupdwn_bgrp(is))
<        enddo
414,415c446,447
<       CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, dbec, rhovan, &
<                    rhor, drhor, rhog, drhog, rhos, enl, denl, ekin, dekin6 )
---
>       CALL rhoofr( nfi, c0diag, irb, eigrb, becdiag, rhovan, &
>                    rhor, rhog, rhos, enl, denl, ekin, dekin6 )
421c453
<       CALL vofrho( nfi, vpot, drhor, rhog, drhog, rhos, rhoc, tfirst, &
---
>       CALL vofrho( nfi, vpot, rhog, rhos, rhoc, tfirst, &
426d457
< 
503a535,540
>       USE control_flags,  ONLY: iprint, thdyn, tpre, iprsta, &
>                                 tfor, taurdr, &
>                                 tprnfor, ndr, ndw, nbeg, nomore, &
>                                 tsde, tortho, tnosee, tnosep, trane, &
>                                 tranp, tsdp, tcp, tcap, ampre, &
>                                 amprp, tnoseh
514,516c551,553
<       USE gvect,          ONLY: ngm
<       USE gvecs,          ONLY: ngms
<       USE smallbox_gvec,          ONLY: ngb
---
>       USE gvecp,          ONLY: ngm
>       USE gvecs,          ONLY: ngs
>       USE gvecb,          ONLY: ngb
518c555
<       USE gvect, &
---
>       USE reciprocal_vectors, &
520,521c557,561
<       USE uspp_param,     ONLY: nvb, ish
<       USE ions_base,      ONLY: na, nat, nsp
---
>       USE cvan,           ONLY: nvb, ish
>       USE ions_base,      ONLY: na, nat, pmass, nax, nsp, rcmax
>       USE grid_dimensions, &
>                           ONLY: nnr => nnrx, nr1, nr2, nr3
>       USE cell_base,      ONLY: ainv, a1, a2, a3
522a563,567
>       USE cell_base,      ONLY: h, hold, deth, wmass, tpiba2
>       USE smooth_grid_dimensions, &
>                           ONLY: nnrsx, nr1s, nr2s, nr3s
>       USE smallbox_grid_dimensions, &
>                           ONLY: nnrb => nnrbx, nr1b, nr2b, nr3b
524,525c569,571
<       USE io_global,      ONLY: stdout, ionode, ionode_id
<       USE mp_global,      ONLY: intra_bgrp_comm
---
>       USE io_global,      ONLY: io_global_start, stdout, ionode, &
>                                 ionode_id
>       USE mp_global,      ONLY: intra_image_comm
526a573,574
>       !USE derho
>       USE cdvan
536,537c584,588
<       USE cp_main_variables, ONLY: descla
<       USE descriptors,       ONLY: la_descriptor, descla_init
---
>       USE cp_main_variables, ONLY: distribute_lambda, descla, nlax, collect_lambda, nrlx
>       USE descriptors,       ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                    descla_init , la_comm_ , ilar_ , ilac_ , nlar_ , &
>                                    nlac_ , la_myr_ , la_myc_ , la_nx_ , la_n_ , &
>                                    la_me_ , la_nrl_ 
546,547c597,598
<       REAL(kind=DP)               :: psihpsi( MAXVAL( descla(:)%nrcx ), MAXVAL( descla(:)%nrcx ), nspin )
<       REAL(kind=DP)               :: z0t( MAXVAL(descla(:)%nrlx), nudx, nspin )
---
>       REAL(kind=DP)               :: psihpsi( nlax, nlax, nspin )
>       REAL(kind=DP)               :: z0t( nrlx, nudx, nspin )
564,567c615,618
<             np_rot   = descla( is )%npr  * descla( is )%npc
<             me_rot   = descla( is )%mype
<             nrl      = descla( is )%nrl
<             comm_rot = descla( is )%comm
---
>             np_rot   = descla( la_npr_ , is )  * descla( la_npc_ , is )
>             me_rot   = descla( la_me_ , is )
>             nrl      = descla( la_nrl_ , is )
>             comm_rot = descla( la_comm_ , is )
573c624
<             IF( descla( is )%active_node > 0 ) THEN
---
>             IF( descla( lambda_node_ , is ) > 0 ) THEN
577c628
<                CALL blk2cyc_redist( nss, epsi0, nrl, nss, psihpsi(1,1,is), SIZE(psihpsi,1), SIZE(psihpsi,2), descla(is) )
---
>                CALL blk2cyc_redist( nss, epsi0, nrl, nss, psihpsi(1,1,is), SIZE(psihpsi,1), SIZE(psihpsi,2), descla(1,is) )
589c640
<             CALL mp_sum( dval, intra_bgrp_comm )
---
>             CALL mp_sum( dval, intra_image_comm )
593a645
> 
596c648
<             IF( descla( is )%active_node > 0 ) THEN
---
>             IF( descla( lambda_node_ , is ) > 0 ) THEN
604c656
<          END DO
---
>    END DO
609,611c661
< 
<   
<    CALL rotate ( z0t, c0, bec, c0diag, becdiag, .false. ) 
---
>    CALL rotate ( z0t, c0, bec, c0diag, becdiag, .false. )
Only in ../../../ffn2_tsvdw_master/CPV: inner_loop_cold.F90
Only in ../../../ffn2_tsvdw_master/CPV: inner_loop_cold.o
diff ./input.f90 ../../../ffn2_tsvdw_master/CPV/input.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 Quantum ESPRESSO group
12,13c12
<    USE kinds,      ONLY: DP
<    USE read_input, ONLY : has_been_read
---
>    USE kinds,     ONLY: DP
20c19,20
<                                 !  a) read input file (module read_input)
---
>                                 !
>    PUBLIC :: read_input_file    !  a) This sub. should be called first
25c25
<    CHARACTER(LEN=256), EXTERNAL :: trimcheck
---
>    LOGICAL :: has_been_read = .FALSE.
29a30,89
>    SUBROUTINE read_input_file()
>      !-------------------------------------------------------------------------
>      !
>      USE read_namelists_module, ONLY : read_namelists
>      USE read_cards_module,     ONLY : read_cards
>      USE input_parameters,      ONLY : calculation, title
>      USE control_flags,         ONLY : lneb, lpath, lwf, lwfnscf, lwfpbe0, lwfpbe0nscf   ! changed by Lingzhu Kong
>      USE printout_base,         ONLY : title_ => title
>      USE io_global,             ONLY : meta_ionode, stdout
>      USE xml_input,             ONLY : xml_input_dump
>      !
>      IMPLICIT NONE
>      !
>      CHARACTER(LEN=2) :: prog
>      !
>      !
>      prog = 'CP'
>      !
>      IF ( meta_ionode ) THEN
>         CALL xml_input_dump()
>         CALL input_from_file()
>      END IF
>      !
>      ! ... Read NAMELISTS 
>      !
>      CALL read_namelists( prog )
>      !
>      ! ... Read CARDS 
>      !
>      CALL read_cards ( prog )
>      !
>      lneb = ( TRIM( calculation ) == 'neb' )
>      !
>      lpath = lneb
>      !
> !====================================================================
> !Lingzhu Kong
> !    lwf = ( TRIM( calculation ) == 'cp-wf' )
>      lwf = ( TRIM( calculation ) == 'cp-wf'      .OR. &
>              TRIM( calculation ) == 'cp-wf-nscf' .OR. &
>              TRIM( calculation ) == 'cp-wf-pbe0' .OR. &
>              TRIM( calculation ) == 'pbe0-nscf' )
>      lwfnscf = ( TRIM( calculation ) == 'cp-wf-nscf' )
>      lwfpbe0     = ( TRIM( calculation ) == 'cp-wf-pbe0')
>      lwfpbe0nscf = ( TRIM( calculation ) == 'pbe0-nscf' )
> !====================================================================
>      !
>      ! ... Set job title and print it on standard output
>      !
>      title_ = title
>      !
>      WRITE( stdout, '(/,3X,"Job Title: ",A )' ) TRIM( title_ )
>      !
>      has_been_read = .TRUE.
>      !
>      RETURN
>      !
>    END SUBROUTINE read_input_file
>    !
>    !-------------------------------------------------------------------------
35,36c95
<      USE read_pseudo_mod,         ONLY : readpp, check_order
<      USE io_global,               ONLY : stdout
---
>      USE read_pseudo_module_fpmd, ONLY : readpp
40,41c99
<                                          prefix_     => prefix, &
<                                          tmp_dir
---
>                                          prefix_     => prefix, tmp_dir
43,44c101,102
<      USE input_parameters,        ONLY : title
<      USE run_info,                ONLY : title_ => title
---
>      !
>      IMPLICIT NONE
50,54d107
<      ! ... Set job title and print it on standard output
<      !
<      title_ = title
<      WRITE( stdout, '(/,3X,"Job Title: ",A )' ) TRIM( title_ )
<      !
56,57c109,110
<      outdir_  = trimcheck( outdir )
<      tmp_dir  = trimcheck( outdir )
---
>      outdir_  = TRIM( outdir )
>      tmp_dir  = TRIM( outdir )
66c119
<      pseudo_dir_     = trimcheck( pseudo_dir  )
---
>      pseudo_dir_     = TRIM( pseudo_dir  )
70,71c123
<      CALL readpp( input_dft, .TRUE. )
<      CALL check_order ( )
---
>      CALL readpp( input_dft )
126c178
<      USE control_flags, ONLY : ldamped
---
>      USE control_flags, ONLY : lcoarsegrained, ldamped
135a188,189
>                                newnfi_     => newnfi, &
>                                tnewnfi_    => tnewnfi, &
141c195
<                                iverbosity_ => iverbosity, &
---
>                                iprsta_     => iprsta, &
187c241,244
<      USE control_flags, ONLY : iesr
---
>      USE control_flags, ONLY : remove_drift_ => remove_drift              
>      USE control_flags, ONLY : correct_mass_ => correct_mass !Charles Swartz
>      USE control_flags, ONLY : iesr, tvhmean, vhrmin, vhrmax, vhasse
>      USE control_flags, ONLY : tprojwfc
189,191c246
<      USE control_flags, ONLY : do_makov_payne, twfcollect
<      USE control_flags, ONLY : lwf, lwfnscf, lwfpbe0, lwfpbe0nscf ! Lingzhu Kong
<      USE control_flags, ONLY : lneb, lpath
---
>      USE control_flags, ONLY : do_makov_payne
210c265
<      USE uspp_param,         ONLY : nvb
---
>      USE cvan,               ONLY : nvb
220a276
>         tdipole_card, tnewnfi_card, newnfi_card,                               &
224c280,282
<         iesr_inp, saverho, tdipole_card, rd_for, assume_isolated, wf_collect
---
>         iesr_inp, vhrmax_inp, vhrmin_inp, tvhmean_inp, vhasse_inp, saverho,    &
>         rd_for, assume_isolated, remove_drift, correct_mass    !Correct Mass added by Charles Swartz    
> 
246a305,309
>      tvhmean = tvhmean_inp
>      vhrmin  = vhrmin_inp
>      vhrmax  = vhrmax_inp
>      vhasse  = vhasse_inp
>      !
248c311,312
<      twfcollect = wf_collect
---
>      remove_drift_     = remove_drift       
>      correct_mass_     = correct_mass   !Charles Swartz 
284,297d347
<      ! no longer implemented!
<      lneb = ( TRIM( calculation ) == 'neb' )
<      lpath = lneb
< !====================================================================
< !Lingzhu Kong
<      lwf = ( TRIM( calculation ) == 'cp-wf'      .OR. &
<              TRIM( calculation ) == 'cp-wf-nscf' .OR. &
<              TRIM( calculation ) == 'cp-wf-pbe0' .OR. &
<              TRIM( calculation ) == 'pbe0-nscf' )
<      lwfnscf     = ( TRIM( calculation ) == 'cp-wf-nscf' )
<      lwfpbe0     = ( TRIM( calculation ) == 'cp-wf-pbe0')
<      lwfpbe0nscf = ( TRIM( calculation ) == 'pbe0-nscf' )
< !====================================================================
< 
301,307c351
<      trhor_ = ( TRIM( calculation ) == 'nscf'       .OR. &
<                 TRIM( calculation ) == 'cp-wf-nscf' .OR. &
<                 TRIM( calculation ) == 'pbe0-nscf'  )    ! Lingzhu Kong
<      trhow_ = saverho
<      tksw_  = ( TRIM( disk_io ) == 'high' )
<      !
<      iverbosity_ = 1
---
>      iprsta_ = 1
318a363,369
>      trhor_ = ( TRIM( calculation ) == 'nscf'       .OR. & 
>                 TRIM( calculation ) == 'cp-wf-nscf' .OR. &
>                 TRIM( calculation ) == 'pbe0-nscf'  )    ! Lingzhu Kong
> 
>      trhow_ = saverho
>      tksw_  = ( TRIM( disk_io ) == 'high' )
>      !
322c373
<          iverbosity_ = 0
---
>          iprsta_ = 0
326c377
<          iverbosity_ = 1
---
>          iprsta_ = 1
328a380,385
>        CASE( 'default+projwfc' )
>          !
>          iprsta_  = 1
>          timing_  = .TRUE.
>          tprojwfc = .TRUE.
>          !
331c388
<          iverbosity_   = 2
---
>          iprsta_   = 2
337c394
<          iverbosity_   = 3
---
>          iprsta_   = 3
341,346c398
<          !
<        CASE( 'debug' )
<          !
<          iverbosity_   = 4
<          memchk_   = .TRUE.
<          timing_   = .TRUE.
---
>          tprojwfc  = .TRUE.
355a408,409
>      newnfi_   = newnfi_card
>      tnewnfi_  = tnewnfi_card
465d518
<           PRINT*,"startingwfc",startingwfc
534a588,598
>       SELECT CASE( TRIM( phase_space ) )
>       CASE( 'full' )
>          !
>          lcoarsegrained  = .FALSE.
>          !
>       CASE ( 'coarse-grained' )
>          !
>          lcoarsegrained  = .TRUE.
>          !
>       END SELECT
>       !
760,761c824,825
<      USE input_parameters, ONLY: ibrav , celldm , trd_ht, dt,                 &
<            rd_ht, a, b, c, cosab, cosac, cosbc, ntyp , nat ,                  &
---
>      USE input_parameters, ONLY: ibrav , celldm , trd_ht, dt,    &
>            cell_symmetry, rd_ht, a, b, c, cosab, cosac, cosbc, ntyp , nat ,   &
767,768c831,833
<            outdir, prefix, nkstot, xk,                                        &
<            occupations, n_inner, fermi_energy, rotmass, occmass,              &
---
>            outdir, prefix,                                                    &
>            k_points, nkstot, nk1, nk2, nk3, k1, k2, k3,                       &
>            xk, wk, occupations, n_inner, fermi_energy, rotmass, occmass,      &
778c843
<            passop, tot_charge, tot_magnetization, niter_cg_restart
---
>            passop, tot_charge, tot_magnetization, ncolvar_inp, niter_cg_restart
779a845,851
> !===============================================================
> !Lingzhu Kong
> !    USE input_parameters, ONLY : wf_efield, wf_switch, sw_len, efx0, efy0,    &
> !                                 efz0, efx1, efy1, efz1, wfsd, wfdt, maxwfdt, &
> !                                 wf_q, wf_friction, nit, nsd, nsteps, tolw,   &
> !                                 adapt, calwf, nwf, wffort, writev,           &
> !                                 wannier_index
781c853,854
<                                   efz0, efx1, efy1, efz1, wfsd, wfdt, maxwfdt, &
---
>                                   efz0, efx1, efy1, efz1, wfsd, wfdt,neigh,poisson_eps,&
>                                   dis_cutoff,exx_ps_rcut, exx_me_rcut,vnbsp, maxwfdt, &
786,789d858
< !Lingzhu Kong
<      USE input_parameters, ONLY : neigh, poisson_eps, dis_cutoff, exx_ps_rcut,&
<                                   exx_me_rcut, vnbsp
< !===============================================================
797,798d865
<      USE input_parameters, ONLY : lda_plus_u, Hubbard_U
<      USE input_parameters, ONLY : step_pen, A_pen, alpha_pen, sigma_pen
800,801c867,868
<      USE ions_base,        ONLY : zv
<      USE cell_base,        ONLY : cell_base_init, cell_dyn_init, at, cell_alat
---
>      USE ions_base,        ONLY : tau, ityp, zv
>      USE cell_base,        ONLY : cell_base_init, a1, a2, a3, cell_alat
812,820c879,900
<      USE ldaU_cp,          ONLY : ldaU_init0
<      USE step_penalty,     ONLY : ldaUpen_init
<      USE fft_base,         ONLY : dfftp, dffts, dfftb
<      USE kohn_sham_states, ONLY : ks_states_init
<      USE electrons_module, ONLY : electrons_setup
<      USE electrons_base,   ONLY : electrons_base_initval
<      USE ensemble_dft,     ONLY : ensemble_initval,tens
<      USE wannier_base,     ONLY : wannier_init
<      USE efield_module,    ONLY : tefield
---
>      !
>      USE smallbox_grid_dimensions, ONLY: &
>            nnrbx, &  !  variable is used to workaround internal compiler error (IBM xlf)
>            nr1b_ => nr1b, &
>            nr2b_ => nr2b, &
>            nr3b_ => nr3b
>      USE grid_dimensions,          ONLY: &
>            nnrx, &  !  variable is used to workaround internal compiler error (IBM xlf)
>            nr1_ => nr1, &
>            nr2_ => nr2, &
>            nr3_ => nr3
>      USE smooth_grid_dimensions,   ONLY: &
>            nnrsx, &  !  variable is used to workaround internal compiler error (IBM xlf)
>            nr1s_ => nr1s, &
>            nr2s_ => nr2s, &
>            nr3s_ => nr3s
>      USE kohn_sham_states,   ONLY : ks_states_init
>      USE electrons_module,   ONLY : electrons_setup
>      USE electrons_base,     ONLY : electrons_base_initval
>      USE ensemble_dft,       ONLY : ensemble_initval,tens
>      USE wannier_base,       ONLY : wannier_init
>      USE efield_module,      ONLY : tefield
838,841c918,921
<      CALL cell_base_init( ibrav, celldm, a, b, c, cosab, cosac, cosbc, &
<                           trd_ht, rd_ht, cell_units )
<      CALL cell_dyn_init ( trd_ht, rd_ht, wmass, massa_totale, press, &
<                           cell_damping, greash, cell_dofree )
---
>      CALL cell_base_init( ibrav , celldm , trd_ht, cell_symmetry, rd_ht, &
>                           cell_units, a, b, c, cosab, cosac, cosbc , wmass, &
>                           massa_totale, press, cell_damping, greash, &
>                           cell_dofree )
849c929
<                           alat_ , at, ion_radius, rd_for )
---
>                           alat_ , a1, a2, a3, ion_radius, rd_for )
872,874c952,954
<      dfftb%nr1 = nr1b  
<      dfftb%nr2 = nr2b
<      dfftb%nr3 = nr3b
---
>      nr1b_ = nr1b  
>      nr2b_ = nr2b
>      nr3b_ = nr3b
879,881c959,961
<      dfftp%nr1  = nr1
<      dfftp%nr2  = nr2
<      dfftp%nr3  = nr3
---
>      nr1_  = nr1
>      nr2_  = nr2
>      nr3_  = nr3
886,888c966,971
<      dffts%nr1 = nr1s
<      dffts%nr2 = nr2s
<      dffts%nr3 = nr3s
---
>      nr1s_ = nr1s
>      nr2s_ = nr2s
>      nr3s_ = nr3s
> 
>      IF ( .NOT. lneb ) &
>         CALL printout_base_init( outdir, prefix )
898a982
> 
924c1008,1009
<      lconstrain = ( nconstr_inp > 0 )
---
>      lconstrain = ( ncolvar_inp + nconstr_inp > 0 )
>      !
927a1013,1017
> !    CALL wannier_init( wf_efield, wf_switch, sw_len, efx0, efy0, efz0, &
> !                       efx1, efy1, efz1, wfsd, wfdt, maxwfdt, wf_q,    &
> !                       wf_friction, nit, nsd, nsteps, tolw, adapt,     &
> !                       calwf, nwf, wffort, writev, wannier_index,      &
> !                       restart_mode )
929,931c1019,1020
<                         efx1, efy1, efz1, wfsd, wfdt, neigh,poisson_eps,&
<                         dis_cutoff, exx_ps_rcut, exx_me_rcut, vnbsp,    &
<                         maxwfdt, wf_q, &
---
>                         efx1, efy1, efz1, wfsd, wfdt,neigh,poisson_eps ,&
>                         dis_cutoff, exx_ps_rcut, exx_me_rcut,vnbsp, maxwfdt, wf_q, &
944,948d1032
<      ! ... initialize variables for lda+U calculations
<      !
<      CALL ldaU_init0 ( ntyp, lda_plus_u, Hubbard_U )
<      CALL ldaUpen_init( SIZE(sigma_pen), step_pen, sigma_pen, alpha_pen, A_pen )
<      !
1002c1086
<                               trhor, tksw, tfor, tnosep, iverbosity, &
---
>                               trhor, tksw, tfor, tnosep, iprsta, &
1014d1097
<     USE time_step,            ONLY: delt
1051c1134
<         CALL electrons_nose_info(delt)
---
>         CALL electrons_nose_info()
1075c1158
<       IF( tfor .AND. tnosep ) CALL ions_nose_info(delt)
---
>       IF( tfor .AND. tnosep ) CALL ions_nose_info()
1083c1166
<       IF( thdyn .AND. tnoseh ) CALL cell_nose_info (delt)
---
>       IF( thdyn .AND. tnoseh ) CALL cell_nose_info()
1090c1173
<       WRITE( stdout,700) iverbosity
---
>       WRITE( stdout,700) iprsta
1107c1190
< 700 FORMAT( /,3X, 'Verbosity: iverbosity = ',i2,/)
---
> 700 FORMAT( /,3X, 'Verbosity: iprsta = ',i2,/)
Only in ../../../ffn2_tsvdw_master/CPV: input.F90
Only in ../../../ffn2_tsvdw_master/CPV: input.mod
Only in ../../../ffn2_tsvdw_master/CPV: input.o
Only in .: ions_nose.f90
Only in ../../../ffn2_tsvdw_master/CPV: ions_positions.F90
Only in ../../../ffn2_tsvdw_master/CPV: ions_positions.mod
Only in ../../../ffn2_tsvdw_master/CPV: ions_positions.o
Only in ../../../ffn2_tsvdw_master/CPV: kohn_sham_states.mod
diff ./ksstates.f90 ../../../ffn2_tsvdw_master/CPV/ksstates.f90
12a13,14
>    USE io_files, ONLY: ksunit, ks_file
> 
20d21
<    CHARACTER(LEN=2 ), PARAMETER :: ks_file       = 'KS'
77c78
<         USE mp_global,        ONLY : intra_bgrp_comm
---
>         USE mp_global,        ONLY : intra_image_comm
143,144c144,146
<         USE fft_base, ONLY: dfftp, dffts, dfftp
<         USE fft_interfaces, ONLY: invfft
---
>         USE fft_base, ONLY: dfftp, dffts
>         USE grid_dimensions, ONLY: nr1, nr2, nr3, nr1x, nr2x, nr3x, nnrx
>         USE cp_interfaces, ONLY: invfft
146c148
<         USE mp_global,       ONLY: intra_bgrp_comm, inter_bgrp_comm
---
>         USE mp_global,       ONLY: nproc_image, me_image, intra_image_comm
157,158c159,160
<         ALLOCATE( psi( dfftp%nnr ) )
<         ALLOCATE( rpsi2( dfftp%nnr ) )
---
>         ALLOCATE( psi( nnrx ) )
>         ALLOCATE( rpsi2( nnrx ) )
163c165
<         DO i = 1, dfftp%nnr
---
>         DO i = 1, nnrx
169,170c171
<                             dfftp%nr1, dfftp%nr2, dfftp%nr3, dfftp%nr1x, dfftp%nr2x, dfftp%ipp, dfftp%npp, &
<                             ionode, intra_bgrp_comm, inter_bgrp_comm )
---
>                             nr1, nr2, nr3, nr1x, nr2x, dfftp%ipp, dfftp%npp )
172c173
<         CALL mp_sum( charge, intra_bgrp_comm )
---
>         CALL mp_sum( charge, intra_image_comm )
176c177
<      &      TRIM(file_name), charge / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      &      TRIM(file_name), charge / DBLE(nr1*nr2*nr3)
Only in ../../../ffn2_tsvdw_master/CPV: ksstates.F90
Only in ../../../ffn2_tsvdw_master/CPV: ksstates.o
Only in .: ldaU.f90
Only in ../../../ffn2_tsvdw_master/CPV: ldau.mod
Only in .: ldaUpen.f90
Only in ../../../ffn2_tsvdw_master/CPV: libcp.a
Only in ../../../ffn2_tsvdw_master/CPV: local_pseudo.mod
Only in .: log
Only in ../../../ffn2_tsvdw_master/CPV: log.compare-all
Only in ../../../ffn2_tsvdw_master/CPV: main_loops.f90
Only in ../../../ffn2_tsvdw_master/CPV: main_loops.F90
Only in ../../../ffn2_tsvdw_master/CPV: main_loops.o
diff ./mainvar.f90 ../../../ffn2_tsvdw_master/CPV/mainvar.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
21,22c21
<   USE descriptors,       ONLY : la_descriptor
<   USE control_flags,     ONLY : lwfnscf, lwfpbe0, lwfpbe0nscf  ! Lingzhu Kong
---
>   USE control_flags,     ONLY : lwfnscf, lwfpbe0, lwfpbe0nscf             ! Lingzhu Kong
32a32,34
>   COMPLEX(DP), ALLOCATABLE :: ei1(:,:)         ! exp (i G_x dot x_I)
>   COMPLEX(DP), ALLOCATABLE :: ei2(:,:)         ! exp (i G_y dot y_I)
>   COMPLEX(DP), ALLOCATABLE :: ei3(:,:)         ! exp (i G_z dot z_I)
55,59c57,58
<   REAL(DP), ALLOCATABLE :: bephi(:,:)      ! distributed (orhto group)
<   REAL(DP), ALLOCATABLE :: becp_bgrp(:,:)  ! distributed becp (band group)
<   REAL(DP), ALLOCATABLE :: bec_bgrp(:,:)  ! distributed bec (band group)
<   REAL(DP), ALLOCATABLE :: becdr_bgrp(:,:,:)  ! distributed becdr (band group)
<   REAL(DP), ALLOCATABLE :: dbec(:,:,:,:)    ! derivative of bec distributed(ortho group) 
---
>   REAL(DP), ALLOCATABLE :: bec(:,:), becdr(:,:,:)
>   REAL(DP), ALLOCATABLE :: bephi(:,:), becp(:,:)
69c68
<   TYPE(la_descriptor), ALLOCATABLE :: descla(:) ! descriptor of the lambda distribution
---
>   INTEGER,  ALLOCATABLE :: descla(:,:) ! descriptor of the lambda distribution
70a70,73
>   INTEGER :: nlax = 0                  ! leading dimension of the distribute (by block) lambda matrix 
>   INTEGER :: nlam = 1                  ! dimension of lambda matrix, can be 1 or nlax depending on la_proc
>   INTEGER :: nrlx = 0                  ! leading dimension of the distribute (by row  ) lambda matrix
>   LOGICAL :: la_proc = .FALSE.         ! indicate if a proc own a block of lambda
87a91
>   REAL(DP),    ALLOCATABLE :: rhopr(:,:)   ! Lingzhu Kong
91d94
<   REAL(DP),    ALLOCATABLE :: rhopr(:,:)   ! Lingzhu Kong
110,119c113,114
<   !==========================================================================
<   ! Lingzhu Kong
<             
<      INTEGER  :: my_nbspx
<      INTEGER  :: nord2            ! order of expansion ( points on one side)
<      INTEGER  :: lap_neig(3,3)    ! new directions
<      REAL(DP) :: lap_dir_step(3)  ! step in the new directions
<      INTEGER  :: lap_dir_num      ! number of new directions
<      REAL(DP) :: b_lap(6)         ! coefficients of the directions
<      INTEGER  :: lap_dir(3)       ! activeness of the new directions
---
> !==========================================================================
> ! Lingzhu Kong
120a116,117
>      INTEGER  my_nbspx
>      INTEGER  nord2 ! order of expansion ( points on one side)
133c130
<      REAL(DP),    ALLOCATABLE     :: exx_potential(:, :)
---
>      REAL(DP),    ALLOCATABLE     :: exx_potential(:,:)
139a137,138
>      !Charles Swartz
>      REAL(DP),    ALLOCATABLE     :: wcenters(:,:), vwcenters(:,:)
145,146c144,145
<     SUBROUTINE allocate_mainvar( ngw, ngw_g, ngb, ngs, ng, nr1, nr2, nr3, &
<                                  nr1x, nr2x, npl, nnr, nrxxs, nat, nax,  &
---
>     SUBROUTINE allocate_mainvar( ngw, ngwt, ngb, ngs, ng, nr1, nr2, nr3, &
>                                  nr1x, nr2x, npl, nnr, nnrsx, nat, nax,  &
148c147
<                                  gstart, nudx, tpre, nbspx_bgrp )
---
>                                  gzero, nudx, tpre )
151,152c150,151
<       USE mp_global,   ONLY: np_ortho, me_ortho, intra_bgrp_comm, ortho_comm, &
<                              me_bgrp, ortho_comm_id
---
>       USE mp_global,   ONLY: np_ortho, me_ortho, intra_image_comm, ortho_comm, &
>                              me_image, ortho_comm_id, nproc_image   ! changed by Lingzhu Kong
154,155c153,155
<       USE descriptors, ONLY: la_descriptor, descla_init
< !==============================================================================
---
>       USE descriptors, ONLY: descla_siz_ , descla_init , nlax_ , la_nrlx_ , lambda_node_
> 
> !=================================================================================
157c157
<       USE mp_global,               ONLY  : nproc_image
---
>       USE mp_global,               ONLY  : nogrp
158a159
>       USE grid_dimensions,         ONLY  : nnrx
162,163c163,164
< !===============================================================================
< 
---
>       USE io_global,               ONLY  : stdout
> !=================================================================================
165,166c166,167
<       INTEGER,           INTENT(IN) :: ngw, ngw_g, ngb, ngs, ng, nr1,nr2,nr3, &
<                                        nnr, nrxxs, nat, nax, nsp, nspin, &
---
>       INTEGER,           INTENT(IN) :: ngw, ngwt, ngb, ngs, ng, nr1, nr2, nr3, &
>                                        nnr, nnrsx, nat, nax, nsp, nspin, &
169c170,171
<       INTEGER,           INTENT(IN) :: gstart, nudx
---
>       LOGICAL,           INTENT(IN) :: gzero
>       INTEGER,           INTENT(IN) :: nudx
171d172
<       INTEGER,           INTENT(IN) :: nbspx_bgrp
173,174c174
<       INTEGER  :: iss, ierr, nlam, nrcx
<       LOGICAL  :: gzero
---
>       INTEGER  :: iss, ierr
178,189c178,184
<       ALLOCATE( eigr( ngw, nat ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate eigr ', ierr )
<       ALLOCATE( sfac( ngs, nsp ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate sfac ', ierr )
<       ALLOCATE( eigrb( ngb, nat ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate eigrb ', ierr )
<       ALLOCATE( irb( 3, nat ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate irb ', ierr )
---
>       ALLOCATE( eigr( ngw, nat ) )
>       ALLOCATE( sfac( ngs, nsp ) )
>       ALLOCATE( ei1( -nr1:nr1, nat ) )
>       ALLOCATE( ei2( -nr2:nr2, nat ) )
>       ALLOCATE( ei3( -nr3:nr3, nat ) )
>       ALLOCATE( eigrb( ngb, nat ) )
>       ALLOCATE( irb( 3, nat ) )
196c191
<          ALLOCATE( kedtaus( nrxxs, nspin ) )
---
>          ALLOCATE( kedtaus( nnrsx, nspin ) )
210,225c205,209
<       ALLOCATE( ema0bg( ngw ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate ema0bg ', ierr )
<       !
<       ALLOCATE( rhor( nnr, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate rhor ', ierr )
<       ALLOCATE( vpot( nnr, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate vpot ', ierr )
<       ALLOCATE( rhos( nrxxs, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate rhos ', ierr )
<       ALLOCATE( rhog( ng,    nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate rhog ', ierr )
---
>       ALLOCATE( ema0bg( ngw ) )
>       ALLOCATE( rhor( nnr, nspin ) )
>       ALLOCATE( vpot( nnr, nspin ) )
>       ALLOCATE( rhos( nnrsx, nspin ) )
>       ALLOCATE( rhog( ng,    nspin ) )
227,235c211,212
<             ALLOCATE( drhog( ng,  nspin, 3, 3 ), STAT=ierr )
<             IF( ierr /= 0 ) &
<                CALL errore( ' allocate_mainvar ', ' unable to allocate drhog ', ierr )
<             ALLOCATE( drhor( nnr, nspin, 3, 3 ), STAT=ierr )
<             IF( ierr /= 0 ) &
<                CALL errore( ' allocate_mainvar ', ' unable to allocate drhor ', ierr )
<       ELSE
<             ALLOCATE( drhog( 1, 1, 1, 1 ) )
<             ALLOCATE( drhor( 1, 1, 1, 1 ) )
---
>             ALLOCATE( drhog( ng,  nspin, 3, 3 ) )
>             ALLOCATE( drhor( nnr, nspin, 3, 3 ) )
236a214
> 
244,245c222,224
<          ALLOCATE( coeke(-nord2:nord2, 6))
<          ALLOCATE( exx_potential(dffts%nnr,nbsp), stat=ierr)
---
>          ALLOCATE( coeke(-nord2:nord2, 3))
> !        ALLOCATE( exx_potential(dffts%nnrx,nbsp), stat=ierr)
>          ALLOCATE( exx_potential(nr1x*nr2x*dffts%npp(me_image+1),nbsp) )
257c236
< 
---
>    
261c240,244
<          print *, 'my_nbspx =', my_nbspx
---
>          write (stdout,*) 'my_nbspx =', my_nbspx
> 
>       !Charles Swartz
>          ALLOCATE( wcenters(1:3,nbsp))
> 
269a253,254
>          !Charles Swartz
>          ALLOCATE( vwcenters(3, vnbsp) )
277a263
> 
278a265
> 
283c270
<       ALLOCATE( descla( nspin ) )
---
>       ALLOCATE( descla( descla_siz_ , nspin ) )
284a272,273
>       nlax = 0
>       nrlx = 0
286c275,278
<          CALL descla_init( descla( iss ), nupdwn( iss ), nudx, np_ortho, me_ortho, ortho_comm, ortho_comm_id )
---
>          CALL descla_init( descla( :, iss ), nupdwn( iss ), nudx, np_ortho, me_ortho, ortho_comm, ortho_comm_id )
>          nlax = MAX( nlax, descla( nlax_ , iss ) )
>          nrlx = MAX( nrlx, descla( la_nrlx_ , iss ) )
>          IF( descla( lambda_node_ , iss ) > 0 ) la_proc = .TRUE.
289,290d280
<       nrcx = MAXVAL( descla( : )%nrcx )
<       !
292,300c282
<       IF( SIZE( descla ) < 2 ) THEN
<          IF( descla(1)%active_node > 0 ) &
<             nlam = descla(1)%nrcx
<       ELSE
<          IF( ( descla(1)%active_node > 0 ) .OR. ( descla(2)%active_node > 0 ) ) &
<             nlam = MAX( descla(1)%nrcx, descla(2)%nrcx )
<       END IF
< 
<       !
---
>       IF( la_proc ) nlam = nlax
305,310c287,294
<       if ( abivol.or.abisur ) then
<          !
<          allocate(rho_gaus(nnr))
<          allocate(v_vol(nnr))
<          if (jellium.or.t_gauss) allocate(posv(3,nr1*nr2*nr3))
<          if (t_gauss) allocate(f_vol(3,nax,nsp))
---
>          if ( abivol.or.abisur ) then
>             !
>             allocate(rho_gaus(nnr))
>             allocate(v_vol(nnr))
>             if (jellium.or.t_gauss) allocate(posv(3,nr1*nr2*nr3))
>             if (t_gauss) allocate(f_vol(3,nax,nsp))
>             !
>          end if
312,322c296,298
<       end if
<       !
<       ALLOCATE( lambda(  nlam, nlam, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate lambda ', ierr )
<       ALLOCATE( lambdam( nlam, nlam, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate lambdam ', ierr )
<       ALLOCATE( lambdap( nlam, nlam, nspin ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate lambdap ', ierr )
---
>       ALLOCATE( lambda(  nlam, nlam, nspin ) )
>       ALLOCATE( lambdam( nlam, nlam, nspin ) )
>       ALLOCATE( lambdap( nlam, nlam, nspin ) )
326,337c302
<       ALLOCATE( becdr_bgrp( nhsa, nbspx_bgrp, 3 ), STAT=ierr )  
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate becdr_bgrp ', ierr )
<       ALLOCATE( bec_bgrp( nhsa, nbspx_bgrp ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate bec_bgrp ', ierr )
<       ALLOCATE( bephi( nhsa, nspin*nrcx ), STAT=ierr )
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate becphi ', ierr )
<       ALLOCATE( becp_bgrp( nhsa, nbspx_bgrp ), STAT=ierr )  
<       IF( ierr /= 0 ) &
<          CALL errore( ' allocate_mainvar ', ' unable to allocate becp_bgrp ', ierr )
---
>       ALLOCATE( becdr( nhsa, nspin*nlax, 3 ) )  
339,347c304,307
<       IF ( tpre ) THEN
<         ALLOCATE( dbec( nhsa, 2*nrcx, 3, 3 ), STAT=ierr )
<         IF( ierr /= 0 ) &
<            CALL errore( ' allocate_mainvar ', ' unable to allocate dbec ', ierr )
<       ELSE
<         ALLOCATE( dbec( 1, 1, 1, 1 ) )
<       END IF
< 
<       gzero =  (gstart == 2)
---
>       ALLOCATE( bec( nhsa, n ) )
>       !
>       ALLOCATE( bephi( nhsa, nspin*nlax ) )
>       ALLOCATE( becp(  nhsa, n ) )
349c309
<       CALL wave_descriptor_init( wfill, ngw, ngw_g, nupdwn,  nupdwn, &
---
>       CALL wave_descriptor_init( wfill, ngw, ngwt, nupdwn,  nupdwn, &
359a320,322
>       IF( ALLOCATED( ei1 ) )     DEALLOCATE( ei1 )
>       IF( ALLOCATED( ei2 ) )     DEALLOCATE( ei2 )
>       IF( ALLOCATED( ei3 ) )     DEALLOCATE( ei3 )
370a334,335
>          !Charles Swartz
>          IF( ALLOCATED( wcenters ) )       DEALLOCATE( wcenters )
376c341
<          
---
> 
378a344,345
>          !Charles Swartz
>          IF( ALLOCATED( vwcenters) )       DEALLOCATE( vwcenters )
395,396c362,363
<       IF( ALLOCATED( bec_bgrp ) )     DEALLOCATE( bec_bgrp )
<       IF( ALLOCATED( becdr_bgrp ) )   DEALLOCATE( becdr_bgrp )
---
>       IF( ALLOCATED( bec ) )     DEALLOCATE( bec )
>       IF( ALLOCATED( becdr ) )   DEALLOCATE( becdr )
398,399c365
<       IF( ALLOCATED( becp_bgrp ) )    DEALLOCATE( becp_bgrp )
<       IF( ALLOCATED( dbec ) )    DEALLOCATE( dbec )
---
>       IF( ALLOCATED( becp ) )    DEALLOCATE( becp )
413a380,560
>     !
>     !
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE distribute_lambda( lambda_repl, lambda_dist, desc )
>        USE descriptors, ONLY: lambda_node_ , ilar_ , ilac_ , nlac_ , nlar_
>        REAL(DP), INTENT(IN)  :: lambda_repl(:,:)
>        REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:)
>        INTEGER :: i, j, ic, ir
>        IF( desc( lambda_node_ ) > 0 ) THEN
>           ir = desc( ilar_ )       
>           ic = desc( ilac_ )       
>           DO j = 1, desc( nlac_ )
>              DO i = 1, desc( nlar_ )
>                 lambda_dist( i, j ) = lambda_repl( i + ir - 1, j + ic - 1 )
>              END DO
>           END DO
>        END IF
>        RETURN
>     END SUBROUTINE distribute_lambda
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE distribute_bec( bec_repl, bec_dist, desc, nspin )
>        USE descriptors, ONLY: lambda_node_ , ilar_ , nlar_ , la_n_ , nlax_
>        REAL(DP), INTENT(IN)  :: bec_repl(:,:)
>        REAL(DP), INTENT(OUT) :: bec_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:,:)
>        INTEGER,  INTENT(IN)  :: nspin
>        INTEGER :: i, ir, n, nlax
>        !
>        IF( desc( lambda_node_ , 1 ) > 0 ) THEN
>           !
>           bec_dist = 0.0d0
>           !
>           ir = desc( ilar_ , 1 )
>           DO i = 1, desc( nlar_ , 1 )
>              bec_dist( :, i ) = bec_repl( :, i + ir - 1 )
>           END DO
>           !
>           IF( nspin == 2 ) THEN
>              n     = desc( la_n_ , 1 )  !  number of states with spin 1 ( nupdw(1) )
>              nlax  = desc( nlax_ , 1 )   !  array elements reserved for each spin ( bec(:,2*nlax) )
>              ir = desc( ilar_ , 2 )
>              DO i = 1, desc( nlar_ , 2 )
>                 bec_dist( :, i + nlax ) = bec_repl( :, i + ir - 1 + n )
>              END DO
>           END IF
>           !
>        END IF
>        RETURN
>     END SUBROUTINE distribute_bec
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE distribute_zmat( zmat_repl, zmat_dist, desc )
>        USE descriptors, ONLY: lambda_node_ , la_nrl_ , la_me_ , la_npr_ , la_npc_ , la_n_
>        REAL(DP), INTENT(IN)  :: zmat_repl(:,:)
>        REAL(DP), INTENT(OUT) :: zmat_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:)
>        INTEGER :: i, ii, j, me, np
>        me = desc( la_me_ )
>        np = desc( la_npc_ ) * desc( la_npr_ )
>        IF( desc( lambda_node_ ) > 0 ) THEN
>           DO j = 1, desc( la_n_ )
>              ii = me + 1
>              DO i = 1, desc( la_nrl_ )
>                 zmat_dist( i, j ) = zmat_repl( ii, j )
>                 ii = ii + np
>              END DO
>           END DO
>        END IF
>        RETURN
>     END SUBROUTINE distribute_zmat
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE collect_lambda( lambda_repl, lambda_dist, desc )
>        USE mp_global,   ONLY: intra_image_comm
>        USE mp,          ONLY: mp_sum
>        USE descriptors, ONLY: lambda_node_ , ilar_ , ilac_ , nlac_ , nlar_
>        REAL(DP), INTENT(OUT) :: lambda_repl(:,:)
>        REAL(DP), INTENT(IN)  :: lambda_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:)
>        INTEGER :: i, j, ic, ir
>        lambda_repl = 0.0d0
>        IF( desc( lambda_node_ ) > 0 ) THEN
>           ir = desc( ilar_ )       
>           ic = desc( ilac_ )       
>           DO j = 1, desc( nlac_ )
>              DO i = 1, desc( nlar_ )
>                 lambda_repl( i + ir - 1, j + ic - 1 ) = lambda_dist( i, j )
>              END DO
>           END DO
>        END IF
>        CALL mp_sum( lambda_repl, intra_image_comm )
>        RETURN
>     END SUBROUTINE collect_lambda
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE collect_bec( bec_repl, bec_dist, desc, nspin )
>        USE mp_global,   ONLY: intra_image_comm
>        USE mp,          ONLY: mp_sum
>        USE descriptors, ONLY: lambda_node_ , ilar_ , nlar_ , la_myc_ , nlax_ , la_n_
>        REAL(DP), INTENT(OUT) :: bec_repl(:,:)
>        REAL(DP), INTENT(IN)  :: bec_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:,:)
>        INTEGER,  INTENT(IN)  :: nspin
>        INTEGER :: i, ir, n, nlax, iss
>        !
>        bec_repl = 0.0d0
>        !
>        !  bec is distributed across row processor, the first column is enough
>        !
>        IF( ( desc( lambda_node_ , 1 ) > 0 ) .AND. ( desc( la_myc_ , 1 ) == 1 ) ) THEN
>           ir = desc( ilar_ , 1 )
>           DO i = 1, desc( nlar_ , 1 )
>              bec_repl( :, i + ir - 1 ) = bec_dist( :, i )
>           END DO
>           IF( nspin == 2 ) THEN
>              n  = desc( la_n_ , 1 )   ! number of states with spin==1 ( nupdw(1) )
>              nlax = desc( nlax_ , 1 ) ! array elements reserved for each spin ( bec(:,2*nlax) )
>              ir = desc( ilar_ , 2 )
>              DO i = 1, desc( nlar_ , 2 )
>                 bec_repl( :, i + ir - 1 + n ) = bec_dist( :, i + nlax )
>              END DO
>           END IF
>        END IF
>        !
>        CALL mp_sum( bec_repl, intra_image_comm )
>        !
>        RETURN
>     END SUBROUTINE collect_bec
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE collect_zmat( zmat_repl, zmat_dist, desc )
>        USE mp_global,   ONLY: intra_image_comm
>        USE mp,          ONLY: mp_sum
>        USE descriptors, ONLY: lambda_node_ , la_nrl_ , la_me_ , la_npr_ , la_npc_ , la_n_
>        REAL(DP), INTENT(OUT) :: zmat_repl(:,:)
>        REAL(DP), INTENT(IN)  :: zmat_dist(:,:)
>        INTEGER,  INTENT(IN)  :: desc(:)
>        INTEGER :: i, ii, j, me, np, nrl
>        zmat_repl = 0.0d0
>        me = desc( la_me_ )
>        np = desc( la_npc_ ) * desc( la_npr_ )
>        nrl = desc( la_nrl_ )
>        IF( desc( lambda_node_ ) > 0 ) THEN
>           DO j = 1, desc( la_n_ )
>              ii = me + 1
>              DO i = 1, nrl
>                 zmat_repl( ii, j ) = zmat_dist( i, j )
>                 ii = ii + np
>              END DO
>           END DO
>        END IF
>        CALL mp_sum( zmat_repl, intra_image_comm )
>        RETURN
>     END SUBROUTINE collect_zmat
>     !
>     !
>     !------------------------------------------------------------------------
>     SUBROUTINE setval_lambda( lambda_dist, i, j, val, desc )
>        USE descriptors, ONLY: lambda_node_ , ilar_ , ilac_ , nlac_ , nlar_
>        REAL(DP), INTENT(OUT) :: lambda_dist(:,:)
>        INTEGER,  INTENT(IN)  :: i, j
>        REAL(DP), INTENT(IN)  :: val
>        INTEGER,  INTENT(IN)  :: desc(:)
>        IF( desc( lambda_node_ ) > 0 ) THEN
>           IF( ( i >= desc( ilar_ ) ) .AND. ( i - desc( ilar_ ) + 1 <= desc( nlar_ ) ) ) THEN
>              IF( ( j >= desc( ilac_ ) ) .AND. ( j - desc( ilac_ ) + 1 <= desc( nlac_ ) ) ) THEN
>                 lambda_dist( i - desc( ilar_ ) + 1, j - desc( ilac_ ) + 1 ) = val
>              END IF
>           END IF
>        END IF
>        RETURN
>     END SUBROUTINE setval_lambda
>     !
Only in ../../../ffn2_tsvdw_master/CPV: mainvar.F90
Only in ../../../ffn2_tsvdw_master/CPV: mainvar.o
diff ./make.depend ../../../ffn2_tsvdw_master/CPV/make.depend
1,41c1,34
< atoms_type.o : ../../Modules/cell_base.o
< atoms_type.o : ../../Modules/kind.o
< atoms_type.o : ../../Modules/parameters.o
< berry_phase.o : ../../Modules/io_global.o
< berry_phase.o : ../../Modules/mp.o
< berry_phase.o : ../../Modules/mp_global.o
< berry_phase.o : ../../Modules/recvec.o
< berry_phase.o : ../../Modules/stick_base.o
< berryion.o : ../../Modules/cell_base.o
< berryion.o : ../../Modules/constants.o
< berryion.o : ../../Modules/ions_base.o
< berryion.o : ../../Modules/kind.o
< bforceion.o : ../../Modules/cell_base.o
< bforceion.o : ../../Modules/constants.o
< bforceion.o : ../../Modules/electrons_base.o
< bforceion.o : ../../Modules/ions_base.o
< bforceion.o : ../../Modules/kind.o
< bforceion.o : ../../Modules/mp_global.o
< bforceion.o : ../../Modules/uspp.o
< cell_nose.o : ../../Modules/constants.o
< cell_nose.o : ../../Modules/control_flags.o
< cell_nose.o : ../../Modules/io_global.o
< cell_nose.o : ../../Modules/kind.o
< cg.o : ../../Modules/electrons_base.o
< cg.o : ../../Modules/io_global.o
< cg.o : ../../Modules/kind.o
< cg.o : gvecw.o
< cg_sub.o : ../../Modules/cell_base.o
< cg_sub.o : ../../Modules/constants.o
< cg_sub.o : ../../Modules/control_flags.o
< cg_sub.o : ../../Modules/descriptors.o
< cg_sub.o : ../../Modules/electrons_base.o
< cg_sub.o : ../../Modules/fft_base.o
< cg_sub.o : ../../Modules/io_files.o
< cg_sub.o : ../../Modules/io_global.o
< cg_sub.o : ../../Modules/ions_base.o
< cg_sub.o : ../../Modules/kind.o
< cg_sub.o : ../../Modules/mp.o
< cg_sub.o : ../../Modules/mp_global.o
< cg_sub.o : ../../Modules/recvec.o
< cg_sub.o : ../../Modules/uspp.o
---
> atoms_type.o : ../Modules/cell_base.o
> atoms_type.o : ../Modules/kind.o
> atoms_type.o : ../Modules/parameters.o
> berryion.o : ../Modules/cell_base.o
> berryion.o : ../Modules/constants.o
> berryion.o : ../Modules/ions_base.o
> bforceion.o : ../Modules/cell_base.o
> bforceion.o : ../Modules/constants.o
> bforceion.o : ../Modules/electrons_base.o
> bforceion.o : ../Modules/ions_base.o
> bforceion.o : ../Modules/parameters.o
> bforceion.o : ../Modules/uspp.o
> bforceion.o : mainvar.o
> bforceion.o : modules.o
> cg.o : ../Modules/electrons_base.o
> cg.o : ../Modules/io_global.o
> cg.o : ../Modules/kind.o
> cg.o : ../Modules/recvec.o
> cg_sub.o : ../Modules/cell_base.o
> cg_sub.o : ../Modules/constants.o
> cg_sub.o : ../Modules/control_flags.o
> cg_sub.o : ../Modules/descriptors.o
> cg_sub.o : ../Modules/electrons_base.o
> cg_sub.o : ../Modules/energies.o
> cg_sub.o : ../Modules/griddim.o
> cg_sub.o : ../Modules/io_files.o
> cg_sub.o : ../Modules/io_global.o
> cg_sub.o : ../Modules/ions_base.o
> cg_sub.o : ../Modules/kind.o
> cg_sub.o : ../Modules/mp.o
> cg_sub.o : ../Modules/mp_global.o
> cg_sub.o : ../Modules/recvec.o
> cg_sub.o : ../Modules/uspp.o
> cg_sub.o : ../Modules/wavefunctions.o
46d38
< cg_sub.o : energies.o
48d39
< cg_sub.o : gvecw.o
53,66c44,57
< cg_sub.o : smallbox_gvec.o
< cglib.o : ../../Modules/cell_base.o
< cglib.o : ../../Modules/constants.o
< cglib.o : ../../Modules/descriptors.o
< cglib.o : ../../Modules/dspev_drv.o
< cglib.o : ../../Modules/electrons_base.o
< cglib.o : ../../Modules/io_global.o
< cglib.o : ../../Modules/ions_base.o
< cglib.o : ../../Modules/kind.o
< cglib.o : ../../Modules/mp.o
< cglib.o : ../../Modules/mp_global.o
< cglib.o : ../../Modules/ptoolkit.o
< cglib.o : ../../Modules/recvec.o
< cglib.o : ../../Modules/uspp.o
---
> cglib.o : ../Modules/cell_base.o
> cglib.o : ../Modules/constants.o
> cglib.o : ../Modules/control_flags.o
> cglib.o : ../Modules/descriptors.o
> cglib.o : ../Modules/dspev_drv.o
> cglib.o : ../Modules/electrons_base.o
> cglib.o : ../Modules/io_global.o
> cglib.o : ../Modules/ions_base.o
> cglib.o : ../Modules/kind.o
> cglib.o : ../Modules/mp.o
> cglib.o : ../Modules/mp_global.o
> cglib.o : ../Modules/ptoolkit.o
> cglib.o : ../Modules/recvec.o
> cglib.o : ../Modules/uspp.o
68d58
< cglib.o : gvecw.o
70,86c60,78
< chargedensity.o : ../../Modules/cell_base.o
< chargedensity.o : ../../Modules/constants.o
< chargedensity.o : ../../Modules/control_flags.o
< chargedensity.o : ../../Modules/electrons_base.o
< chargedensity.o : ../../Modules/fft_base.o
< chargedensity.o : ../../Modules/fft_interfaces.o
< chargedensity.o : ../../Modules/funct.o
< chargedensity.o : ../../Modules/io_files.o
< chargedensity.o : ../../Modules/io_global.o
< chargedensity.o : ../../Modules/ions_base.o
< chargedensity.o : ../../Modules/kind.o
< chargedensity.o : ../../Modules/mp.o
< chargedensity.o : ../../Modules/mp_global.o
< chargedensity.o : ../../Modules/parallel_include.o
< chargedensity.o : ../../Modules/recvec.o
< chargedensity.o : ../../Modules/uspp.o
< chargedensity.o : ../../Modules/xml_io_base.o
---
> cglib.o : modules.o
> chargedensity.o : ../Modules/cell_base.o
> chargedensity.o : ../Modules/constants.o
> chargedensity.o : ../Modules/control_flags.o
> chargedensity.o : ../Modules/electrons_base.o
> chargedensity.o : ../Modules/fft_base.o
> chargedensity.o : ../Modules/funct.o
> chargedensity.o : ../Modules/griddim.o
> chargedensity.o : ../Modules/io_files.o
> chargedensity.o : ../Modules/io_global.o
> chargedensity.o : ../Modules/ions_base.o
> chargedensity.o : ../Modules/kind.o
> chargedensity.o : ../Modules/mp.o
> chargedensity.o : ../Modules/mp_global.o
> chargedensity.o : ../Modules/parallel_include.o
> chargedensity.o : ../Modules/recvec.o
> chargedensity.o : ../Modules/smallbox.o
> chargedensity.o : ../Modules/uspp.o
> chargedensity.o : ../Modules/xml_io_base.o
89d80
< chargedensity.o : gvecw.o
92,93d82
< chargedensity.o : smallbox.o
< chargedensity.o : smallbox_gvec.o
95,104c84,128
< cp_autopilot.o : ../../Modules/autopilot.o
< cp_autopilot.o : ../../Modules/control_flags.o
< cp_autopilot.o : ../../Modules/input_parameters.o
< cp_autopilot.o : ../../Modules/io_global.o
< cp_autopilot.o : ../../Modules/ions_base.o
< cp_autopilot.o : ../../Modules/kind.o
< cp_autopilot.o : ../../Modules/mp.o
< cp_autopilot.o : ../../Modules/parser.o
< cp_autopilot.o : ../../Modules/timestep.o
< cp_autopilot.o : ../../Modules/wave_base.o
---
> compute_fes_grads.o : ../Modules/cell_base.o
> compute_fes_grads.o : ../Modules/check_stop.o
> compute_fes_grads.o : ../Modules/constants.o
> compute_fes_grads.o : ../Modules/constraints_module.o
> compute_fes_grads.o : ../Modules/control_flags.o
> compute_fes_grads.o : ../Modules/input_parameters.o
> compute_fes_grads.o : ../Modules/io_files.o
> compute_fes_grads.o : ../Modules/io_global.o
> compute_fes_grads.o : ../Modules/ions_base.o
> compute_fes_grads.o : ../Modules/kind.o
> compute_fes_grads.o : ../Modules/metadyn_base.o
> compute_fes_grads.o : ../Modules/metadyn_io.o
> compute_fes_grads.o : ../Modules/metadyn_vars.o
> compute_fes_grads.o : ../Modules/mp.o
> compute_fes_grads.o : ../Modules/mp_global.o
> compute_fes_grads.o : ../Modules/path_formats.o
> compute_fes_grads.o : ../Modules/path_io_routines.o
> compute_fes_grads.o : ../Modules/path_variables.o
> compute_fes_grads.o : ../Modules/wave_base.o
> compute_fes_grads.o : ../Modules/xml_io_base.o
> compute_fes_grads.o : input.o
> compute_fes_grads.o : ions_positions.o
> compute_fes_grads.o : mainvar.o
> compute_scf.o : ../Modules/check_stop.o
> compute_scf.o : ../Modules/control_flags.o
> compute_scf.o : ../Modules/io_files.o
> compute_scf.o : ../Modules/io_global.o
> compute_scf.o : ../Modules/ions_base.o
> compute_scf.o : ../Modules/kind.o
> compute_scf.o : ../Modules/path_formats.o
> compute_scf.o : ../Modules/path_variables.o
> compute_scf.o : ../Modules/xml_io_base.o
> compute_scf.o : input.o
> compute_scf.o : mainvar.o
> cp_autopilot.o : ../Modules/autopilot.o
> cp_autopilot.o : ../Modules/control_flags.o
> cp_autopilot.o : ../Modules/input_parameters.o
> cp_autopilot.o : ../Modules/io_global.o
> cp_autopilot.o : ../Modules/ions_base.o
> cp_autopilot.o : ../Modules/ions_nose.o
> cp_autopilot.o : ../Modules/kind.o
> cp_autopilot.o : ../Modules/mp.o
> cp_autopilot.o : ../Modules/parser.o
> cp_autopilot.o : ../Modules/timestep.o
> cp_autopilot.o : ../Modules/wave_base.o
106,114c130,158
< cp_autopilot.o : ions_nose.o
< cp_emass.o : ../../Modules/control_flags.o
< cp_emass.o : ../../Modules/kind.o
< cp_interfaces.o : ../../Modules/cell_base.o
< cp_interfaces.o : ../../Modules/descriptors.o
< cp_interfaces.o : ../../Modules/fft_base.o
< cp_interfaces.o : ../../Modules/ions_base.o
< cp_interfaces.o : ../../Modules/kind.o
< cp_interfaces.o : ../../Modules/recvec.o
---
> cp_emass.o : ../Modules/control_flags.o
> cp_emass.o : ../Modules/kind.o
> cp_fpmd.o : ../Modules/cell_base.o
> cp_fpmd.o : ../Modules/constants.o
> cp_fpmd.o : ../Modules/constraints_module.o
> cp_fpmd.o : ../Modules/control_flags.o
> cp_fpmd.o : ../Modules/electrons_base.o
> cp_fpmd.o : ../Modules/fft_base.o
> cp_fpmd.o : ../Modules/funct.o
> cp_fpmd.o : ../Modules/griddim.o
> cp_fpmd.o : ../Modules/io_global.o
> cp_fpmd.o : ../Modules/ions_base.o
> cp_fpmd.o : ../Modules/ions_nose.o
> cp_fpmd.o : ../Modules/kind.o
> cp_fpmd.o : ../Modules/mp.o
> cp_fpmd.o : ../Modules/mp_global.o
> cp_fpmd.o : ../Modules/recvec.o
> cp_fpmd.o : ../Modules/smallbox.o
> cp_fpmd.o : ../Modules/uspp.o
> cp_fpmd.o : cpr_mod.o
> cp_fpmd.o : pseudopot.o
> cp_interfaces.o : ../Modules/cell_base.o
> cp_interfaces.o : ../Modules/descriptors.o
> cp_interfaces.o : ../Modules/fft_types.o
> cp_interfaces.o : ../Modules/griddim.o
> cp_interfaces.o : ../Modules/ions_base.o
> cp_interfaces.o : ../Modules/kind.o
> cp_interfaces.o : ../Modules/recvec.o
> cp_interfaces.o : ../Modules/uspp.o
116,135c160,180
< cp_restart.o : ../../Modules/cell_base.o
< cp_restart.o : ../../Modules/constants.o
< cp_restart.o : ../../Modules/control_flags.o
< cp_restart.o : ../../Modules/electrons_base.o
< cp_restart.o : ../../Modules/fft_base.o
< cp_restart.o : ../../Modules/funct.o
< cp_restart.o : ../../Modules/io_files.o
< cp_restart.o : ../../Modules/io_global.o
< cp_restart.o : ../../Modules/ions_base.o
< cp_restart.o : ../../Modules/kind.o
< cp_restart.o : ../../Modules/mp.o
< cp_restart.o : ../../Modules/mp_global.o
< cp_restart.o : ../../Modules/parameters.o
< cp_restart.o : ../../Modules/parser.o
< cp_restart.o : ../../Modules/recvec.o
< cp_restart.o : ../../Modules/run_info.o
< cp_restart.o : ../../Modules/uspp.o
< cp_restart.o : ../../Modules/version.o
< cp_restart.o : ../../Modules/xml_io_base.o
< cp_restart.o : ../../iotk/src/iotk_module.o
---
> cp_restart.o : ../Modules/cell_base.o
> cp_restart.o : ../Modules/constants.o
> cp_restart.o : ../Modules/control_flags.o
> cp_restart.o : ../Modules/electrons_base.o
> cp_restart.o : ../Modules/energies.o
> cp_restart.o : ../Modules/fft_base.o
> cp_restart.o : ../Modules/funct.o
> cp_restart.o : ../Modules/griddim.o
> cp_restart.o : ../Modules/io_files.o
> cp_restart.o : ../Modules/io_global.o
> cp_restart.o : ../Modules/ions_base.o
> cp_restart.o : ../Modules/kind.o
> cp_restart.o : ../Modules/mp.o
> cp_restart.o : ../Modules/mp_global.o
> cp_restart.o : ../Modules/parameters.o
> cp_restart.o : ../Modules/parser.o
> cp_restart.o : ../Modules/printout_base.o
> cp_restart.o : ../Modules/recvec.o
> cp_restart.o : ../Modules/version.o
> cp_restart.o : ../Modules/xml_io_base.o
> cp_restart.o : ../iotk/src/iotk_module.o
137,139d181
< cp_restart.o : energies.o
< cp_restart.o : gvecw.o
< cp_restart.o : ldaU.o
141,158c183,204
< cp_restart.o : wannier_base.o
< cplib.o : ../../Modules/atom.o
< cplib.o : ../../Modules/cell_base.o
< cplib.o : ../../Modules/constants.o
< cplib.o : ../../Modules/constraints_module.o
< cplib.o : ../../Modules/control_flags.o
< cplib.o : ../../Modules/descriptors.o
< cplib.o : ../../Modules/electrons_base.o
< cplib.o : ../../Modules/fft_base.o
< cplib.o : ../../Modules/fft_interfaces.o
< cplib.o : ../../Modules/funct.o
< cplib.o : ../../Modules/io_global.o
< cplib.o : ../../Modules/ions_base.o
< cplib.o : ../../Modules/kind.o
< cplib.o : ../../Modules/mp.o
< cplib.o : ../../Modules/mp_global.o
< cplib.o : ../../Modules/recvec.o
< cplib.o : ../../Modules/uspp.o
---
> cplib.o : ../Modules/atom.o
> cplib.o : ../Modules/cell_base.o
> cplib.o : ../Modules/constants.o
> cplib.o : ../Modules/control_flags.o
> cplib.o : ../Modules/descriptors.o
> cplib.o : ../Modules/dspev_drv.o
> cplib.o : ../Modules/electrons_base.o
> cplib.o : ../Modules/energies.o
> cplib.o : ../Modules/fft_base.o
> cplib.o : ../Modules/fft_types.o
> cplib.o : ../Modules/funct.o
> cplib.o : ../Modules/griddim.o
> cplib.o : ../Modules/input_parameters.o
> cplib.o : ../Modules/io_global.o
> cplib.o : ../Modules/ions_base.o
> cplib.o : ../Modules/kind.o
> cplib.o : ../Modules/mp.o
> cplib.o : ../Modules/mp_global.o
> cplib.o : ../Modules/recvec.o
> cplib.o : ../Modules/sic.o
> cplib.o : ../Modules/smallbox.o
> cplib.o : ../Modules/uspp.o
160,162c206
< cplib.o : cpr_mod.o
< cplib.o : gvecw.o
< cplib.o : ions_nose.o
---
> cplib.o : mainvar.o
164,181c208,223
< cplib.o : pseudo_base.o
< cplib.o : pseudopot.o
< cplib.o : smallbox_gvec.o
< cplib.o : spline.o
< cplib_meta.o : ../../Modules/cell_base.o
< cplib_meta.o : ../../Modules/constants.o
< cplib_meta.o : ../../Modules/control_flags.o
< cplib_meta.o : ../../Modules/electrons_base.o
< cplib_meta.o : ../../Modules/fft_base.o
< cplib_meta.o : ../../Modules/fft_interfaces.o
< cplib_meta.o : ../../Modules/io_global.o
< cplib_meta.o : ../../Modules/ions_base.o
< cplib_meta.o : ../../Modules/kind.o
< cplib_meta.o : ../../Modules/mp.o
< cplib_meta.o : ../../Modules/mp_global.o
< cplib_meta.o : ../../Modules/recvec.o
< cplib_meta.o : energies.o
< cplib_meta.o : gvecw.o
---
> cplib.o : pres_ai_mod.o
> cplib.o : tsvdw.o
> cplib_meta.o : ../Modules/cell_base.o
> cplib_meta.o : ../Modules/constants.o
> cplib_meta.o : ../Modules/control_flags.o
> cplib_meta.o : ../Modules/electrons_base.o
> cplib_meta.o : ../Modules/energies.o
> cplib_meta.o : ../Modules/fft_base.o
> cplib_meta.o : ../Modules/griddim.o
> cplib_meta.o : ../Modules/io_global.o
> cplib_meta.o : ../Modules/ions_base.o
> cplib_meta.o : ../Modules/kind.o
> cplib_meta.o : ../Modules/mp.o
> cplib_meta.o : ../Modules/mp_global.o
> cplib_meta.o : ../Modules/recvec.o
> cplib_meta.o : cp_interfaces.o
183,203c225,248
< cplib_meta.o : smallbox_gvec.o
< cpr.o : ../../Modules/autopilot.o
< cpr.o : ../../Modules/cell_base.o
< cpr.o : ../../Modules/check_stop.o
< cpr.o : ../../Modules/constants.o
< cpr.o : ../../Modules/constraints_module.o
< cpr.o : ../../Modules/control_flags.o
< cpr.o : ../../Modules/electrons_base.o
< cpr.o : ../../Modules/fft_base.o
< cpr.o : ../../Modules/io_files.o
< cpr.o : ../../Modules/io_global.o
< cpr.o : ../../Modules/ions_base.o
< cpr.o : ../../Modules/kind.o
< cpr.o : ../../Modules/mp.o
< cpr.o : ../../Modules/mp_global.o
< cpr.o : ../../Modules/recvec.o
< cpr.o : ../../Modules/timestep.o
< cpr.o : ../../Modules/uspp.o
< cpr.o : ../../Modules/wave_base.o
< cpr.o : ../../Modules/wavefunctions.o
< cpr.o : cell_nose.o
---
> cpr.o : ../Modules/autopilot.o
> cpr.o : ../Modules/cell_base.o
> cpr.o : ../Modules/check_stop.o
> cpr.o : ../Modules/constants.o
> cpr.o : ../Modules/constraints_module.o
> cpr.o : ../Modules/control_flags.o
> cpr.o : ../Modules/electrons_base.o
> cpr.o : ../Modules/energies.o
> cpr.o : ../Modules/griddim.o
> cpr.o : ../Modules/io_files.o
> cpr.o : ../Modules/io_global.o
> cpr.o : ../Modules/ions_base.o
> cpr.o : ../Modules/ions_nose.o
> cpr.o : ../Modules/kind.o
> cpr.o : ../Modules/metadyn_base.o
> cpr.o : ../Modules/mp.o
> cpr.o : ../Modules/mp_global.o
> cpr.o : ../Modules/printout_base.o
> cpr.o : ../Modules/recvec.o
> cpr.o : ../Modules/smallbox.o
> cpr.o : ../Modules/timestep.o
> cpr.o : ../Modules/uspp.o
> cpr.o : ../Modules/wave_base.o
> cpr.o : ../Modules/wavefunctions.o
209,211d253
< cpr.o : electrons.o
< cpr.o : electrons_nose.o
< cpr.o : energies.o
213,214d254
< cpr.o : gvecw.o
< cpr.o : ions_nose.o
216d255
< cpr.o : ldaU.o
221c260
< cpr.o : smallbox_gvec.o
---
> cpr.o : tsvdw.o
223,231c262,266
< cpr_loop.o : ../../Modules/ions_base.o
< cpr_loop.o : ../../Modules/kind.o
< cpr_mod.o : ../../Modules/kind.o
< cprstart.o : ../../Modules/check_stop.o
< cprstart.o : ../../Modules/control_flags.o
< cprstart.o : ../../Modules/environment.o
< cprstart.o : ../../Modules/io_global.o
< cprstart.o : ../../Modules/mp_global.o
< cprstart.o : ../../Modules/read_input.o
---
> cpr_mod.o : ../Modules/kind.o
> cprstart.o : ../Modules/check_stop.o
> cprstart.o : ../Modules/control_flags.o
> cprstart.o : ../Modules/environment.o
> cprstart.o : ../Modules/mp_global.o
233,241c268,298
< dealloc.o : ../../Modules/electrons_base.o
< dealloc.o : ../../Modules/fft_base.o
< dealloc.o : ../../Modules/fft_types.o
< dealloc.o : ../../Modules/ions_base.o
< dealloc.o : ../../Modules/recvec.o
< dealloc.o : ../../Modules/sic.o
< dealloc.o : ../../Modules/stick_base.o
< dealloc.o : ../../Modules/uspp.o
< dealloc.o : ../../Modules/wavefunctions.o
---
> cprsub.o : ../Modules/atom.o
> cprsub.o : ../Modules/cell_base.o
> cprsub.o : ../Modules/constants.o
> cprsub.o : ../Modules/control_flags.o
> cprsub.o : ../Modules/descriptors.o
> cprsub.o : ../Modules/electrons_base.o
> cprsub.o : ../Modules/griddim.o
> cprsub.o : ../Modules/io_global.o
> cprsub.o : ../Modules/ions_base.o
> cprsub.o : ../Modules/kind.o
> cprsub.o : ../Modules/mp.o
> cprsub.o : ../Modules/mp_global.o
> cprsub.o : ../Modules/recvec.o
> cprsub.o : ../Modules/uspp.o
> cprsub.o : cp_interfaces.o
> cprsub.o : cpr_mod.o
> cprsub.o : mainvar.o
> cprsub.o : modules.o
> cprsub.o : pseudo_base.o
> cprsub.o : pseudopot.o
> cprsub.o : spline.o
> dealloc.o : ../Modules/electrons_base.o
> dealloc.o : ../Modules/fft_base.o
> dealloc.o : ../Modules/fft_types.o
> dealloc.o : ../Modules/ions_base.o
> dealloc.o : ../Modules/ions_nose.o
> dealloc.o : ../Modules/recvec.o
> dealloc.o : ../Modules/sic.o
> dealloc.o : ../Modules/stick_base.o
> dealloc.o : ../Modules/uspp.o
> dealloc.o : ../Modules/wavefunctions.o
247,248d303
< dealloc.o : gvecw.o
< dealloc.o : ions_nose.o
251,252d305
< dealloc.o : ldaU.o
< dealloc.o : ldaUpen.o
257d309
< dealloc.o : smallbox_gvec.o
259,269c311,321
< dforceb.o : ../../Modules/cell_base.o
< dforceb.o : ../../Modules/constants.o
< dforceb.o : ../../Modules/electrons_base.o
< dforceb.o : ../../Modules/ions_base.o
< dforceb.o : ../../Modules/kind.o
< dforceb.o : ../../Modules/mp.o
< dforceb.o : ../../Modules/mp_global.o
< dforceb.o : ../../Modules/parallel_include.o
< dforceb.o : ../../Modules/parameters.o
< dforceb.o : ../../Modules/recvec.o
< dforceb.o : ../../Modules/uspp.o
---
> dforceb.o : ../Modules/cell_base.o
> dforceb.o : ../Modules/constants.o
> dforceb.o : ../Modules/electrons_base.o
> dforceb.o : ../Modules/ions_base.o
> dforceb.o : ../Modules/kind.o
> dforceb.o : ../Modules/mp.o
> dforceb.o : ../Modules/mp_global.o
> dforceb.o : ../Modules/parallel_include.o
> dforceb.o : ../Modules/parameters.o
> dforceb.o : ../Modules/recvec.o
> dforceb.o : ../Modules/uspp.o
271,277c323,329
< dforceb.o : gvecw.o
< efermi.o : ../../Modules/kind.o
< efield.o : ../../Modules/control_flags.o
< efield.o : ../../Modules/io_global.o
< efield.o : ../../Modules/kind.o
< efield.o : ../../Modules/uspp.o
< efield.o : gvecw.o
---
> dforceb.o : modules.o
> efermi.o : ../Modules/kind.o
> efield.o : ../Modules/control_flags.o
> efield.o : ../Modules/io_global.o
> efield.o : ../Modules/kind.o
> efield.o : ../Modules/recvec.o
> efield.o : ../Modules/uspp.o
279,287c331,339
< eigs0.o : ../../Modules/constants.o
< eigs0.o : ../../Modules/descriptors.o
< eigs0.o : ../../Modules/dspev_drv.o
< eigs0.o : ../../Modules/electrons_base.o
< eigs0.o : ../../Modules/io_global.o
< eigs0.o : ../../Modules/kind.o
< eigs0.o : ../../Modules/mp.o
< eigs0.o : ../../Modules/mp_global.o
< eigs0.o : ../../Modules/sic.o
---
> eigs0.o : ../Modules/constants.o
> eigs0.o : ../Modules/descriptors.o
> eigs0.o : ../Modules/dspev_drv.o
> eigs0.o : ../Modules/electrons_base.o
> eigs0.o : ../Modules/io_global.o
> eigs0.o : ../Modules/kind.o
> eigs0.o : ../Modules/mp.o
> eigs0.o : ../Modules/mp_global.o
> eigs0.o : ../Modules/sic.o
290,296c342,348
< electrons.o : ../../Modules/constants.o
< electrons.o : ../../Modules/dspev_drv.o
< electrons.o : ../../Modules/electrons_base.o
< electrons.o : ../../Modules/io_global.o
< electrons.o : ../../Modules/kind.o
< electrons.o : ../../Modules/mp.o
< electrons.o : ../../Modules/mp_global.o
---
> eigs0.o : mainvar.o
> electrons.o : ../Modules/constants.o
> electrons.o : ../Modules/dspev_drv.o
> electrons.o : ../Modules/electrons_base.o
> electrons.o : ../Modules/io_global.o
> electrons.o : ../Modules/kind.o
> electrons.o : ../Modules/mp_global.o
298,322c350,366
< electrons_nose.o : ../../Modules/constants.o
< electrons_nose.o : ../../Modules/control_flags.o
< electrons_nose.o : ../../Modules/io_global.o
< electrons_nose.o : ../../Modules/kind.o
< energies.o : ../../Modules/control_flags.o
< energies.o : ../../Modules/io_global.o
< energies.o : ../../Modules/kind.o
< ensemble_dft.o : ../../Modules/descriptors.o
< ensemble_dft.o : ../../Modules/io_global.o
< ensemble_dft.o : ../../Modules/kind.o
< entropy.o : ../../Modules/kind.o
< exch_corr.o : ../../Modules/cell_base.o
< exch_corr.o : ../../Modules/constants.o
< exch_corr.o : ../../Modules/control_flags.o
< exch_corr.o : ../../Modules/fft_base.o
< exch_corr.o : ../../Modules/fft_interfaces.o
< exch_corr.o : ../../Modules/funct.o
< exch_corr.o : ../../Modules/io_global.o
< exch_corr.o : ../../Modules/ions_base.o
< exch_corr.o : ../../Modules/kind.o
< exch_corr.o : ../../Modules/mp.o
< exch_corr.o : ../../Modules/mp_global.o
< exch_corr.o : ../../Modules/recvec.o
< exch_corr.o : ../../Modules/sic.o
< exch_corr.o : ../../Modules/uspp.o
---
> ensemble_dft.o : ../Modules/descriptors.o
> ensemble_dft.o : ../Modules/io_global.o
> ensemble_dft.o : ../Modules/kind.o
> entropy.o : ../Modules/kind.o
> exch_corr.o : ../Modules/cell_base.o
> exch_corr.o : ../Modules/constants.o
> exch_corr.o : ../Modules/control_flags.o
> exch_corr.o : ../Modules/fft_base.o
> exch_corr.o : ../Modules/funct.o
> exch_corr.o : ../Modules/griddim.o
> exch_corr.o : ../Modules/io_global.o
> exch_corr.o : ../Modules/ions_base.o
> exch_corr.o : ../Modules/kind.o
> exch_corr.o : ../Modules/mp.o
> exch_corr.o : ../Modules/mp_global.o
> exch_corr.o : ../Modules/recvec.o
> exch_corr.o : ../Modules/sic.o
326,408c370,390
< exx_cg.o : ../../Modules/kind.o
< exx_cg.o : mainvar.o
< exx_cg.o : wannier_base.o
< exx_es.o : ../../Modules/cell_base.o
< exx_es.o : ../../Modules/constants.o
< exx_es.o : ../../Modules/control_flags.o
< exx_es.o : ../../Modules/electrons_base.o
< exx_es.o : ../../Modules/fft_base.o
< exx_es.o : ../../Modules/io_global.o
< exx_es.o : ../../Modules/kind.o
< exx_es.o : ../../Modules/mp.o
< exx_es.o : ../../Modules/mp_global.o
< exx_es.o : ../../Modules/mp_wave.o
< exx_es.o : ../../Modules/parallel_include.o
< exx_es.o : gvecw.o
< exx_es.o : mainvar.o
< exx_es.o : printout_base.o
< exx_es.o : wannier.o
< exx_es.o : wannier_base.o
< exx_ggrid.o : ../../Modules/constants.o
< exx_ggrid.o : ../../Modules/kind.o
< exx_ggrid.o : mainvar.o
< exx_gs.o : ../../Modules/cell_base.o
< exx_gs.o : ../../Modules/constants.o
< exx_gs.o : ../../Modules/electrons_base.o
< exx_gs.o : ../../Modules/fft_base.o
< exx_gs.o : ../../Modules/input_parameters.o
< exx_gs.o : ../../Modules/io_global.o
< exx_gs.o : ../../Modules/kind.o
< exx_gs.o : ../../Modules/mp.o
< exx_gs.o : ../../Modules/mp_global.o
< exx_gs.o : ../../Modules/mp_wave.o
< exx_gs.o : ../../Modules/parallel_include.o
< exx_gs.o : energies.o
< exx_gs.o : gvecw.o
< exx_gs.o : mainvar.o
< exx_gs.o : printout_base.o
< exx_gs.o : wannier.o
< exx_gs.o : wannier_base.o
< exx_pair.o : ../../Modules/cell_base.o
< exx_pair.o : ../../Modules/electrons_base.o
< exx_pair.o : ../../Modules/kind.o
< exx_pair.o : ../../Modules/mp.o
< exx_pair.o : ../../Modules/mp_global.o
< exx_pair.o : ../../Modules/parallel_include.o
< exx_pair.o : mainvar.o
< exx_pair.o : wannier_base.o
< exx_psi.o : ../../Modules/cell_base.o
< exx_psi.o : ../../Modules/fft_base.o
< exx_psi.o : ../../Modules/fft_interfaces.o
< exx_psi.o : ../../Modules/kind.o
< exx_psi.o : ../../Modules/mp.o
< exx_psi.o : ../../Modules/mp_global.o
< exx_psi.o : ../../Modules/mp_wave.o
< exx_psi.o : ../../Modules/parallel_include.o
< exx_psi.o : gvecw.o
< exx_setup.o : ../../Modules/cell_base.o
< exx_setup.o : ../../Modules/fft_base.o
< exx_setup.o : ../../Modules/kind.o
< exx_setup.o : ../../Modules/mp_global.o
< exx_setup.o : ../../Modules/parallel_include.o
< exx_setup.o : mainvar.o
< exx_setup.o : wannier_base.o
< exx_vofr.o : ../../Modules/fft_base.o
< exx_vofr.o : ../../Modules/kind.o
< exx_vofr.o : ../../Modules/mp_global.o
< exx_vofr.o : mainvar.o
< fft.o : ../../Modules/fft_base.o
< fft.o : ../../Modules/kind.o
< fft.o : ../../Modules/mp_global.o
< fft.o : ../../Modules/recvec.o
< forces.o : ../../Modules/cell_base.o
< forces.o : ../../Modules/constants.o
< forces.o : ../../Modules/control_flags.o
< forces.o : ../../Modules/fft_base.o
< forces.o : ../../Modules/fft_interfaces.o
< forces.o : ../../Modules/funct.o
< forces.o : ../../Modules/ions_base.o
< forces.o : ../../Modules/kind.o
< forces.o : ../../Modules/mp_global.o
< forces.o : ../../Modules/parallel_include.o
< forces.o : ../../Modules/recvec.o
< forces.o : ../../Modules/uspp.o
---
> fft.o : ../Modules/fft_base.o
> fft.o : ../Modules/fft_parallel.o
> fft.o : ../Modules/fft_scalar.o
> fft.o : ../Modules/fft_types.o
> fft.o : ../Modules/griddim.o
> fft.o : ../Modules/kind.o
> fft.o : ../Modules/mp_global.o
> fft.o : ../Modules/recvec.o
> forces.o : ../Modules/cell_base.o
> forces.o : ../Modules/constants.o
> forces.o : ../Modules/control_flags.o
> forces.o : ../Modules/fft_base.o
> forces.o : ../Modules/funct.o
> forces.o : ../Modules/griddim.o
> forces.o : ../Modules/ions_base.o
> forces.o : ../Modules/kind.o
> forces.o : ../Modules/mp_global.o
> forces.o : ../Modules/parallel_include.o
> forces.o : ../Modules/recvec.o
> forces.o : ../Modules/uspp.o
> forces.o : cp_interfaces.o
410,433c392,417
< forces.o : gvecw.o
< forces.o : mainvar.o
< fpmdpp.o : ../../Modules/constants.o
< fpmdpp.o : ../../Modules/io_files.o
< fpmdpp.o : ../../Modules/io_global.o
< fpmdpp.o : ../../Modules/kind.o
< fpmdpp.o : ../../Modules/mp.o
< fpmdpp.o : ../../Modules/mp_global.o
< fpmdpp.o : ../../Modules/xml_io_base.o
< fpmdpp.o : ../../iotk/src/iotk_module.o
< fromscra.o : ../../Modules/cell_base.o
< fromscra.o : ../../Modules/control_flags.o
< fromscra.o : ../../Modules/electrons_base.o
< fromscra.o : ../../Modules/fft_base.o
< fromscra.o : ../../Modules/io_global.o
< fromscra.o : ../../Modules/ions_base.o
< fromscra.o : ../../Modules/kind.o
< fromscra.o : ../../Modules/mp.o
< fromscra.o : ../../Modules/mp_global.o
< fromscra.o : ../../Modules/recvec.o
< fromscra.o : ../../Modules/timestep.o
< fromscra.o : ../../Modules/uspp.o
< fromscra.o : ../../Modules/wave_base.o
< fromscra.o : ../../Modules/wavefunctions.o
---
> forces.o : modules.o
> fpmdpp.o : ../Modules/constants.o
> fpmdpp.o : ../Modules/io_files.o
> fpmdpp.o : ../Modules/io_global.o
> fpmdpp.o : ../Modules/kind.o
> fpmdpp.o : ../Modules/mp.o
> fpmdpp.o : ../Modules/mp_global.o
> fpmdpp.o : ../Modules/xml_io_base.o
> fpmdpp.o : ../iotk/src/iotk_module.o
> fromscra.o : ../Modules/cell_base.o
> fromscra.o : ../Modules/control_flags.o
> fromscra.o : ../Modules/electrons_base.o
> fromscra.o : ../Modules/energies.o
> fromscra.o : ../Modules/griddim.o
> fromscra.o : ../Modules/io_global.o
> fromscra.o : ../Modules/ions_base.o
> fromscra.o : ../Modules/ions_nose.o
> fromscra.o : ../Modules/kind.o
> fromscra.o : ../Modules/mp_global.o
> fromscra.o : ../Modules/printout_base.o
> fromscra.o : ../Modules/recvec.o
> fromscra.o : ../Modules/smallbox.o
> fromscra.o : ../Modules/timestep.o
> fromscra.o : ../Modules/uspp.o
> fromscra.o : ../Modules/wave_base.o
> fromscra.o : ../Modules/wavefunctions.o
435d418
< fromscra.o : cell_nose.o
441,442d423
< fromscra.o : electrons_nose.o
< fromscra.o : energies.o
444,445d424
< fromscra.o : gvecw.o
< fromscra.o : ions_nose.o
450,468c429,438
< fromscra.o : printout_base.o
< gradrho.o : ../../Modules/cell_base.o
< gradrho.o : ../../Modules/fft_base.o
< gradrho.o : ../../Modules/fft_interfaces.o
< gradrho.o : ../../Modules/recvec.o
< gram.o : ../../Modules/electrons_base.o
< gram.o : ../../Modules/ions_base.o
< gram.o : ../../Modules/kind.o
< gram.o : ../../Modules/mp.o
< gram.o : ../../Modules/mp_global.o
< gram.o : ../../Modules/recvec.o
< gram.o : ../../Modules/uspp.o
< gram.o : gvecw.o
< gtable.o : ../../Modules/io_global.o
< gtable.o : ../../Modules/kind.o
< gtable.o : ../../Modules/mp.o
< gtable.o : ../../Modules/mp_global.o
< gtable.o : ../../Modules/parallel_include.o
< gtable.o : ../../Modules/recvec.o
---
> gradrho.o : ../Modules/cell_base.o
> gradrho.o : ../Modules/fft_base.o
> gradrho.o : ../Modules/griddim.o
> gradrho.o : ../Modules/recvec.o
> gradrho.o : cp_interfaces.o
> gtable.o : ../Modules/io_global.o
> gtable.o : ../Modules/mp.o
> gtable.o : ../Modules/mp_global.o
> gtable.o : ../Modules/parallel_include.o
> gtable.o : ../Modules/recvec.o
470,489c440,455
< gtable.o : gvecw.o
< gvecw.o : ../../Modules/kind.o
< gvecw.o : ../../Modules/mp.o
< init.o : ../../Modules/cell_base.o
< init.o : ../../Modules/constants.o
< init.o : ../../Modules/control_flags.o
< init.o : ../../Modules/electrons_base.o
< init.o : ../../Modules/fft_base.o
< init.o : ../../Modules/fft_scalar.o
< init.o : ../../Modules/fft_types.o
< init.o : ../../Modules/griddim.o
< init.o : ../../Modules/io_files.o
< init.o : ../../Modules/io_global.o
< init.o : ../../Modules/ions_base.o
< init.o : ../../Modules/kind.o
< init.o : ../../Modules/mp_global.o
< init.o : ../../Modules/recvec.o
< init.o : ../../Modules/recvec_subs.o
< init.o : ../../Modules/stick_set.o
< init.o : ../../Modules/uspp.o
---
> init.o : ../Modules/berry_phase.o
> init.o : ../Modules/cell_base.o
> init.o : ../Modules/control_flags.o
> init.o : ../Modules/fft_base.o
> init.o : ../Modules/fft_types.o
> init.o : ../Modules/griddim.o
> init.o : ../Modules/io_files.o
> init.o : ../Modules/io_global.o
> init.o : ../Modules/ions_base.o
> init.o : ../Modules/kind.o
> init.o : ../Modules/mp_global.o
> init.o : ../Modules/recvec.o
> init.o : ../Modules/smallbox.o
> init.o : ../Modules/stick_base.o
> init.o : ../Modules/task_groups.o
> init.o : ../Modules/uspp.o
491,492d456
< init.o : berry_phase.o
< init.o : cp_interfaces.o
495d458
< init.o : gvecw.o
497a461
> init.o : modules.o
499,519c463,480
< init.o : smallbox.o
< init.o : smallbox_grid.o
< init.o : smallbox_subs.o
< init_run.o : ../../Modules/cell_base.o
< init_run.o : ../../Modules/control_flags.o
< init_run.o : ../../Modules/electrons_base.o
< init_run.o : ../../Modules/fft_base.o
< init_run.o : ../../Modules/funct.o
< init_run.o : ../../Modules/io_files.o
< init_run.o : ../../Modules/io_global.o
< init_run.o : ../../Modules/ions_base.o
< init_run.o : ../../Modules/kind.o
< init_run.o : ../../Modules/mp.o
< init_run.o : ../../Modules/mp_global.o
< init_run.o : ../../Modules/recvec.o
< init_run.o : ../../Modules/timestep.o
< init_run.o : ../../Modules/uspp.o
< init_run.o : ../../Modules/wavefunctions.o
< init_run.o : ../../Modules/wrappers.o
< init_run.o : ../../Modules/xml_io_base.o
< init_run.o : cell_nose.o
---
> init_run.o : ../Modules/cell_base.o
> init_run.o : ../Modules/control_flags.o
> init_run.o : ../Modules/electrons_base.o
> init_run.o : ../Modules/energies.o
> init_run.o : ../Modules/fft_base.o
> init_run.o : ../Modules/funct.o
> init_run.o : ../Modules/griddim.o
> init_run.o : ../Modules/io_files.o
> init_run.o : ../Modules/io_global.o
> init_run.o : ../Modules/ions_base.o
> init_run.o : ../Modules/ions_nose.o
> init_run.o : ../Modules/kind.o
> init_run.o : ../Modules/printout_base.o
> init_run.o : ../Modules/recvec.o
> init_run.o : ../Modules/timestep.o
> init_run.o : ../Modules/uspp.o
> init_run.o : ../Modules/wavefunctions.o
> init_run.o : ../Modules/xml_io_base.o
523d483
< init_run.o : cp_restart.o
525,526d484
< init_run.o : electrons_nose.o
< init_run.o : energies.o
528,529d485
< init_run.o : gvecw.o
< init_run.o : ions_nose.o
531d486
< init_run.o : ldaU.o
535,536c490
< init_run.o : printout_base.o
< init_run.o : smallbox_gvec.o
---
> init_run.o : tsvdw.o
538d491
< init_run.o : wannier_base.o
540,551c493,506
< inner_loop_cold.o : ../../Modules/cell_base.o
< inner_loop_cold.o : ../../Modules/descriptors.o
< inner_loop_cold.o : ../../Modules/dspev_drv.o
< inner_loop_cold.o : ../../Modules/electrons_base.o
< inner_loop_cold.o : ../../Modules/fft_base.o
< inner_loop_cold.o : ../../Modules/io_global.o
< inner_loop_cold.o : ../../Modules/ions_base.o
< inner_loop_cold.o : ../../Modules/kind.o
< inner_loop_cold.o : ../../Modules/mp.o
< inner_loop_cold.o : ../../Modules/mp_global.o
< inner_loop_cold.o : ../../Modules/recvec.o
< inner_loop_cold.o : ../../Modules/uspp.o
---
> inner_loop_cold.o : ../Modules/cell_base.o
> inner_loop_cold.o : ../Modules/control_flags.o
> inner_loop_cold.o : ../Modules/descriptors.o
> inner_loop_cold.o : ../Modules/dspev_drv.o
> inner_loop_cold.o : ../Modules/electrons_base.o
> inner_loop_cold.o : ../Modules/energies.o
> inner_loop_cold.o : ../Modules/griddim.o
> inner_loop_cold.o : ../Modules/io_global.o
> inner_loop_cold.o : ../Modules/ions_base.o
> inner_loop_cold.o : ../Modules/kind.o
> inner_loop_cold.o : ../Modules/mp.o
> inner_loop_cold.o : ../Modules/mp_global.o
> inner_loop_cold.o : ../Modules/recvec.o
> inner_loop_cold.o : ../Modules/uspp.o
554d508
< inner_loop_cold.o : energies.o
556d509
< inner_loop_cold.o : gvecw.o
560,580c513,532
< inner_loop_cold.o : smallbox_gvec.o
< input.o : ../../Modules/autopilot.o
< input.o : ../../Modules/cell_base.o
< input.o : ../../Modules/constants.o
< input.o : ../../Modules/constraints_module.o
< input.o : ../../Modules/control_flags.o
< input.o : ../../Modules/electrons_base.o
< input.o : ../../Modules/fft_base.o
< input.o : ../../Modules/input_parameters.o
< input.o : ../../Modules/io_files.o
< input.o : ../../Modules/io_global.o
< input.o : ../../Modules/ions_base.o
< input.o : ../../Modules/kind.o
< input.o : ../../Modules/read_input.o
< input.o : ../../Modules/read_pseudo.o
< input.o : ../../Modules/run_info.o
< input.o : ../../Modules/sic.o
< input.o : ../../Modules/timestep.o
< input.o : ../../Modules/uspp.o
< input.o : ../../Modules/wave_base.o
< input.o : cell_nose.o
---
> input.o : ../Modules/autopilot.o
> input.o : ../Modules/cell_base.o
> input.o : ../Modules/constants.o
> input.o : ../Modules/constraints_module.o
> input.o : ../Modules/control_flags.o
> input.o : ../Modules/electrons_base.o
> input.o : ../Modules/griddim.o
> input.o : ../Modules/input_parameters.o
> input.o : ../Modules/io_files.o
> input.o : ../Modules/io_global.o
> input.o : ../Modules/ions_base.o
> input.o : ../Modules/ions_nose.o
> input.o : ../Modules/kind.o
> input.o : ../Modules/printout_base.o
> input.o : ../Modules/read_cards.o
> input.o : ../Modules/read_namelists.o
> input.o : ../Modules/sic.o
> input.o : ../Modules/timestep.o
> input.o : ../Modules/wave_base.o
> input.o : ../Modules/xml_input.o
585d536
< input.o : electrons_nose.o
587d537
< input.o : ions_nose.o
589,590d538
< input.o : ldaU.o
< input.o : ldaUpen.o
591a540
> input.o : modules.o
593c542
< input.o : printout_base.o
---
> input.o : read_pseudo.o
595,602c544,547
< ions_nose.o : ../../Modules/constants.o
< ions_nose.o : ../../Modules/control_flags.o
< ions_nose.o : ../../Modules/io_global.o
< ions_nose.o : ../../Modules/ions_base.o
< ions_nose.o : ../../Modules/kind.o
< ions_positions.o : ../../Modules/cell_base.o
< ions_positions.o : ../../Modules/io_global.o
< ions_positions.o : ../../Modules/kind.o
---
> ions_positions.o : ../Modules/cell_base.o
> ions_positions.o : ../Modules/io_global.o
> ions_positions.o : ../Modules/kind.o
> ions_positions.o : ../Modules/printout_base.o
604,641c549,571
< ions_positions.o : printout_base.o
< ksstates.o : ../../Modules/electrons_base.o
< ksstates.o : ../../Modules/fft_base.o
< ksstates.o : ../../Modules/fft_interfaces.o
< ksstates.o : ../../Modules/io_global.o
< ksstates.o : ../../Modules/kind.o
< ksstates.o : ../../Modules/mp.o
< ksstates.o : ../../Modules/mp_global.o
< ksstates.o : ../../Modules/xml_io_base.o
< ksstates.o : gvecw.o
< ldaU.o : ../../Modules/atom.o
< ldaU.o : ../../Modules/cell_base.o
< ldaU.o : ../../Modules/constants.o
< ldaU.o : ../../Modules/control_flags.o
< ldaU.o : ../../Modules/dspev_drv.o
< ldaU.o : ../../Modules/electrons_base.o
< ldaU.o : ../../Modules/io_global.o
< ldaU.o : ../../Modules/ions_base.o
< ldaU.o : ../../Modules/kind.o
< ldaU.o : ../../Modules/mp.o
< ldaU.o : ../../Modules/mp_global.o
< ldaU.o : ../../Modules/parameters.o
< ldaU.o : ../../Modules/recvec.o
< ldaU.o : ../../Modules/uspp.o
< ldaU.o : cp_interfaces.o
< ldaU.o : gvecw.o
< ldaU.o : ldaUpen.o
< ldaUpen.o : ../../Modules/kind.o
< mainvar.o : ../../Modules/cell_base.o
< mainvar.o : ../../Modules/control_flags.o
< mainvar.o : ../../Modules/descriptors.o
< mainvar.o : ../../Modules/electrons_base.o
< mainvar.o : ../../Modules/fft_base.o
< mainvar.o : ../../Modules/funct.o
< mainvar.o : ../../Modules/kind.o
< mainvar.o : ../../Modules/mp.o
< mainvar.o : ../../Modules/mp_global.o
< mainvar.o : energies.o
---
> ksstates.o : ../Modules/electrons_base.o
> ksstates.o : ../Modules/fft_base.o
> ksstates.o : ../Modules/griddim.o
> ksstates.o : ../Modules/io_files.o
> ksstates.o : ../Modules/io_global.o
> ksstates.o : ../Modules/kind.o
> ksstates.o : ../Modules/mp.o
> ksstates.o : ../Modules/mp_global.o
> ksstates.o : ../Modules/recvec.o
> ksstates.o : ../Modules/xml_io_base.o
> ksstates.o : cp_interfaces.o
> main_loops.o : ../Modules/ions_base.o
> main_loops.o : ../Modules/kind.o
> main_loops.o : ../Modules/path_base.o
> main_loops.o : ../Modules/path_io_routines.o
> main_loops.o : path_routines.o
> mainvar.o : ../Modules/cell_base.o
> mainvar.o : ../Modules/descriptors.o
> mainvar.o : ../Modules/energies.o
> mainvar.o : ../Modules/funct.o
> mainvar.o : ../Modules/kind.o
> mainvar.o : ../Modules/mp.o
> mainvar.o : ../Modules/mp_global.o
644d573
< mainvar.o : wannier_base.o
646,656c575,586
< makov_payne.o : ../../Modules/cell_base.o
< makov_payne.o : ../../Modules/constants.o
< makov_payne.o : ../../Modules/electrons_base.o
< makov_payne.o : ../../Modules/fft_base.o
< makov_payne.o : ../../Modules/io_global.o
< makov_payne.o : ../../Modules/ions_base.o
< makov_payne.o : ../../Modules/kind.o
< makov_payne.o : ../../Modules/mp.o
< makov_payne.o : ../../Modules/mp_global.o
< makov_payne.o : ../../Modules/parallel_include.o
< makov_payne.o : gvecw.o
---
> makov_payne.o : ../Modules/cell_base.o
> makov_payne.o : ../Modules/constants.o
> makov_payne.o : ../Modules/electrons_base.o
> makov_payne.o : ../Modules/fft_base.o
> makov_payne.o : ../Modules/griddim.o
> makov_payne.o : ../Modules/io_global.o
> makov_payne.o : ../Modules/ions_base.o
> makov_payne.o : ../Modules/kind.o
> makov_payne.o : ../Modules/mp.o
> makov_payne.o : ../Modules/mp_global.o
> makov_payne.o : ../Modules/parallel_include.o
> makov_payne.o : ../Modules/recvec.o
659,669c589,602
< metaxc.o : ../../Modules/kind.o
< modules.o : ../../Modules/kind.o
< modules.o : ../../Modules/uspp.o
< move_electrons.o : ../../Modules/cell_base.o
< move_electrons.o : ../../Modules/control_flags.o
< move_electrons.o : ../../Modules/electrons_base.o
< move_electrons.o : ../../Modules/ions_base.o
< move_electrons.o : ../../Modules/kind.o
< move_electrons.o : ../../Modules/recvec.o
< move_electrons.o : ../../Modules/uspp.o
< move_electrons.o : ../../Modules/wavefunctions.o
---
> metaxc.o : ../Modules/recvec.o
> modules.o : ../Modules/kind.o
> modules.o : ../Modules/parameters.o
> move_electrons.o : ../Modules/cell_base.o
> move_electrons.o : ../Modules/control_flags.o
> move_electrons.o : ../Modules/electrons_base.o
> move_electrons.o : ../Modules/energies.o
> move_electrons.o : ../Modules/griddim.o
> move_electrons.o : ../Modules/ions_base.o
> move_electrons.o : ../Modules/kind.o
> move_electrons.o : ../Modules/mp_global.o
> move_electrons.o : ../Modules/recvec.o
> move_electrons.o : ../Modules/uspp.o
> move_electrons.o : ../Modules/wavefunctions.o
673,674d605
< move_electrons.o : electrons.o
< move_electrons.o : energies.o
676d606
< move_electrons.o : gvecw.o
682,721c612,640
< newd.o : ../../Modules/constants.o
< newd.o : ../../Modules/control_flags.o
< newd.o : ../../Modules/electrons_base.o
< newd.o : ../../Modules/fft_base.o
< newd.o : ../../Modules/fft_interfaces.o
< newd.o : ../../Modules/ions_base.o
< newd.o : ../../Modules/kind.o
< newd.o : ../../Modules/mp.o
< newd.o : ../../Modules/mp_global.o
< newd.o : ../../Modules/uspp.o
< newd.o : modules.o
< newd.o : smallbox.o
< newd.o : smallbox_gvec.o
< nl_base.o : ../../Modules/cell_base.o
< nl_base.o : ../../Modules/constants.o
< nl_base.o : ../../Modules/control_flags.o
< nl_base.o : ../../Modules/descriptors.o
< nl_base.o : ../../Modules/electrons_base.o
< nl_base.o : ../../Modules/io_global.o
< nl_base.o : ../../Modules/ions_base.o
< nl_base.o : ../../Modules/kind.o
< nl_base.o : ../../Modules/mp.o
< nl_base.o : ../../Modules/mp_global.o
< nl_base.o : ../../Modules/recvec.o
< nl_base.o : ../../Modules/uspp.o
< nl_base.o : cp_interfaces.o
< nl_base.o : gvecw.o
< nlcc.o : ../../Modules/atom.o
< nlcc.o : ../../Modules/cell_base.o
< nlcc.o : ../../Modules/control_flags.o
< nlcc.o : ../../Modules/electrons_base.o
< nlcc.o : ../../Modules/fft_base.o
< nlcc.o : ../../Modules/fft_interfaces.o
< nlcc.o : ../../Modules/io_global.o
< nlcc.o : ../../Modules/ions_base.o
< nlcc.o : ../../Modules/kind.o
< nlcc.o : ../../Modules/mp.o
< nlcc.o : ../../Modules/mp_global.o
< nlcc.o : ../../Modules/recvec.o
< nlcc.o : ../../Modules/uspp.o
---
> nl_base.o : ../Modules/cell_base.o
> nl_base.o : ../Modules/constants.o
> nl_base.o : ../Modules/control_flags.o
> nl_base.o : ../Modules/descriptors.o
> nl_base.o : ../Modules/electrons_base.o
> nl_base.o : ../Modules/io_global.o
> nl_base.o : ../Modules/ions_base.o
> nl_base.o : ../Modules/kind.o
> nl_base.o : ../Modules/mp.o
> nl_base.o : ../Modules/mp_global.o
> nl_base.o : ../Modules/recvec.o
> nl_base.o : ../Modules/uspp.o
> nl_base.o : mainvar.o
> nl_base.o : modules.o
> nlcc.o : ../Modules/atom.o
> nlcc.o : ../Modules/cell_base.o
> nlcc.o : ../Modules/control_flags.o
> nlcc.o : ../Modules/electrons_base.o
> nlcc.o : ../Modules/fft_base.o
> nlcc.o : ../Modules/griddim.o
> nlcc.o : ../Modules/io_global.o
> nlcc.o : ../Modules/ions_base.o
> nlcc.o : ../Modules/kind.o
> nlcc.o : ../Modules/mp.o
> nlcc.o : ../Modules/mp_global.o
> nlcc.o : ../Modules/recvec.o
> nlcc.o : ../Modules/smallbox.o
> nlcc.o : ../Modules/uspp.o
> nlcc.o : cp_interfaces.o
725,726d643
< nlcc.o : smallbox.o
< nlcc.o : smallbox_gvec.o
728,736c645,654
< ortho.o : ../../Modules/control_flags.o
< ortho.o : ../../Modules/descriptors.o
< ortho.o : ../../Modules/electrons_base.o
< ortho.o : ../../Modules/io_global.o
< ortho.o : ../../Modules/ions_base.o
< ortho.o : ../../Modules/kind.o
< ortho.o : ../../Modules/mp.o
< ortho.o : ../../Modules/mp_global.o
< ortho.o : ../../Modules/uspp.o
---
> ortho.o : ../Modules/control_flags.o
> ortho.o : ../Modules/descriptors.o
> ortho.o : ../Modules/electrons_base.o
> ortho.o : ../Modules/io_global.o
> ortho.o : ../Modules/ions_base.o
> ortho.o : ../Modules/kind.o
> ortho.o : ../Modules/mp.o
> ortho.o : ../Modules/mp_global.o
> ortho.o : ../Modules/recvec.o
> ortho.o : ../Modules/uspp.o
738c656,657
< ortho.o : gvecw.o
---
> ortho.o : mainvar.o
> ortho.o : modules.o
740,761c659,692
< ortho_base.o : ../../Modules/constants.o
< ortho_base.o : ../../Modules/control_flags.o
< ortho_base.o : ../../Modules/descriptors.o
< ortho_base.o : ../../Modules/dspev_drv.o
< ortho_base.o : ../../Modules/electrons_base.o
< ortho_base.o : ../../Modules/io_global.o
< ortho_base.o : ../../Modules/ions_base.o
< ortho_base.o : ../../Modules/kind.o
< ortho_base.o : ../../Modules/mp.o
< ortho_base.o : ../../Modules/mp_global.o
< ortho_base.o : ../../Modules/ptoolkit.o
< ortho_base.o : ../../Modules/recvec.o
< ortho_base.o : ../../Modules/uspp.o
< ortho_base.o : gvecw.o
< phasefactor.o : ../../Modules/cell_base.o
< phasefactor.o : ../../Modules/constants.o
< phasefactor.o : ../../Modules/control_flags.o
< phasefactor.o : ../../Modules/fft_base.o
< phasefactor.o : ../../Modules/io_global.o
< phasefactor.o : ../../Modules/ions_base.o
< phasefactor.o : ../../Modules/kind.o
< phasefactor.o : ../../Modules/recvec.o
---
> ortho_base.o : ../Modules/constants.o
> ortho_base.o : ../Modules/control_flags.o
> ortho_base.o : ../Modules/descriptors.o
> ortho_base.o : ../Modules/dspev_drv.o
> ortho_base.o : ../Modules/io_global.o
> ortho_base.o : ../Modules/ions_base.o
> ortho_base.o : ../Modules/kind.o
> ortho_base.o : ../Modules/mp.o
> ortho_base.o : ../Modules/mp_global.o
> ortho_base.o : ../Modules/ptoolkit.o
> ortho_base.o : ../Modules/recvec.o
> ortho_base.o : ../Modules/uspp.o
> ortho_base.o : modules.o
> path_routines.o : ../Modules/cell_base.o
> path_routines.o : ../Modules/constants.o
> path_routines.o : ../Modules/control_flags.o
> path_routines.o : ../Modules/input_parameters.o
> path_routines.o : ../Modules/io_files.o
> path_routines.o : ../Modules/io_global.o
> path_routines.o : ../Modules/ions_base.o
> path_routines.o : ../Modules/kind.o
> path_routines.o : ../Modules/metadyn_vars.o
> path_routines.o : ../Modules/mp.o
> path_routines.o : ../Modules/mp_global.o
> path_routines.o : ../Modules/path_variables.o
> path_routines.o : ../Modules/wrappers.o
> phasefactor.o : ../Modules/cell_base.o
> phasefactor.o : ../Modules/constants.o
> phasefactor.o : ../Modules/control_flags.o
> phasefactor.o : ../Modules/griddim.o
> phasefactor.o : ../Modules/io_global.o
> phasefactor.o : ../Modules/ions_base.o
> phasefactor.o : ../Modules/kind.o
> phasefactor.o : ../Modules/recvec.o
763,794c694,715
< phasefactor.o : gvecw.o
< plugin_forces.o : ../../Modules/io_files.o
< plugin_forces.o : ../../Modules/io_global.o
< plugin_forces.o : ../../Modules/kind.o
< plugin_forces.o : ../../Modules/mp.o
< plugin_forces.o : ../../Modules/mp_global.o
< plugin_forces.o : ../../Modules/plugin_flags.o
< plugin_initialization.o : ../../Modules/io_files.o
< plugin_initialization.o : ../../Modules/io_global.o
< plugin_initialization.o : ../../Modules/kind.o
< plugin_initialization.o : ../../Modules/plugin_flags.o
< polarization.o : ../../Modules/cell_base.o
< polarization.o : ../../Modules/constants.o
< polarization.o : ../../Modules/io_global.o
< polarization.o : ../../Modules/ions_base.o
< polarization.o : ../../Modules/kind.o
< polarization.o : ../../Modules/mp.o
< polarization.o : ../../Modules/mp_global.o
< polarization.o : ../../Modules/mp_wave.o
< polarization.o : berry_phase.o
< potentials.o : ../../Modules/cell_base.o
< potentials.o : ../../Modules/constants.o
< potentials.o : ../../Modules/control_flags.o
< potentials.o : ../../Modules/fft_base.o
< potentials.o : ../../Modules/fft_interfaces.o
< potentials.o : ../../Modules/io_global.o
< potentials.o : ../../Modules/ions_base.o
< potentials.o : ../../Modules/kind.o
< potentials.o : ../../Modules/mp.o
< potentials.o : ../../Modules/mp_global.o
< potentials.o : ../../Modules/recvec.o
< potentials.o : ../../Modules/sic.o
---
> polarization.o : ../Modules/berry_phase.o
> polarization.o : ../Modules/cell_base.o
> polarization.o : ../Modules/constants.o
> polarization.o : ../Modules/io_global.o
> polarization.o : ../Modules/ions_base.o
> polarization.o : ../Modules/kind.o
> polarization.o : ../Modules/mp.o
> polarization.o : ../Modules/mp_global.o
> polarization.o : ../Modules/mp_wave.o
> potentials.o : ../Modules/cell_base.o
> potentials.o : ../Modules/constants.o
> potentials.o : ../Modules/control_flags.o
> potentials.o : ../Modules/fft_base.o
> potentials.o : ../Modules/griddim.o
> potentials.o : ../Modules/io_files.o
> potentials.o : ../Modules/io_global.o
> potentials.o : ../Modules/ions_base.o
> potentials.o : ../Modules/kind.o
> potentials.o : ../Modules/mp.o
> potentials.o : ../Modules/mp_global.o
> potentials.o : ../Modules/recvec.o
> potentials.o : ../Modules/sic.o
796,808c717,733
< potentials.o : gvecw.o
< pres_ai_mod.o : ../../Modules/constants.o
< pres_ai_mod.o : ../../Modules/kind.o
< pres_ai_mod.o : ../../Modules/parameters.o
< print_out.o : ../../Modules/cell_base.o
< print_out.o : ../../Modules/constants.o
< print_out.o : ../../Modules/control_flags.o
< print_out.o : ../../Modules/io_files.o
< print_out.o : ../../Modules/io_global.o
< print_out.o : ../../Modules/ions_base.o
< print_out.o : ../../Modules/kind.o
< print_out.o : ../../Modules/sic.o
< print_out.o : ../../Modules/xml_io_base.o
---
> potentials.o : cp_interfaces.o
> potentials.o : mainvar.o
> pres_ai_mod.o : ../Modules/constants.o
> pres_ai_mod.o : ../Modules/kind.o
> pres_ai_mod.o : ../Modules/parameters.o
> print_out.o : ../Modules/cell_base.o
> print_out.o : ../Modules/constants.o
> print_out.o : ../Modules/control_flags.o
> print_out.o : ../Modules/electrons_base.o
> print_out.o : ../Modules/energies.o
> print_out.o : ../Modules/io_files.o
> print_out.o : ../Modules/io_global.o
> print_out.o : ../Modules/ions_base.o
> print_out.o : ../Modules/kind.o
> print_out.o : ../Modules/printout_base.o
> print_out.o : ../Modules/sic.o
> print_out.o : ../Modules/xml_io_base.o
809a735
> print_out.o : cp_interfaces.o
812d737
< print_out.o : energies.o
816,836c741,755
< print_out.o : printout_base.o
< printout_base.o : ../../Modules/io_global.o
< printout_base.o : ../../Modules/kind.o
< printout_base.o : ../../Modules/mp.o
< printout_base.o : ../../Modules/mp_global.o
< problem_size.o : ../../Modules/electrons_base.o
< problem_size.o : ../../Modules/fft_base.o
< problem_size.o : ../../Modules/io_global.o
< problem_size.o : ../../Modules/ions_base.o
< problem_size.o : ../../Modules/kind.o
< problem_size.o : ../../Modules/recvec.o
< problem_size.o : ../../Modules/uspp.o
< problem_size.o : gvecw.o
< problem_size.o : smallbox_gvec.o
< pseudo_base.o : ../../Modules/cell_base.o
< pseudo_base.o : ../../Modules/constants.o
< pseudo_base.o : ../../Modules/control_flags.o
< pseudo_base.o : ../../Modules/io_global.o
< pseudo_base.o : ../../Modules/kind.o
< pseudopot.o : ../../Modules/kind.o
< pseudopot.o : ../../Modules/uspp.o
---
> print_out.o : tsvdw.o
> problem_size.o : ../Modules/electrons_base.o
> problem_size.o : ../Modules/fft_base.o
> problem_size.o : ../Modules/io_global.o
> problem_size.o : ../Modules/ions_base.o
> problem_size.o : ../Modules/kind.o
> problem_size.o : ../Modules/recvec.o
> problem_size.o : ../Modules/uspp.o
> pseudo_base.o : ../Modules/cell_base.o
> pseudo_base.o : ../Modules/constants.o
> pseudo_base.o : ../Modules/control_flags.o
> pseudo_base.o : ../Modules/io_global.o
> pseudo_base.o : ../Modules/kind.o
> pseudopot.o : ../Modules/kind.o
> pseudopot.o : ../Modules/uspp.o
839,850c758,770
< pseudopot_sub.o : ../../Modules/atom.o
< pseudopot_sub.o : ../../Modules/cell_base.o
< pseudopot_sub.o : ../../Modules/constants.o
< pseudopot_sub.o : ../../Modules/control_flags.o
< pseudopot_sub.o : ../../Modules/io_global.o
< pseudopot_sub.o : ../../Modules/ions_base.o
< pseudopot_sub.o : ../../Modules/kind.o
< pseudopot_sub.o : ../../Modules/mp.o
< pseudopot_sub.o : ../../Modules/mp_global.o
< pseudopot_sub.o : ../../Modules/parameters.o
< pseudopot_sub.o : ../../Modules/recvec.o
< pseudopot_sub.o : ../../Modules/uspp.o
---
> pseudopot_sub.o : ../Modules/atom.o
> pseudopot_sub.o : ../Modules/cell_base.o
> pseudopot_sub.o : ../Modules/constants.o
> pseudopot_sub.o : ../Modules/control_flags.o
> pseudopot_sub.o : ../Modules/io_global.o
> pseudopot_sub.o : ../Modules/ions_base.o
> pseudopot_sub.o : ../Modules/kind.o
> pseudopot_sub.o : ../Modules/mp.o
> pseudopot_sub.o : ../Modules/mp_global.o
> pseudopot_sub.o : ../Modules/parameters.o
> pseudopot_sub.o : ../Modules/recvec.o
> pseudopot_sub.o : ../Modules/smallbox.o
> pseudopot_sub.o : ../Modules/uspp.o
853d772
< pseudopot_sub.o : gvecw.o
857,858d775
< pseudopot_sub.o : smallbox.o
< pseudopot_sub.o : smallbox_gvec.o
860,867c777,785
< qmatrixd.o : ../../Modules/electrons_base.o
< qmatrixd.o : ../../Modules/io_global.o
< qmatrixd.o : ../../Modules/ions_base.o
< qmatrixd.o : ../../Modules/kind.o
< qmatrixd.o : ../../Modules/mp.o
< qmatrixd.o : ../../Modules/mp_global.o
< qmatrixd.o : ../../Modules/recvec.o
< qmatrixd.o : ../../Modules/uspp.o
---
> qmatrixd.o : ../Modules/cell_base.o
> qmatrixd.o : ../Modules/electrons_base.o
> qmatrixd.o : ../Modules/io_global.o
> qmatrixd.o : ../Modules/ions_base.o
> qmatrixd.o : ../Modules/kind.o
> qmatrixd.o : ../Modules/mp.o
> qmatrixd.o : ../Modules/mp_global.o
> qmatrixd.o : ../Modules/recvec.o
> qmatrixd.o : ../Modules/uspp.o
869,878c787,795
< qmatrixd.o : gvecw.o
< qqberry.o : ../../Modules/atom.o
< qqberry.o : ../../Modules/cell_base.o
< qqberry.o : ../../Modules/constants.o
< qqberry.o : ../../Modules/ions_base.o
< qqberry.o : ../../Modules/kind.o
< qqberry.o : ../../Modules/mp.o
< qqberry.o : ../../Modules/mp_global.o
< qqberry.o : ../../Modules/recvec.o
< qqberry.o : ../../Modules/uspp.o
---
> qmatrixd.o : modules.o
> qqberry.o : ../Modules/atom.o
> qqberry.o : ../Modules/cell_base.o
> qqberry.o : ../Modules/constants.o
> qqberry.o : ../Modules/ions_base.o
> qqberry.o : ../Modules/mp.o
> qqberry.o : ../Modules/mp_global.o
> qqberry.o : ../Modules/recvec.o
> qqberry.o : ../Modules/uspp.o
880d796
< qqberry.o : gvecw.o
882,891c798,821
< restart.o : ../../Modules/autopilot.o
< restart.o : ../../Modules/cell_base.o
< restart.o : ../../Modules/control_flags.o
< restart.o : ../../Modules/descriptors.o
< restart.o : ../../Modules/electrons_base.o
< restart.o : ../../Modules/io_files.o
< restart.o : ../../Modules/ions_base.o
< restart.o : ../../Modules/kind.o
< restart.o : ../../Modules/mp.o
< restart.o : ../../Modules/xml_io_base.o
---
> read_pseudo.o : ../Modules/atom.o
> read_pseudo.o : ../Modules/funct.o
> read_pseudo.o : ../Modules/io_files.o
> read_pseudo.o : ../Modules/io_global.o
> read_pseudo.o : ../Modules/ions_base.o
> read_pseudo.o : ../Modules/kind.o
> read_pseudo.o : ../Modules/mp.o
> read_pseudo.o : ../Modules/pseudo_types.o
> read_pseudo.o : ../Modules/radial_grids.o
> read_pseudo.o : ../Modules/read_uspp.o
> read_pseudo.o : ../Modules/upf.o
> read_pseudo.o : ../Modules/upf_to_internal.o
> read_pseudo.o : ../Modules/uspp.o
> read_pseudo.o : modules.o
> restart.o : ../Modules/autopilot.o
> restart.o : ../Modules/cell_base.o
> restart.o : ../Modules/control_flags.o
> restart.o : ../Modules/electrons_base.o
> restart.o : ../Modules/io_files.o
> restart.o : ../Modules/ions_base.o
> restart.o : ../Modules/kind.o
> restart.o : ../Modules/mp.o
> restart.o : ../Modules/mp_global.o
> restart.o : ../Modules/recvec.o
897,909c827,844
< restart.o : gvecw.o
< restart_sub.o : ../../Modules/cell_base.o
< restart_sub.o : ../../Modules/control_flags.o
< restart_sub.o : ../../Modules/electrons_base.o
< restart_sub.o : ../../Modules/fft_base.o
< restart_sub.o : ../../Modules/io_global.o
< restart_sub.o : ../../Modules/ions_base.o
< restart_sub.o : ../../Modules/kind.o
< restart_sub.o : ../../Modules/recvec.o
< restart_sub.o : ../../Modules/timestep.o
< restart_sub.o : ../../Modules/uspp.o
< restart_sub.o : ../../Modules/wave_base.o
< restart_sub.o : ../../Modules/wavefunctions.o
---
> restart.o : mainvar.o
> restart_sub.o : ../Modules/cell_base.o
> restart_sub.o : ../Modules/control_flags.o
> restart_sub.o : ../Modules/electrons_base.o
> restart_sub.o : ../Modules/energies.o
> restart_sub.o : ../Modules/griddim.o
> restart_sub.o : ../Modules/io_global.o
> restart_sub.o : ../Modules/ions_base.o
> restart_sub.o : ../Modules/ions_nose.o
> restart_sub.o : ../Modules/kind.o
> restart_sub.o : ../Modules/mp_global.o
> restart_sub.o : ../Modules/printout_base.o
> restart_sub.o : ../Modules/recvec.o
> restart_sub.o : ../Modules/smallbox.o
> restart_sub.o : ../Modules/timestep.o
> restart_sub.o : ../Modules/uspp.o
> restart_sub.o : ../Modules/wave_base.o
> restart_sub.o : ../Modules/wavefunctions.o
914,916d848
< restart_sub.o : energies.o
< restart_sub.o : gvecw.o
< restart_sub.o : ions_nose.o
919,929c851,862
< restart_sub.o : printout_base.o
< runcp.o : ../../Modules/control_flags.o
< runcp.o : ../../Modules/electrons_base.o
< runcp.o : ../../Modules/fft_base.o
< runcp.o : ../../Modules/kind.o
< runcp.o : ../../Modules/mp.o
< runcp.o : ../../Modules/mp_global.o
< runcp.o : ../../Modules/parallel_include.o
< runcp.o : ../../Modules/recvec.o
< runcp.o : ../../Modules/uspp.o
< runcp.o : ../../Modules/wave_base.o
---
> restart_sub.o : modules.o
> runcp.o : ../Modules/control_flags.o
> runcp.o : ../Modules/electrons_base.o
> runcp.o : ../Modules/fft_base.o
> runcp.o : ../Modules/kind.o
> runcp.o : ../Modules/mp.o
> runcp.o : ../Modules/mp_global.o
> runcp.o : ../Modules/parallel_include.o
> runcp.o : ../Modules/recvec.o
> runcp.o : ../Modules/task_groups.o
> runcp.o : ../Modules/uspp.o
> runcp.o : ../Modules/wave_base.o
932,933c865
< runcp.o : gvecw.o
< runcp.o : ldaU.o
---
> runcp.o : modules.o
935,974c867,886
< smallbox.o : ../../Modules/constants.o
< smallbox.o : ../../Modules/io_global.o
< smallbox.o : ../../Modules/kind.o
< smallbox_grid.o : ../../Modules/fft_scalar.o
< smallbox_grid.o : ../../Modules/fft_types.o
< smallbox_grid.o : ../../Modules/io_global.o
< smallbox_gvec.o : ../../Modules/kind.o
< smallbox_lib.o : ../../Modules/cell_base.o
< smallbox_lib.o : ../../Modules/control_flags.o
< smallbox_lib.o : ../../Modules/fft_base.o
< smallbox_lib.o : ../../Modules/fft_types.o
< smallbox_lib.o : ../../Modules/io_global.o
< smallbox_lib.o : ../../Modules/ions_base.o
< smallbox_lib.o : ../../Modules/kind.o
< smallbox_lib.o : ../../Modules/mp_global.o
< smallbox_lib.o : cp_interfaces.o
< smallbox_lib.o : smallbox.o
< smallbox_lib.o : smallbox_gvec.o
< smallbox_subs.o : ../../Modules/fft_base.o
< smallbox_subs.o : ../../Modules/io_global.o
< smallbox_subs.o : ../../Modules/kind.o
< smallbox_subs.o : smallbox.o
< smallbox_subs.o : smallbox_gvec.o
< spline.o : ../../Modules/kind.o
< stop_run.o : ../../Modules/constraints_module.o
< stop_run.o : ../../Modules/control_flags.o
< stop_run.o : ../../Modules/environment.o
< stop_run.o : ../../Modules/image_io_routines.o
< stop_run.o : ../../Modules/io_files.o
< stop_run.o : ../../Modules/io_global.o
< stop_run.o : ../../Modules/mp_global.o
< stress.o : ../../Modules/cell_base.o
< stress.o : ../../Modules/constants.o
< stress.o : ../../Modules/electrons_base.o
< stress.o : ../../Modules/io_global.o
< stress.o : ../../Modules/ions_base.o
< stress.o : ../../Modules/kind.o
< stress.o : ../../Modules/mp.o
< stress.o : ../../Modules/mp_global.o
< stress.o : ../../Modules/recvec.o
---
> spline.o : ../Modules/kind.o
> stop_run.o : ../Modules/constraints_module.o
> stop_run.o : ../Modules/control_flags.o
> stop_run.o : ../Modules/environment.o
> stop_run.o : ../Modules/io_files.o
> stop_run.o : ../Modules/io_global.o
> stop_run.o : ../Modules/metadyn_vars.o
> stop_run.o : ../Modules/mp_global.o
> stop_run.o : ../Modules/path_io_routines.o
> stop_run.o : ../Modules/path_variables.o
> stop_run.o : ../Modules/recvec.o
> stress.o : ../Modules/cell_base.o
> stress.o : ../Modules/constants.o
> stress.o : ../Modules/electrons_base.o
> stress.o : ../Modules/io_global.o
> stress.o : ../Modules/ions_base.o
> stress.o : ../Modules/kind.o
> stress.o : ../Modules/mp.o
> stress.o : ../Modules/mp_global.o
> stress.o : ../Modules/recvec.o
976d887
< stress.o : gvecw.o
978,1012c889,905
< vofrho.o : ../../Modules/cell_base.o
< vofrho.o : ../../Modules/constants.o
< vofrho.o : ../../Modules/control_flags.o
< vofrho.o : ../../Modules/electrons_base.o
< vofrho.o : ../../Modules/fft_base.o
< vofrho.o : ../../Modules/fft_interfaces.o
< vofrho.o : ../../Modules/funct.o
< vofrho.o : ../../Modules/io_global.o
< vofrho.o : ../../Modules/ions_base.o
< vofrho.o : ../../Modules/kind.o
< vofrho.o : ../../Modules/mp.o
< vofrho.o : ../../Modules/mp_global.o
< vofrho.o : ../../Modules/recvec.o
< vofrho.o : ../../Modules/sic.o
< vofrho.o : ../../Modules/uspp.o
< vofrho.o : cp_interfaces.o
< vofrho.o : energies.o
< vofrho.o : ldaU.o
< vofrho.o : ldaUpen.o
< vofrho.o : modules.o
< vofrho.o : pres_ai_mod.o
< vofrho.o : smallbox_gvec.o
< vol_clu.o : ../../Modules/cell_base.o
< vol_clu.o : ../../Modules/constants.o
< vol_clu.o : ../../Modules/control_flags.o
< vol_clu.o : ../../Modules/electrons_base.o
< vol_clu.o : ../../Modules/fft_base.o
< vol_clu.o : ../../Modules/fft_interfaces.o
< vol_clu.o : ../../Modules/io_global.o
< vol_clu.o : ../../Modules/ions_base.o
< vol_clu.o : ../../Modules/kind.o
< vol_clu.o : ../../Modules/mp.o
< vol_clu.o : ../../Modules/mp_global.o
< vol_clu.o : ../../Modules/parameters.o
< vol_clu.o : ../../Modules/recvec.o
---
> vanderwaals.o : ../Modules/cell_base.o
> vanderwaals.o : ../Modules/constants.o
> vanderwaals.o : ../Modules/kind.o
> vanderwaals.o : ../Modules/mp_global.o
> vol_clu.o : ../Modules/cell_base.o
> vol_clu.o : ../Modules/constants.o
> vol_clu.o : ../Modules/control_flags.o
> vol_clu.o : ../Modules/electrons_base.o
> vol_clu.o : ../Modules/fft_base.o
> vol_clu.o : ../Modules/griddim.o
> vol_clu.o : ../Modules/io_global.o
> vol_clu.o : ../Modules/ions_base.o
> vol_clu.o : ../Modules/mp.o
> vol_clu.o : ../Modules/mp_global.o
> vol_clu.o : ../Modules/parameters.o
> vol_clu.o : ../Modules/recvec.o
> vol_clu.o : cp_interfaces.o
1014a908
> vol_clu.o : modules.o
1016,1026c910,919
< wannier.o : ../../Modules/cell_base.o
< wannier.o : ../../Modules/control_flags.o
< wannier.o : ../../Modules/descriptors.o
< wannier.o : ../../Modules/electrons_base.o
< wannier.o : ../../Modules/fft_base.o
< wannier.o : ../../Modules/io_global.o
< wannier.o : ../../Modules/ions_base.o
< wannier.o : ../../Modules/kind.o
< wannier.o : ../../Modules/recvec.o
< wannier.o : ../../Modules/uspp.o
< wannier.o : ../../Modules/wave_base.o
---
> wannier.o : ../Modules/cell_base.o
> wannier.o : ../Modules/control_flags.o
> wannier.o : ../Modules/electrons_base.o
> wannier.o : ../Modules/griddim.o
> wannier.o : ../Modules/io_global.o
> wannier.o : ../Modules/ions_base.o
> wannier.o : ../Modules/kind.o
> wannier.o : ../Modules/printout_base.o
> wannier.o : ../Modules/recvec.o
> wannier.o : ../Modules/wave_base.o
1028d920
< wannier.o : gvecw.o
1030d921
< wannier.o : printout_base.o
1032,1042c923,932
< wannier_base.o : ../../Modules/kind.o
< wave.o : ../../Modules/dspev_drv.o
< wave.o : ../../Modules/electrons_base.o
< wave.o : ../../Modules/io_global.o
< wave.o : ../../Modules/kind.o
< wave.o : ../../Modules/mp.o
< wave.o : ../../Modules/mp_global.o
< wave.o : ../../Modules/mp_wave.o
< wave.o : ../../Modules/random_numbers.o
< wave.o : ../../Modules/recvec.o
< wave.o : ../../Modules/wave_base.o
---
> wannier_base.o : ../Modules/kind.o
> wave.o : ../Modules/dspev_drv.o
> wave.o : ../Modules/io_global.o
> wave.o : ../Modules/kind.o
> wave.o : ../Modules/mp.o
> wave.o : ../Modules/mp_global.o
> wave.o : ../Modules/mp_wave.o
> wave.o : ../Modules/random_numbers.o
> wave.o : ../Modules/recvec.o
> wave.o : ../Modules/wave_base.o
1044,1060c934,950
< wave.o : gvecw.o
< wave_types.o : ../../Modules/kind.o
< wf.o : ../../Modules/cell_base.o
< wf.o : ../../Modules/constants.o
< wf.o : ../../Modules/control_flags.o
< wf.o : ../../Modules/electrons_base.o
< wf.o : ../../Modules/fft_base.o
< wf.o : ../../Modules/fft_interfaces.o
< wf.o : ../../Modules/io_global.o
< wf.o : ../../Modules/ions_base.o
< wf.o : ../../Modules/kind.o
< wf.o : ../../Modules/mp.o
< wf.o : ../../Modules/mp_global.o
< wf.o : ../../Modules/mp_wave.o
< wf.o : ../../Modules/parallel_include.o
< wf.o : ../../Modules/recvec.o
< wf.o : ../../Modules/uspp.o
---
> wave_types.o : ../Modules/kind.o
> wf.o : ../Modules/cell_base.o
> wf.o : ../Modules/constants.o
> wf.o : ../Modules/control_flags.o
> wf.o : ../Modules/electrons_base.o
> wf.o : ../Modules/fft_base.o
> wf.o : ../Modules/griddim.o
> wf.o : ../Modules/io_global.o
> wf.o : ../Modules/ions_base.o
> wf.o : ../Modules/kind.o
> wf.o : ../Modules/mp.o
> wf.o : ../Modules/mp_global.o
> wf.o : ../Modules/mp_wave.o
> wf.o : ../Modules/parallel_include.o
> wf.o : ../Modules/printout_base.o
> wf.o : ../Modules/recvec.o
> wf.o : ../Modules/uspp.o
1062,1063d951
< wf.o : gvecw.o
< wf.o : mainvar.o
1065,1066d952
< wf.o : printout_base.o
< wf.o : smallbox_gvec.o
1069d954
< wfdd.o : ../../Modules/constants.o
diff ./Makefile ../../../ffn2_tsvdw_master/CPV/Makefile
3c3
< include	../../make.sys
---
> include	../make.sys
6c6,7
< MODFLAGS= $(MOD_FLAG)../../iotk/src $(MOD_FLAG)../../Modules $(MOD_FLAG).
---
> MODFLAGS= $(MOD_FLAG)../iotk/src $(MOD_FLAG)../Modules \
>           $(MOD_FLAG)../EE $(MOD_FLAG).
11d11
< berry_phase.o \
13d12
< cell_nose.o \
19a19
> cp_fpmd.o \
24a25
> cprsub.o \
31,32d31
< electrons_nose.o \
< energies.o \
35d33
< exx_ggrid.o \
47d44
< gram.o \
49d45
< gvecw.o\
54d49
< ions_nose.o \
57,58d51
< ldaU.o \
< ldaUpen.o \
60c53
< cpr_loop.o \
---
> main_loops.o \
65d57
< newd.o \
69a62
> path_routines.o \
71,72d63
< plugin_initialization.o \
< plugin_forces.o \
77d67
< printout_base.o \
83a74
> read_pseudo.o \
87,91d77
< smallbox.o \
< smallbox_grid.o \
< smallbox_gvec.o \
< smallbox_subs.o \
< smallbox_lib.o \
94a81
> tsvdw.o  \
96,97d82
< vofrho.o \
< wannier_base.o \
102c87,88
< makov_payne.o
---
> makov_payne.o 
> 
107c93
< QEMODS=../../Modules/libqemod.a
---
> QEMODS=../Modules/libqemod.a
111,112d96
< LIBOBJS        = ../../flib/ptools.a ../../flib/flib.a ../../clib/clib.a ../../iotk/src/libiotk.a
< 
114c98
< cp : tldeps libcp.a cp.x cppp.x wfdd.x
---
> cp : tldeps libcp.a cp.x cppp.x
116,117c100,101
< cp.x : cprstart.o libcp.a $(QEMODS) $(LIBOBJS)
< 	$(LD) $(LDFLAGS) -o cp.x cprstart.o \
---
> cp.x : cprstart.o compute_fes_grads.o compute_scf.o libcp.a $(QEMODS) $(LIBOBJS)
> 	$(LD) $(LDFLAGS) -o cp.x cprstart.o compute_fes_grads.o compute_scf.o \
119c103
< 	- ( cd ../../bin ; ln -fs ../CPV/src/cp.x . )
---
> 	- ( cd ../bin ; ln -fs ../CPV/cp.x . )
133,138c117
< 	- (cd ../../bin ; ln -fs ../CPV/src/cppp.x . )
< 
< wfdd.x : wfdd.o
< 	$(LD) $(LDFLAGS) -o $@ wfdd.o $(QEMODS) $(LIBOBJS) $(LIBS)
< 	- ( cd ../../bin ; ln -fs ../CPV/src/$@ . )
< 
---
> 	- (cd ../bin ; ln -fs ../CPV/cppp.x . )
141c120
< 	test -n "$(TLDEPS)" && ( cd ../.. ; $(MAKE) $(MFLAGS) $(TLDEPS) || exit 1) || :
---
> 	test -n "$(TLDEPS)" && ( cd .. ; $(MAKE) $(MFLAGS) $(TLDEPS) || exit 1) || :
146d124
< 	-/bin/rm -rf ../../bin/cppp.x ../../bin/cp.x
diff ./makov_payne.f90 ../../../ffn2_tsvdw_master/CPV/makov_payne.f90
8,9c8,9
< ! ... original code written by Giovanni Cantele and Paolo Cazzato
< ! ... adapted to work in the parallel case by Carlo Sbraccia
---
> ! ... original code written by Giovanni Cantele and Paolo Cazzato; adapted to
> ! ... work in the parallel case by Carlo Sbraccia
19,20c19,21
<   USE io_global,         ONLY : stdout, ionode, ionode_id
<   USE constants,         ONLY : pi, autoev, au_debye
---
>   USE io_global,         ONLY : io_global_start, &
>                                 stdout, ionode, ionode_id
>   USE constants,         ONLY : pi,AUTOEV
24a26
>   USE grid_dimensions,   ONLY : nr1x, nr2x, nr3x, nnrx
27,28c29,30
< #if defined __MPI
<   USE mp_global,         ONLY : me_bgrp, nproc_bgrp, intra_bgrp_comm
---
> #if defined __PARA
>   USE mp_global,         ONLY : me_image, nproc_image, intra_image_comm
39c41
< REAL(DP) :: usunx,usuny,usunz,R0(3),qq,aa,bb
---
> REAL(DP) :: usunx,usuny,usunz,R0(3),qq,aa,bb,debye
47c49
< #if defined __MPI
---
> #if defined __PARA
59,63c61,65
<  usunx=1.0D0/DBLE(dfftp%nr1x)
<  usuny=1.0D0/DBLE(dfftp%nr2x)
<  usunz=1.0D0/DBLE(dfftp%nr3x)
<  ALLOCATE ( r(nat,3),rhof(dfftp%nr1x,dfftp%nr2x,dfftp%nr3x),&
<   & rgx(dfftp%nr1x),rgy(dfftp%nr2x),rgz(dfftp%nr3x),zvv(nat) )
---
>  usunx=1.0D0/DBLE(nr1x)
>  usuny=1.0D0/DBLE(nr2x)
>  usunz=1.0D0/DBLE(nr3x)
>  ALLOCATE ( r(nat,3),rhof(nr1x,nr2x,nr3x),&
>   & rgx(nr1x),rgy(nr2x),rgz(nr3x),zvv(nat) )
76,79c78,81
< ALLOCATE(rhodist1(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x))
< IF (nspin.EQ.2) ALLOCATE(rhodist2(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x))
< #if defined __MPI
< ALLOCATE( displs( nproc_bgrp ), recvcount( nproc_bgrp ) )
---
> ALLOCATE(rhodist1(nr1x*nr2x*nr3x))
> IF (nspin.EQ.2) ALLOCATE(rhodist2(nr1x*nr2x*nr3x))
> #if defined __PARA
> ALLOCATE( displs( nproc_image ), recvcount( nproc_image ) )
81c83
<       do proc=1,nproc_bgrp
---
>       do proc=1,nproc_image
93c95
<    call mpi_gatherv( rhor(1,1), recvcount(me_bgrp+1), MPI_DOUBLE_PRECISION,&
---
>    call mpi_gatherv( rhor(1,1), recvcount(me_image+1), MPI_DOUBLE_PRECISION,&
95c97
<  &                ionode_id, intra_bgrp_comm, ierr)
---
>  &                ionode_id, intra_image_comm, ierr)
100c102
<          call mpi_gatherv( rhor(1,2), recvcount(me_bgrp+1), MPI_DOUBLE_PRECISION,        &
---
>          call mpi_gatherv( rhor(1,2), recvcount(me_image+1), MPI_DOUBLE_PRECISION,        &
102c104
<      &                  ionode_id, intra_bgrp_comm, ierr)
---
>      &                  ionode_id, intra_image_comm, ierr)
110c112
< #if defined __MPI
---
> #if defined __PARA
113,115c115,117
<  DO k = 1, dfftp%nr3x
<   DO j = 1, dfftp%nr2x
<    DO i = 1, dfftp%nr1x
---
>  DO k = 1, nr3x
>   DO j = 1, nr2x
>    DO i = 1, nr1x
123c125
<  DO i=1,dfftp%nr1x
---
>  DO i=1,nr1x
126c128
<  DO i=1,dfftp%nr2x
---
>  DO i=1,nr2x
129c131
<  DO i=1,dfftp%nr3x
---
>  DO i=1,nr3x
155c157
<  DO i=1,dfftp%nr1x
---
>  DO i=1,nr1x
158c160
<  DO i=1,dfftp%nr2x
---
>  DO i=1,nr2x
161c163
<  DO i=1,dfftp%nr3x
---
>  DO i=1,nr3x
186,188c188,190
<   DO i = 1, dfftp%nr1x
<    DO j = 1, dfftp%nr2x
<     DO k = 1, dfftp%nr3x
---
>   DO i = 1, nr1x
>    DO j = 1, nr2x
>     DO k = 1, nr3x
201,203c203,205
<    charge_el=charge_el*alat**3/DBLE(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x)
<    dipole_el=dipole_el*alat**3/DBLE(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x)
<    quadrupole_el=quadrupole_el*alat**3/DBLE(dfftp%nr1x*dfftp%nr2x*dfftp%nr3x)
---
>    charge_el=charge_el*alat**3/DBLE(nr1x*nr2x*nr3x)
>    dipole_el=dipole_el*alat**3/DBLE(nr1x*nr2x*nr3x)
>    quadrupole_el=quadrupole_el*alat**3/DBLE(nr1x*nr2x*nr3x)
215a218,219
>    debye = 2.54176D0
>    !
223c227
<        (-dipole_el(ip), ip = 1, 3), (-dipole_el(ip)*au_debye, ip = 1, 3 )
---
>        (-dipole_el(ip), ip = 1, 3), (-dipole_el(ip)*debye, ip = 1, 3 )
225c229
<        ( dipole_ion(ip),ip = 1, 3), ( dipole_ion(ip)*au_debye,ip = 1, 3 )
---
>        ( dipole_ion(ip),ip = 1, 3), ( dipole_ion(ip)*debye,ip = 1, 3 )
227c231
<        ( dipole(ip),    ip = 1, 3), ( dipole(ip)*au_debye,    ip = 1, 3 )
---
>        ( dipole(ip),    ip = 1, 3), ( dipole(ip)*debye,    ip = 1, 3 )
246a251
>    ! 4 / 3 -> 2 / 3 Ry -> a.u.
254c259
<         &              " eV (1st order, 1/a0)")'   ) -corr1, -corr1*autoev
---
>         &              " eV (1st order, 1/a0)")'   ) -corr1, -corr1*AUTOEV
256c261
<         &              " eV (2nd order, 1/a0^3)")' ) -corr2, -corr2*autoev
---
>         &              " eV (2nd order, 1/a0^3)")' ) -corr2, -corr2*AUTOEV
258c263
<         &              " eV (total)")' ) -corr1-corr2, (-corr1-corr2)*autoev
---
>         &              " eV (total)")' ) -corr1-corr2, (-corr1-corr2)*AUTOEV
263c268
< #if defined __MPI
---
> #if defined __PARA
269c274
< #if defined __MPI
---
> #if defined __PARA
Only in ../../../ffn2_tsvdw_master/CPV: makov_payne.F90
Only in ../../../ffn2_tsvdw_master/CPV: makov_payne.o
Only in ../../../ffn2_tsvdw_master/CPV: metagga.mod
diff ./metaxc.f90 ../../../ffn2_tsvdw_master/CPV/metaxc.f90
12c12
<   use kinds, only: dp
---
>   use gvecp, only: ng => ngm
17c17
<   real(dp)  grho(nnr,3,nspin), rho(nnr,nspin),kedtau(nnr,nspin)
---
>   real(8)  grho(nnr,3,nspin), rho(nnr,nspin),kedtau(nnr,nspin)
20,21c20,21
<   real(dp)  etxc
<   REAL(dp) :: zeta, rh, grh2
---
>   real(8)  etxc
>   REAL(8) :: zeta, rh, grh2
23c23
<   REAL(dp) :: grho2 (2), sx, sc, v1x, v2x, v3x,v1c, v2c, v3c, &
---
>   REAL(8) :: grho2 (2), sx, sc, v1x, v2x, v3x,v1c, v2c, v3c, &
27c27
<   REAL(dp), PARAMETER :: epsr = 1.0d-6, epsg = 1.0d-10
---
>   REAL(8), PARAMETER :: epsr = 1.0d-6, epsg = 1.0d-10
Only in ../../../ffn2_tsvdw_master/CPV: metaxc.F90
Only in ../../../ffn2_tsvdw_master/CPV: metaxc.o
diff ./modules.f90 ../../../ffn2_tsvdw_master/CPV/modules.f90
7a8,59
> !     n     = total number of electronic states
> !     nx    = if n is even, nx=n ; if it is odd, nx=n+1
> !             nx is used only to dimension arrays
> 
> !     tpiba   = 2*pi/alat
> !     tpiba2  = (2*pi/alat)**2
> !     ng      = number of G vectors for density and potential
> !     ngl     = number of shells of G
> 
> !     G-vector quantities for the thick grid - see also doc in ggen 
> !     g       = G^2 in increasing order (in units of tpiba2=(2pi/a)^2)
> !     gl      = shells of G^2           ( "   "   "    "      "      )
> !     gx      = G-vectors               ( "   "   "  tpiba =(2pi/a)  )
> !
> !     g2_g    = all G^2 in increasing order, replicated on all procs
> !     mill_g  = miller index of G vecs (increasing order), replicated on all procs
> !     mill_l  = miller index of G vecs local to the processors
> !     ig_l2g  = "l2g" means local to global, this array convert a local
> !               G-vector index into the global index, in other words
> !               the index of the G-v. in the overall array of G-vectors
> !     bi?     = base vector used to generate the reciprocal space
> !
> !     np      = fft index for G>
> !     nm      = fft index for G<
> !     mill_l  = G components in crystal axis
> !
> 
> 
> !
> !  lqmax:  maximum angular momentum of Q (Vanderbilt augmentation charges)
> ! 
> 
> !  nbeta    number of beta functions (sum over all l)
> !  kkbeta   last radial mesh point used to describe functions
> !                 which vanish outside core
> !  nqf      coefficients in Q smoothing
> !  nqlc     angular momenta present in Q smoothing
> !  lll      lll(j) is l quantum number of j'th beta function
> !  lmaxq      highest angular momentum that is present in Q functions
> !  lmaxkb   highest angular momentum that is present in beta functions
> !  dion     bare pseudopotential D_{\mu,\nu} parameters
> !              (ionic and screening parts subtracted out)
> !  betar    the beta function on a r grid (actually, r*beta)
> !  qqq      Q_ij matrix
> !  qfunc    Q_ij(r) function (for r>rinner)
> !  rinner   radius at which to cut off partial core or Q_ij
> !
> !  qfcoef   coefficients to pseudize qfunc for different total
> !              angular momentum (for r<rinner)
> !  vloc_at  local potential for each atom
> 
> 
55d106
<   complex(DP), allocatable :: dqgb(:,:,:,:,:)
59d109
<       IF( ALLOCATED( dqgb ) ) DEALLOCATE( dqgb )
63d112
< 
103a153,208
> module dqgb_mod
>   USE kinds, ONLY: DP
>   implicit none
>   save
>   complex(DP),allocatable:: dqgb(:,:,:,:,:)
> contains
>   subroutine deallocate_dqgb_mod
>       IF( ALLOCATED( dqgb ) ) DEALLOCATE( dqgb )
>   end subroutine deallocate_dqgb_mod
> end module dqgb_mod
> 
> MODULE cdvan
>   USE kinds, ONLY: DP
>   IMPLICIT NONE
>   SAVE
>   REAL(DP), ALLOCATABLE :: dbeta(:,:,:,:,:)
>   REAL(DP), ALLOCATABLE :: dbec(:,:,:,:)     
>     ! Warning dbec is distributed over row and column processors of the ortho group
>   REAL(DP), ALLOCATABLE :: drhovan(:,:,:,:,:)
> CONTAINS
>   SUBROUTINE deallocate_cdvan
>       IF( ALLOCATED( dbeta ) ) DEALLOCATE( dbeta )
>       IF( ALLOCATED( dbec ) ) DEALLOCATE( dbec )
>       IF( ALLOCATED( drhovan ) ) DEALLOCATE( drhovan )
>   END SUBROUTINE deallocate_cdvan
> END MODULE cdvan
> 
> 
> 
> module cvan
> 
>   ! this file contains common subroutines and modules between
>   ! CP and FPMD
> 
>   !     ionic pseudo-potential variables
>   use parameters, only: nsx
>   implicit none
>   save
>   integer nvb, ish(nsx)
>   !     nvb    = number of species with Vanderbilt PPs
>   !     ish(is)= used for indexing the nonlocal projectors betae
>   !              with contiguous indices inl=ish(is)+(iv-1)*na(is)+1
>   !              where "is" is the species and iv=1,nh(is)
>   !
>   !     indlm: indlm(ind,is)=Y_lm for projector ind
>   integer, allocatable:: indlm(:,:)
> contains
> 
>   subroutine allocate_cvan( nind, ns )
>     integer, intent(in) :: nind, ns
>     allocate( indlm( nind, ns ) )
>   end subroutine allocate_cvan
> 
>   subroutine deallocate_cvan( )
>     if( allocated(indlm) ) deallocate( indlm )
>   end subroutine deallocate_cvan
104a210
> end module cvan
135d240
<    USE uspp, ONLY : nlcc_any
138a244
>    !     nlcc_any = 0 no core correction on any atom
143a250
>    LOGICAL :: nlcc_any
151,152c258,259
<    SUBROUTINE allocate_core( nrxx, ngm, ngb, nsp ) 
<      INTEGER, INTENT(IN) :: nrxx, ngm, ngb, nsp
---
>    SUBROUTINE allocate_core( nnrx, ngm, ngb, nsp ) 
>      INTEGER, INTENT(IN) :: nnrx, ngm, ngb, nsp
155c262
<         ALLOCATE( rhoc( nrxx ) )
---
>         ALLOCATE( rhoc( nnrx ) )
178a286,326
> module ldaU
>   use parameters, only: nsx
>   USE kinds
>   implicit none
>   complex(DP), allocatable :: atomwfc(:,:)
>   complex(DP), allocatable :: swfcatom(:,:)
>   real(DP) :: Hubbard_U(nsx), Hubbard_lambda(nsx,2), ns0(nsx,2),   &
>      & Hubbard_alpha(nsx)
>   real(DP) :: e_hubbard = 0.d0, e_lambda = 0.d0
>   real(DP), allocatable :: ns(:,:,:,:)
>   integer :: Hubbard_l(nsx), Hubbard_lmax=0, n_atomic_wfc
>   logical lda_plus_u
>   COMPLEX(DP), allocatable::  vupsi(:,:) !#@@@
> contains
>   !
>   subroutine deallocate_lda_plus_u()
>      !
>      IF( ALLOCATED( atomwfc ) ) DEALLOCATE( atomwfc )
>      IF( ALLOCATED( swfcatom ) ) DEALLOCATE( swfcatom )
>      IF( ALLOCATED( ns ) ) DEALLOCATE( ns )
>      IF( ALLOCATED( vupsi ) ) DEALLOCATE( vupsi )
>      !
>      !
>   end subroutine
>   !
> end module ldaU
> !
> !
> ! Occupation constraint ...to be implemented...
> !
> module step_constraint
>   USE kinds
>   implicit none
>   integer, parameter :: natx_ = 5000
>   real(DP) :: E_con
>   real(DP) :: A_con(natx_,2), sigma_con(natx_), alpha_con(natx_)
>   logical :: step_con
>   ! complex(DP), allocatable:: vpsi_con(:,:)
>   complex(DP) :: vpsi_con(1,1)
> end module step_constraint
> 
Only in ../../../ffn2_tsvdw_master/CPV: modules.F90
Only in ../../../ffn2_tsvdw_master/CPV: modules.o
diff ./move_electrons.f90 ../../../ffn2_tsvdw_master/CPV/move_electrons.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 Quantum ESPRESSO group
10,11c10,11
< SUBROUTINE move_electrons_x( nfi, tfirst, tlast, b1, b2, b3, fion, c0_bgrp, &
<             cm_bgrp, phi_bgrp, enthal, enb, enbi, fccc, ccc, dt2bye, stress )
---
> SUBROUTINE move_electrons_x( nfi, tfirst, tlast, b1, b2, b3, fion, &
>                            enthal, enb, enbi, fccc, ccc, dt2bye, stress )
17c17
<   USE control_flags,        ONLY : lwf, tfor, tprnfor, thdyn
---
>   USE control_flags,        ONLY : lwf, tfor, tprnfor, thdyn, lwfpbe0, lwfpbe0nscf  ! changed by Lingzhu Kong
19,21c19,22
<   USE cp_main_variables,    ONLY : eigr, irb, eigrb, rhog, rhos, rhor, drhor, &
<                                    drhog, sfac, ema0bg, bec_bgrp, becdr_bgrp, &
<                                    taub, lambda, lambdam, lambdap, vpot, dbec, descla
---
>   USE cp_main_variables,    ONLY : eigr, bec, irb, eigrb, rhog, rhos, rhor, &
>                                    ei1, ei2, ei3, sfac, ema0bg, becdr, &
>                                    taub, lambda, lambdam, lambdap, vpot
>   USE wavefunctions_module, ONLY : cv0, c0, cm, phi => cp  ! cv0 added by Lingzhu Kong
23c24
<   USE uspp,                 ONLY : becsum, vkb, nkb, nlcc_any
---
>   USE uspp,                 ONLY : becsum, vkb, nkb
25,26c26,28
<   USE electrons_base,       ONLY : nbsp, nspin, f, nudx, nupdwn, nbspx_bgrp, nbsp_bgrp
<   USE core,                 ONLY : rhoc
---
>   USE grid_dimensions,      ONLY : nnrx
>   USE electrons_base,       ONLY : nbsp, nspin, f, nudx
>   USE core,                 ONLY : nlcc_any, rhoc
40c42
<   USE orthogonalize_base,   ONLY : calphi_bgrp
---
>   USE orthogonalize_base,   ONLY : calphi
42,46c44,46
<   USE cp_interfaces,        ONLY : rhoofr, compute_stress, vofrho, nlfl_bgrp, prefor, nlfq_bgrp
<   USE electrons_module,     ONLY : distribute_c, collect_c, distribute_b
<   USE gvect,                ONLY : eigts1, eigts2, eigts3 
<   USE control_flags,        ONLY : lwfpbe0, lwfpbe0nscf  ! Lingzhu Kong
<   USE wavefunctions_module, ONLY : cv0 ! Lingzhu Kong
---
>   USE cp_interfaces,        ONLY : rhoofr, compute_stress
>   USE electrons_base,       ONLY : nupdwn 
>   USE mp_global,            ONLY : me_image 
54d53
<   COMPLEX(DP)             :: c0_bgrp(:,:), cm_bgrp(:,:), phi_bgrp(:,:)
61d59
<   REAL(DP)                :: dum
65c63
<   CALL start_clock('move_electrons')
---
>   !
68,71c66,68
<      CALL runcg_uspp( nfi, tfirst, tlast, eigr, bec_bgrp, irb, eigrb, &
<                       rhor, rhog, rhos, rhoc, eigts1, eigts2, eigts3, sfac, &
<                       fion, ema0bg, becdr_bgrp, lambdap, lambda, SIZE(lambda,1), vpot, c0_bgrp, &
<                       cm_bgrp, phi_bgrp, dbec  )
---
>      CALL runcg_uspp( nfi, tfirst, tlast, eigr, bec, irb, eigrb, &
>                       rhor, rhog, rhos, rhoc, ei1, ei2, ei3, sfac, &
>                       fion, ema0bg, becdr, lambdap, lambda, vpot  )
78c75
<           CALL get_wannier_center( tfirst, cm_bgrp, bec_bgrp, eigr, &
---
>           CALL get_wannier_center( tfirst, cm, bec, eigr, &
81,82c78,80
<      CALL rhoofr( nfi, c0_bgrp, irb, eigrb, bec_bgrp, dbec, becsum, rhor, &
<                   drhor, rhog, drhog, rhos, enl, denl, ekin, dekin6 )
---
>      CALL rhoofr( nfi, c0, irb, eigrb, bec, &
>                      becsum, rhor, rhog, rhos, enl, denl, ekin, dekin6 )
> 
88c86
<            CALL exx_gs(nfi, c0_bgrp)
---
>            CALL exx_gs(nfi, c0)
91c89
<            CALL exx_es(nfi, c0_bgrp, cv0)
---
>            CALL exx_es(nfi, c0, cv0)
111,113c109,110
<      CALL vofrho( nfi, vpot, drhor, rhog, drhog, rhos, rhoc, tfirst, tlast,&
<                      eigts1, eigts2, eigts3, irb, eigrb, sfac, &
<                      tau0, fion )
---
>      CALL vofrho( nfi, vpot(1,1), rhog(1,1), rhos(1,1), rhoc(1), tfirst, tlast, &
>                      ei1, ei2, ei3, irb(1,1), eigrb(1,1), sfac(1,1), tau0(1,1), fion(1,1) )
115c112
<      IF ( lwf ) CALL wf_options( tfirst, nfi, cm_bgrp, becsum, bec_bgrp, dbec, &
---
>      IF ( lwf ) CALL wf_options( tfirst, nfi, cm, becsum, bec, &
117c114
<                                  b2, b3, vpot, drhor, rhog, drhog, rhos, enl, ekin  )
---
>                                  b2, b3, vpot, rhog, rhos, enl, ekin  )
125c122
<         CALL berry_energy( enb, enbi, bec_bgrp, c0_bgrp, fion )
---
>         CALL berry_energy( enb, enbi, bec, c0, fion )
132c129
<         CALL berry_energy2( enb, enbi, bec_bgrp, c0_bgrp, fion )
---
>         CALL berry_energy2( enb, enbi, bec, c0, fion )
156c153
<                       rhos, bec_bgrp, c0_bgrp, cm_bgrp, ei_unp )
---
>                       rhos, bec, c0, cm, ei_unp )
160c157
<         CALL runcp_uspp( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec_bgrp, c0_bgrp, cm_bgrp )
---
>         CALL runcp_uspp( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec, c0, cm )
170,172c167
<      IF ( tfor .OR. tprnfor ) THEN
<         CALL nlfq_bgrp( c0_bgrp, eigr, bec_bgrp, becdr_bgrp, fion )
<      END IF
---
>      IF ( tfor .OR. tprnfor ) CALL nlfq( c0, eigr, bec, becdr, fion )
175c170
<         CALL bforceion( fion, .TRUE. , ipolp, qmat, bec_bgrp, becdr_bgrp, gqq, evalue )
---
>         CALL bforceion( fion, .TRUE. , ipolp, qmat, bec, becdr, gqq, evalue )
177c172
<         CALL bforceion( fion, .TRUE. , ipolp2, qmat2, bec_bgrp, becdr_bgrp, gqq2, evalue2 )
---
>         CALL bforceion( fion, .TRUE. , ipolp2, qmat2, bec, becdr, gqq2, evalue2 )
194c189
<      CALL calphi_bgrp( c0_bgrp, ngw, bec_bgrp, nkb, vkb, phi_bgrp, nbspx_bgrp, ema0bg )
---
>      CALL calphi( c0, ngw, bec, nkb, vkb, phi, nbsp, ema0bg )
200,202c195
<      IF ( tfor .OR. tprnfor ) THEN
<         CALL nlfl_bgrp( bec_bgrp, becdr_bgrp, lambda, descla, fion )
<      END IF
---
>      IF ( tfor .OR. tprnfor ) CALL nlfl( bec, becdr, lambda, fion )
205d197
<   CALL stop_clock('move_electrons')
Only in ../../../ffn2_tsvdw_master/CPV: move_electrons.F90
Only in ../../../ffn2_tsvdw_master/CPV: move_electrons.o
Only in .: newd.f90
diff ./nl_base.f90 ../../../ffn2_tsvdw_master/CPV/nl_base.f90
10c10
<    subroutine nlsm1_x ( n, nspmn, nspmx, eigr, c, becp )
---
>    subroutine nlsm1 ( n, nspmn, nspmx, eigr, c, becp )
25c25
<       USE mp_global,  ONLY : nproc_bgrp, intra_bgrp_comm
---
>       USE mp_global,  ONLY : nproc_image, intra_image_comm
29c29,30
<       USE uspp_param, only : nh, ish
---
>       USE cvan,       only : ish
>       USE uspp_param, only : nh
31c32
<       USE gvect, ONLY : gstart
---
>       USE reciprocal_vectors, ONLY : gstart
35,37c36,38
<       integer,     intent(in)  :: n, nspmn, nspmx
<       complex(DP), intent(in)  :: eigr( :, : ), c( :, : )
<       real(DP), intent(out) :: becp( :, : )
---
>       integer,   intent(in)  :: n, nspmn, nspmx
>       real(DP), intent(in)  :: eigr( 2, ngw, nat ), c( 2, ngw, n )
>       real(DP), intent(out) :: becp( nkb, n )
39c40,41
<       integer   :: isa, ig, is, iv, ia, l, inl, i, nhx
---
>       integer   :: isa, ig, is, iv, ia, l, ixr, ixi, inl, i, nhx
>       real(DP)  :: signre, signim, arg
41,42c43
<       complex(DP), allocatable :: wrk2( :, : )
<       complex(DP) :: cfact
---
>       real(DP), allocatable :: wrk2( :, :, : )
58c59
<          allocate( wrk2( ngw, na( is ) ) )
---
>          allocate( wrk2( 2, ngw, na( is ) ) )
60c61
<          IF( nproc_bgrp > 1 ) THEN
---
>          IF( nproc_image > 1 ) THEN
62c63
<             IF( MOD( nhx, 2 ) == 0 ) nhx = nhx + 1
---
>             IF( MOD( nhx, 2 ) /= 0 ) nhx = nhx + 1
69c70
< !$omp parallel default(shared), private(l,ig,ia,cfact)
---
> !$omp parallel default(shared), private(l,ixr,ixi,signre,signim,ig,arg,ia)
73c74,77
<                cfact =   cmplx( 1.0_dp , 0.0_dp )
---
>                ixr = 1
>                ixi = 2
>                signre =  1.0d0
>                signim =  1.0d0
75c79,82
<                cfact = - cmplx( 0.0_dp , 1.0_dp )
---
>                ixr = 2
>                ixi = 1
>                signre =  1.0d0
>                signim = -1.0d0
77,78c84,87
<                cfact = - cmplx( 0.0_dp , 1.0_dp )
<                cfact = cfact * cfact
---
>                ixr = 1
>                ixi = 2
>                signre = -1.0d0
>                signim = -1.0d0
80,81c89,92
<                cfact = - cmplx( 0.0_dp , 1.0_dp )
<                cfact = cfact * cfact * cfact
---
>                ixr = 2
>                ixi = 1
>                signre = -1.0d0
>                signim =  1.0d0
90c101,102
<                   wrk2( 1, ia ) = cfact * beta(1,iv,is) * eigr(1,ia+isa)
---
>                   wrk2( 1, 1, ia ) = signre*beta(1,iv,is)*eigr(ixr,1,ia+isa)
>                   wrk2( 2, 1, ia ) = signim*beta(1,iv,is)*eigr(ixi,1,ia+isa)
96c108,110
<                   wrk2( ig, ia ) = 2.0d0 * cfact * beta(ig,iv,is) * eigr(ig,ia+isa)
---
>                   arg = 2.0d0 * beta(ig,iv,is)
>                   wrk2( 1, ig, ia ) = signre*arg*eigr(ixr,ig,ia+isa)
>                   wrk2( 2, ig, ia ) = signim*arg*eigr(ixi,ig,ia+isa)
104c118
<             IF( nproc_bgrp > 1 ) THEN
---
>             IF( nproc_image > 1 ) THEN
117c131
<          IF( nproc_bgrp > 1 ) THEN
---
>          IF( nproc_image > 1 ) THEN
121c135
<             CALL mp_sum( becps, intra_bgrp_comm )
---
>             CALL mp_sum( becps, intra_image_comm )
140c154,326
<    end subroutine nlsm1_x
---
>    end subroutine nlsm1
> !-----------------------------------------------------------------------
> 
> !
> !-----------------------------------------------------------------------
>    subroutine nlsm1_dist ( n, nspmn, nspmx, eigr, c, becp, nlax, nspin, desc )
> !-----------------------------------------------------------------------
>       !  
>       ! This version is for becp distributed over procs  
>       !  
>       !     computes: the array becp
>       !     becp(ia,n,iv,is)=
>       !         = sum_g [(-i)**l beta(g,iv,is) e^(-ig.r_ia)]^* c(g,n)
>       !         = delta_l0 beta(g=0,iv,is) c(g=0,n)
>       !          +sum_g> beta(g,iv,is) 2 re[(i)**l e^(ig.r_ia) c(g,n)]
>       !
>       !     routine makes use of c*(g)=c(-g)  (g> see routine ggen)
>       !     input : beta(ig,l,is), eigr, c
>       !     output: becp as parameter
>       !
>       USE kinds,      ONLY : DP
>       USE mp,         ONLY : mp_sum
>       USE mp_global,  ONLY : nproc_image, intra_image_comm
>       USE ions_base,  only : na, nat
>       USE gvecw,      only : ngw
>       USE uspp,       only : nkb, nhtol, beta
>       USE cvan,       only : ish
>       USE uspp_param, only : nh
>       !
>       USE reciprocal_vectors, ONLY : gstart
>       USE descriptors,        ONLY : descla_siz_ , lambda_node_ , nlar_ , ilar_ , la_n_
> !
>       implicit none
> 
>       integer,  intent(in)  :: n, nspmn, nspmx, nlax, nspin
>       integer,  intent(in)  :: desc( descla_siz_ , nspin )
>       real(DP), intent(in)  :: eigr( 2, ngw, nat ), c( 2, ngw, n )
>       real(DP), intent(out) :: becp( nkb, nlax*nspin )
>       !
>       integer   :: isa, ig, is, iv, ia, l, ixr, ixi, inl, i, nhx
>       integer   :: nr, ir, nup
>       real(DP)  :: signre, signim, arg
>       real(DP), allocatable :: becps( :, : )
>       real(DP), allocatable :: wrk2( :, :, : )
>       !
>       call start_clock( 'nlsm1' )
> 
>       isa = 0
>       do is = 1, nspmn - 1
>         isa = isa + na(is)
>       end do
> 
>       do is = nspmn, nspmx
>          !
>          IF( nh( is ) < 1 ) THEN
>             isa = isa + na(is)
>             CYCLE
>          END IF
>          !
>          allocate( wrk2( 2, ngw, na( is ) ) )
>          !
>          IF( nproc_image > 1 ) THEN
>             nhx = nh( is ) * na( is )
>             IF( MOD( nhx, 2 ) /= 0 ) nhx = nhx + 1
>             ALLOCATE( becps( nhx, n ) )
>             becps = 0.0d0
>          END IF
>          !
>          do iv = 1, nh( is )
>             !
> !$omp parallel default(shared), private(l,ixr,ixi,signre,signim,ig,arg,ia)
>             l = nhtol( iv, is )
>             !
>             if (l == 0) then
>                ixr = 1
>                ixi = 2
>                signre =  1.0d0
>                signim =  1.0d0
>             else if (l == 1) then
>                ixr = 2
>                ixi = 1
>                signre =  1.0d0
>                signim = -1.0d0
>             else if (l == 2) then
>                ixr = 1
>                ixi = 2
>                signre = -1.0d0
>                signim = -1.0d0
>             else if (l == 3) then
>                ixr = 2
>                ixi = 1
>                signre = -1.0d0
>                signim =  1.0d0
>             endif
> !
> !$omp do
>             do ia=1,na(is)
>                !
>                !  q = 0   component (with weight 1.0)
>                !
>                if (gstart == 2) then
>                   wrk2( 1, 1, ia ) = signre*beta(1,iv,is)*eigr(ixr,1,ia+isa)
>                   wrk2( 2, 1, ia ) = signim*beta(1,iv,is)*eigr(ixi,1,ia+isa)
>                end if
>                !
>                !   q > 0   components (with weight 2.0)
>                !
>                do ig = gstart, ngw
>                   arg = 2.0d0 * beta(ig,iv,is)
>                   wrk2( 1, ig, ia ) = signre*arg*eigr(ixr,ig,ia+isa)
>                   wrk2( 2, ig, ia ) = signim*arg*eigr(ixi,ig,ia+isa)
>                end do
>                !
>             end do
> !$omp end do
>             
> !$omp end parallel
>             
>             !
>             IF( nproc_image > 1 ) THEN
>                inl=(iv-1)*na(is)+1
>                CALL dgemm( 'T', 'N', na(is), n, 2*ngw, 1.0d0, wrk2, 2*ngw, c, 2*ngw, 0.0d0, becps( inl, 1 ), nhx )
>             ELSE
>                inl=ish(is)+(iv-1)*na(is)+1
>                CALL dgemm( 'T', 'N', na(is), n, 2*ngw, 1.0d0, wrk2, 2*ngw, c, 2*ngw, 0.0d0, becp( inl, 1 ), nkb )
>             END IF
> 
>          end do
> 
>          deallocate( wrk2 )
> 
> 
>          IF( nproc_image > 1 ) THEN
>             !
>             inl = ish(is) + 1
>             !
>             CALL mp_sum( becps, intra_image_comm )
> 
>             IF( desc( lambda_node_ , 1 ) > 0 ) THEN
>                ir = desc( ilar_ , 1 )
>                nr = desc( nlar_ , 1 )
>                do i = 1, nr
>                   do iv = inl , ( inl + na(is) * nh(is) - 1 )
>                      becp( iv, i ) = becps( iv - inl + 1, i + ir - 1 )
>                   end do
>                end do
>             END IF
>             !
>             IF( nspin == 2 ) THEN
>                IF( desc( lambda_node_ , 2 ) > 0 ) THEN
>                   nup = desc( la_n_ , 1 )
>                   ir = desc( ilar_ , 2 )
>                   nr = desc( nlar_ , 2 )
>                   do i = 1, nr
>                      do iv = inl , ( inl + na(is) * nh(is) - 1 )
>                         becp( iv, i + nlax ) = becps( iv - inl + 1, i + ir - 1 + nup )
>                      end do
>                   end do
>                END IF
>             END IF
> 
>             DEALLOCATE( becps )
> 
>          END IF
> 
>          isa = isa + na(is)
> 
>       end do
> 
>       call stop_clock( 'nlsm1' )
> 
>       return
>    end subroutine nlsm1_dist
145c331
<    subroutine nlsm2_bgrp_x( ngw, nkb, eigr, c_bgrp, becdr_bgrp, nbspx_bgrp, nbsp_bgrp )
---
>    subroutine nlsm2( ngw, nkb, n, nspin, eigr, c, becdr )
159,160c345,347
<       use uspp,       only : nhtol, beta
<       use uspp_param, only : nh, ish
---
>       use uspp,       only : nhtol, beta  !, nkb
>       use cvan,       only : ish
>       use uspp_param, only : nh
163,164c350,352
<       use mp_global,  only : nproc_bgrp, intra_bgrp_comm
<       use gvect,      only : g, gstart
---
>       use mp_global,  only : nproc_image, intra_image_comm
>       use cp_main_variables,  only : nlax, descla, distribute_bec
>       use reciprocal_vectors, only : gx, gstart
168,177c356,365
<       integer,     intent(in)  :: ngw, nkb, nbspx_bgrp, nbsp_bgrp
<       complex(DP), intent(in)  :: eigr(:,:), c_bgrp(:,:)
<       real(DP),    intent(out) :: becdr_bgrp(:,:,:)
<       !
<       real(DP),    allocatable :: gk(:)
<       complex(DP), allocatable :: wrk2(:,:)
<       !
<       integer  :: ig, is, iv, ia, k, l, inl, isa, i
<       real(DP) :: arg
<       complex(DP) :: cfact
---
>       integer,  intent(in)  :: ngw, nkb, n, nspin
>       real(DP), intent(in)  :: eigr(2,ngw,nat), c(2,ngw,n)
>       real(DP), intent(out) :: becdr(nkb,nspin*nlax,3)
>       !
>       real(DP), allocatable :: gk(:)
>       real(DP), allocatable :: wrk2(:,:,:)
>       real(DP), allocatable :: becdr_repl(:,:)
>       !
>       integer   :: ig, is, iv, ia, k, l, ixr, ixi, inl, isa, i
>       real(DP) :: signre, signim, arg
181a370
>       allocate( becdr_repl( nkb, n ) )
183c372
<       becdr_bgrp = 0.d0
---
>       becdr = 0.d0
186a376,377
>          becdr_repl = 0.d0
> 
188c379
<             gk(ig)=g(k,ig)*tpiba
---
>             gk(ig)=gx(k,ig)*tpiba
195c386
<             allocate( wrk2( ngw, na( is ) ) )
---
>             allocate( wrk2( 2, ngw, na( is ) ) )
201c392
< !$omp parallel default(none), shared(na,nhtol,gstart,wrk2,gk,beta,eigr,ngw,iv,is,isa), private(l,cfact,ig,arg,ia)
---
> !$omp parallel default(shared), private(l,ixr,ixi,signre,signim,ig,arg,ia)
202a394,492
>                if (l.eq.0) then
>                   ixr = 2
>                   ixi = 1
>                   signre =  1.0d0
>                   signim = -1.0d0
>                else if (l.eq.1) then
>                   ixr = 1
>                   ixi = 2
>                   signre = -1.0d0
>                   signim = -1.0d0
>                else if (l.eq.2) then
>                   ixr = 2
>                   ixi = 1
>                   signre = -1.0d0
>                   signim =  1.0d0
>                else if (l == 3) then
>                   ixr = 1
>                   ixi = 2
>                   signre =  1.0d0
>                   signim =  1.0d0
>                endif
> !    
> !$omp do
>                do ia=1,na(is)
>                   !    q = 0   component (with weight 1.0)
>                   if (gstart == 2) then
>                      wrk2(1,1,ia) = signre*gk(1)*beta(1,iv,is)*eigr(ixr,1,ia+isa)
>                      wrk2(2,1,ia) = signim*gk(1)*beta(1,iv,is)*eigr(ixi,1,ia+isa)
>                   end if
>                   !    q > 0   components (with weight 2.0)
>                   do ig=gstart,ngw
>                      arg = 2.0d0*gk(ig)*beta(ig,iv,is)
>                      wrk2(1,ig,ia) = signre*arg*eigr(ixr,ig,ia+isa)
>                      wrk2(2,ig,ia) = signim*arg*eigr(ixi,ig,ia+isa)
>                   end do
>                end do
> !$omp end do
> !$omp end parallel 
>                inl=ish(is)+(iv-1)*na(is)+1
>                CALL dgemm( 'T', 'N', na(is), n, 2*ngw, 1.0d0, wrk2, 2*ngw, c, 2*ngw, 0.0d0, becdr_repl( inl, 1 ), nkb )
>             end do
> 
>             deallocate( wrk2 )
> 
>             isa = isa + na(is)
> 
>          end do
> 
>          IF( nproc_image > 1 ) THEN
>             CALL mp_sum( becdr_repl(:,:), intra_image_comm )
>          END IF
>          CALL distribute_bec( becdr_repl, becdr(:,:,k), descla, nspin )
>       end do
> 
>       deallocate( gk )
>       deallocate( becdr_repl )
> 
>       call stop_clock( 'nlsm2' )
> !
>       return
>    end subroutine nlsm2
> !-----------------------------------------------------------------------
> 
> !-------------------------------------------------------------------------
>    subroutine nlsm2_repl( ngw, nkb, n, eigr, c, becdr )
> !-----------------------------------------------------------------------
> 
>       !     computes: the array becdr
>       !     becdr(ia,n,iv,is,k)
>       !      =2.0 sum_g> g_k beta(g,iv,is) re[ (i)**(l+1) e^(ig.r_ia) c(g,n)]
>       !
>       !     routine makes use of  c*(g)=c(-g)  (g> see routine ggen)
>       !     input : eigr, c
>       !     output: becdr
>       !
>  
>       USE kinds,      ONLY : DP
>       use ions_base,  only : nsp, na, nat
>       use uspp,       only : nhtol, beta  !, nkb
>       use cvan,       only : ish
>       use uspp_param, only : nh
>       use cell_base,  only : tpiba
>       use mp,         only : mp_sum
>       use mp_global,  only : nproc_image, intra_image_comm
>       use reciprocal_vectors, only : gx, gstart
> !
>       implicit none
>     
>       integer,  intent(in)  :: ngw, nkb, n
>       real(DP), intent(in)  :: eigr(2,ngw,nat), c(2,ngw,n)
>       real(DP), intent(out) :: becdr(nkb,n,3)
>       !
>       real(DP), allocatable :: gk(:)
>       real(DP), allocatable :: wrk2(:,:,:)
>       !
>       integer   :: ig, is, iv, ia, k, l, ixr, ixi, inl, isa, i
>       real(DP) :: signre, signim, arg
> !
>       call start_clock( 'nlsm2' )
204c494,510
<                ! compute (-i)^(l+1)
---
>       allocate( gk( ngw ) )
> 
>       becdr = 0.d0
> !
>       do k = 1, 3
> 
>          do ig=1,ngw
>             gk(ig)=gx(k,ig)*tpiba
>          end do
> !
>          isa = 0
> 
>          do is=1,nsp
> 
>             allocate( wrk2( 2, ngw, na( is ) ) )
> 
>             do iv=1,nh(is)
206,213c512,530
<                if (l == 0) then
<                   cfact = - cmplx( 0.0_dp , 1.0_dp )
<                else if (l == 1) then
<                   cfact = - cmplx( 0.0_dp , 1.0_dp )
<                   cfact = cfact * cfact
<                else if (l == 2) then
<                   cfact = - cmplx( 0.0_dp , 1.0_dp )
<                   cfact = cfact * cfact * cfact
---
>                !     order of states:  s_1  p_x1  p_z1  p_y1  s_2  p_x2  p_z2  p_y2
>                !
> !$omp parallel default(shared), private(l,ixr,ixi,signre,signim,ig,arg,ia)
>                l=nhtol(iv,is)
>                if (l.eq.0) then
>                   ixr = 2
>                   ixi = 1
>                   signre =  1.0d0
>                   signim = -1.0d0
>                else if (l.eq.1) then
>                   ixr = 1
>                   ixi = 2
>                   signre = -1.0d0
>                   signim = -1.0d0
>                else if (l.eq.2) then
>                   ixr = 2
>                   ixi = 1
>                   signre = -1.0d0
>                   signim =  1.0d0
215c532,535
<                   cfact =   cmplx( 1.0_dp , 0.0_dp )
---
>                   ixr = 1
>                   ixi = 2
>                   signre =  1.0d0
>                   signim =  1.0d0
217c537
< 
---
> !    
222c542,543
<                      wrk2(1,ia) = cfact*gk(1)*beta(1,iv,is)*eigr(1,ia+isa)
---
>                      wrk2(1,1,ia) = signre*gk(1)*beta(1,iv,is)*eigr(ixr,1,ia+isa)
>                      wrk2(2,1,ia) = signim*gk(1)*beta(1,iv,is)*eigr(ixi,1,ia+isa)
227c548,549
<                      wrk2(ig,ia) = cfact * arg * eigr(ig,ia+isa)
---
>                      wrk2(1,ig,ia) = signre*arg*eigr(ixr,ig,ia+isa)
>                      wrk2(2,ig,ia) = signim*arg*eigr(ixi,ig,ia+isa)
233,234c555
<                CALL dgemm( 'T', 'N', na(is), nbsp_bgrp, 2*ngw, 1.0d0, wrk2, 2*ngw, &
<                            c_bgrp, 2*ngw, 0.0d0, becdr_bgrp( inl, 1, k ), nkb )
---
>                CALL dgemm( 'T', 'N', na(is), n, 2*ngw, 1.0d0, wrk2, 2*ngw, c, 2*ngw, 0.0d0, becdr( inl, 1, k ), nkb )
242a564,566
>          IF( nproc_image > 1 ) THEN
>             CALL mp_sum( becdr(:,:,k), intra_image_comm )
>          END IF
247,250d570
<       IF( nproc_bgrp > 1 ) THEN
<          CALL mp_sum( becdr_bgrp, intra_bgrp_comm )
<       END IF
< 
254c574
<    end subroutine nlsm2_bgrp_x
---
>    end subroutine nlsm2_repl
260c580
<    SUBROUTINE ennl_x( ennl_val, rhovan, bec_bgrp )
---
>    real(8) function ennl( rhovan, bec )
266,269c586,590
<       use uspp_param,     only : nh, ish
<       use uspp,           only : dvan
<       use electrons_base, only : nbsp_bgrp, nspin, ispin_bgrp, f_bgrp, nbspx_bgrp
<       use ions_base,      only : nsp, na
---
>       use cvan,           only : ish
>       use uspp_param,     only : nhm, nh
>       use uspp,           only : nkb, dvan
>       use electrons_base, only : n => nbsp, nspin, ispin, f
>       use ions_base,      only : nsp, nat, na
275,277c596,597
<       real(DP), intent(out) :: ennl_val
<       real(DP), intent(out) :: rhovan( :, :, : )
<       real(DP), intent(in)  :: bec_bgrp( :, : )
---
>       real(DP) :: bec( nkb, n )
>       real(DP) :: rhovan( nhm*(nhm+1)/2, nat, nspin )
304,306c624,626
<                   do i = 1, nbsp_bgrp
<                      iss = ispin_bgrp(i)
<                      sums(iss) = sums(iss) + f_bgrp(i) * bec_bgrp(inl,i) * bec_bgrp(jnl,i)
---
>                   do i = 1, n
>                      iss = ispin(i)
>                      sums(iss) = sums(iss) + f(i) * bec(inl,i) * bec(jnl,i)
322c642
<       ennl_val = ennl_t
---
>       ennl = ennl_t
325c645
<    end subroutine ennl_x
---
>    end function ennl
330c650
<    subroutine calrhovan_x( rhovan, bec, iwf )
---
>    subroutine calrhovan( rhovan, bec, iwf )
336c656,657
<       use uspp_param,     only : nhm, nh, ish
---
>       use cvan,           only : ish
>       use uspp_param,     only : nhm, nh
345,346c666,667
<       real(DP), intent(out) :: rhovan( :, :, : )
<       real(DP), intent(in) :: bec( :, : )
---
>       real(DP) :: bec( nkb, n )
>       real(DP) :: rhovan( nhm*(nhm+1)/2, nat, nspin )
373c694
<    end subroutine calrhovan_x
---
>    end subroutine calrhovan
379c700
<    subroutine calbec_x ( nspmn, nspmx, eigr, c, bec )
---
>    subroutine calbec ( nspmn, nspmx, eigr, c, bec )
391c712
<       use ions_base,      only : na
---
>       use ions_base,      only : na, nat
393,396c714,719
<       use electrons_base, only : nbsp
<       use control_flags,  only : iverbosity
<       use uspp_param,     only : nh, ish
<       use cp_interfaces,  only : nlsm1
---
>       use cvan,           only : ish
>       use electrons_base, only : n => nbsp
>       use gvecw,          only : ngw
>       use control_flags,  only : iprint, iprsta
>       use uspp_param,     only : nh
>       use uspp,           only : nkb
401,402c724,725
<       real(DP),    intent(out) :: bec( :, : )
<       complex(DP), intent(in)  :: c( :, : ), eigr( :, : )
---
>       real(DP),    intent(out) :: bec( nkb, n )
>       complex(DP), intent(in)  :: c( ngw, n ), eigr( ngw,nat )
407a731
> !
409,410c733
<       !
<       call nlsm1( nbsp, nspmn, nspmx, eigr, c, bec )
---
>       call nlsm1( n, nspmn, nspmx, eigr, c, bec )
412c735
<       if ( iverbosity > 2 ) then
---
>       if ( iprsta > 2 ) then
415,416c738,743
<             WRITE( stdout,'(33x,a,i4)') ' calbec: bec (is)',is
<             do ia=1,na(is)
---
>             if(nspmx.gt.1) then
>                WRITE( stdout,'(33x,a,i4)') ' calbec: bec (is)',is
>                WRITE( stdout,'(8f9.4)')                                       &
>      &              ((bec(ish(is)+(iv-1)*na(is)+1,i),iv=1,nh(is)),i=1,n)
>             else
>                do ia=1,na(is)
419,420c746,748
<      &             ((bec(ish(is)+(iv-1)*na(is)+ia,i),iv=1,nh(is)),i=1,nbsp)
<             end do
---
>      &             ((bec(ish(is)+(iv-1)*na(is)+ia,i),iv=1,nh(is)),i=1,n)
>                end do
>             end if
426c754
<    end subroutine calbec_x
---
>    end subroutine calbec
429,463d756
< !-----------------------------------------------------------------------
<    subroutine calbec_bgrp_x ( nspmn, nspmx, eigr, c_bgrp, bec_bgrp )
< !-----------------------------------------------------------------------
< 
<       !     this routine calculates array bec
<       !
<       !        < psi_n | beta_i,i > = c_n(0) beta_i,i(0) +
<       !                 2 sum_g> re(c_n*(g) (-i)**l beta_i,i(g) e^-ig.r_i)
<       !
<       !     routine makes use of c(-g)=c*(g)  and  beta(-g)=beta*(g)
<       !
< 
<       USE kinds,          ONLY : DP
<       use ions_base,      only : na, nat
<       use electrons_base, only : nbsp_bgrp, nbspx_bgrp
<       use gvecw,          only : ngw
<       use uspp_param,     only : nh, ish
<       use uspp,           only : nkb
<       use cp_interfaces,  only : nlsm1
< !
<       implicit none
<       !
<       integer,     intent(in)  :: nspmn, nspmx
<       real(DP),    intent(out) :: bec_bgrp( :, : )
<       complex(DP), intent(in)  :: c_bgrp( :, : ), eigr( :, : )
< !
<       call start_clock( 'calbec' )
<       !
<       call nlsm1( nbsp_bgrp, nspmn, nspmx, eigr, c_bgrp, bec_bgrp )
<       !
<       call stop_clock( 'calbec' )
< !
<       return
<    end subroutine calbec_bgrp_x
< 
466c759
< SUBROUTINE caldbec_bgrp_x( eigr, c_bgrp, dbec, descla )
---
> SUBROUTINE caldbec( ngw, nkb, n, nspmn, nspmx, eigr, c, dbec )
480,488c773,782
<   use mp_global,  only : nproc_bgrp, intra_bgrp_comm, inter_bgrp_comm, nbgrp
<   use ions_base,  only : na, nat, nsp
<   use uspp,       only : nhtol, nkb, dbeta
<   use uspp_param, only : nh, nhm, ish
<   use gvect,      only : gstart
<   use gvecw,      only : ngw
<   USE descriptors,        ONLY : la_descriptor
<   use electrons_base,     only : nspin, iupdwn, nupdwn, nbspx_bgrp, iupdwn_bgrp, nupdwn_bgrp, &
<                                  ibgrp_g2l, i2gupdwn_bgrp, nbspx, nbsp_bgrp
---
>   use mp_global,  only : nproc_image, intra_image_comm
>   use ions_base,  only : na, nat
>   use cvan,       only : ish
>   use cdvan,      only : dbeta
>   use uspp,       only : nhtol
>   use uspp_param, only : nh, nhm
>   use reciprocal_vectors, only : gstart
>   USE cp_main_variables,  ONLY : descla, la_proc, nlax, nlam
>   USE descriptors,        ONLY : nlar_ , nlac_ , ilar_ , ilac_ , nlax_ , la_myr_ , la_myc_
>   use electrons_base,     only : nspin, iupdwn, nupdwn
492,495c786,790
<   complex(DP), intent(in)  :: c_bgrp( :, : )
<   complex(DP), intent(in)  :: eigr(:,:)
<   real(DP),    intent(out) :: dbec( :, :, :, : )
<   TYPE(la_descriptor), intent(in) :: descla( : )
---
>   integer,      intent(in)  :: ngw, nkb, n
>   integer,      intent(in)  :: nspmn, nspmx
>   complex(DP), intent(in)  :: c(ngw,n)
>   real(DP),    intent(in)  :: eigr(2,ngw,nat)
>   real(DP),    intent(out) :: dbec( nkb, 2*nlam, 3, 3 )
497,498c792
<   complex(DP), allocatable :: wrk2(:,:)
<   real(DP),    allocatable :: dwrk_bgrp(:,:)
---
>   real(DP), allocatable :: wrk2(:,:,:), dwrk(:,:)
500,502c794,795
<   integer   :: ig, is, iv, ia, l, inl, i, j, ii, isa, nanh, iw, iss, nr, ir, istart, nss
<   integer   :: n1, n2, m1, m2, ibgrp_i, nrcx
<   complex(DP) :: cfact
---
>   integer   :: ig, is, iv, ia, l, ixr, ixi, inl, i, j, ii, isa, nanh, iw, iss, nr, ir, istart, nss
>   real(DP) :: signre, signim, arg
504d796
<   nrcx = MAXVAL(descla(:)%nrcx)
506d797
<   dbec = 0.0d0
511a803,805
>         do is = 1, nspmn - 1
>           isa = isa + na(is)
>         end do
513,514c807,808
<         do is=1,nsp
<            allocate( wrk2( ngw, na(is) ) )
---
>         do is=nspmn,nspmx
>            allocate( wrk2( 2, ngw, na(is) ) )
516c810
<            allocate( dwrk_bgrp( nanh, nbspx_bgrp ) )
---
>            allocate( dwrk( nanh, n ) )
520c814,817
<                  cfact =   cmplx( 1.0_dp , 0.0_dp )
---
>                  ixr = 1
>                  ixi = 2
>                  signre =  1.0d0
>                  signim =  1.0d0
522c819,822
<                  cfact = - cmplx( 0.0_dp , 1.0_dp )
---
>                  ixr = 2
>                  ixi = 1
>                  signre =  1.0d0
>                  signim = -1.0d0
524,525c824,827
<                  cfact = - cmplx( 0.0_dp , 1.0_dp )
<                  cfact = cfact * cfact
---
>                  ixr = 1
>                  ixi = 2
>                  signre = -1.0d0
>                  signim = -1.0d0
527,528c829,832
<                  cfact = - cmplx( 0.0_dp , 1.0_dp )
<                  cfact = cfact * cfact * cfact
---
>                  ixr = 2
>                  ixi = 1
>                  signre = -1.0d0
>                  signim =  1.0d0
536c840,841
<                     wrk2(1,ia)= cfact*dbeta(1,iv,is,i,j)*eigr(1,ia+isa)
---
>                     wrk2(1,1,ia)= signre*dbeta(1,iv,is,i,j)*eigr(ixr,1,ia+isa)
>                     wrk2(2,1,ia)= signim*dbeta(1,iv,is,i,j)*eigr(ixi,1,ia+isa)
540c845,847
<                     wrk2(ig,ia) = 2.0d0*cfact*dbeta(ig,iv,is,i,j)*eigr(ig,ia+isa)
---
>                     arg = 2.0d0*dbeta(ig,iv,is,i,j)
>                     wrk2(1,ig,ia) = signre*arg*eigr(ixr,ig,ia+isa)
>                     wrk2(2,ig,ia) = signim*arg*eigr(ixi,ig,ia+isa)
544c851
<               CALL dgemm( 'T', 'N', na(is), nbsp_bgrp, 2*ngw, 1.0d0, wrk2, 2*ngw, c_bgrp, 2*ngw, 0.0d0, dwrk_bgrp(inl,1), nanh )
---
>               CALL dgemm( 'T', 'N', na(is), n, 2*ngw, 1.0d0, wrk2, 2*ngw, c, 2*ngw, 0.0d0, dwrk(inl,1), nanh )
547,549c854,855
< 
<            if( nproc_bgrp > 1 ) then
<               call mp_sum( dwrk_bgrp, intra_bgrp_comm )
---
>            if( nproc_image > 1 ) then
>               call mp_sum( dwrk, intra_image_comm )
551d856
< 
554,556c859,861
<               IF( descla( iss )%active_node > 0 ) THEN
<                  nr = descla( iss )%nr
<                  ir = descla( iss )%ir
---
>               IF( la_proc ) THEN
>                  nr = descla( nlar_ , iss )
>                  ir = descla( ilar_ , iss )
560,565c865,867
<                     ibgrp_i = ibgrp_g2l( ii + ir - 1 + istart - 1 )
<                     IF( ibgrp_i > 0 ) THEN
<                        do iw = 1, nanh
<                           dbec( iw + inl - 1, ii + (iss-1)*nrcx, i, j ) = dwrk_bgrp( iw, ibgrp_i )
<                        end do
<                     END IF
---
>                     do iw = 1, nanh
>                        dbec( iw + inl - 1, ii + (iss-1)*nspin, i, j ) = dwrk( iw, ii + ir - 1 + istart - 1 )
>                     end do
569c871
<            deallocate( dwrk_bgrp )
---
>            deallocate( dwrk )
575,577d876
<   if( nbgrp > 1 ) then
<      CALL mp_sum( dbec, inter_bgrp_comm )
<   end if
580c879
< end subroutine caldbec_bgrp_x
---
> end subroutine caldbec
583d881
< 
585c883
< subroutine dennl_x( bec_bgrp, dbec, drhovan, denl, descla )
---
> subroutine dennl( bec, dbec, drhovan, denl )
592c890,891
<   use uspp_param, only : nh, nhm, ish
---
>   use cvan,       only : ish
>   use uspp_param, only : nh, nhm
598,601c897,901
<   use mp_global,  only : intra_bgrp_comm
<   USE descriptors,        ONLY : la_descriptor
<   use electrons_base,     only : nbspx_bgrp, nbsp_bgrp, ispin_bgrp, f_bgrp, nspin, iupdwn, nupdwn, ibgrp_g2l
<   use gvect, only : gstart
---
>   use mp_global,  only : intra_image_comm
>   USE cp_main_variables,  ONLY : descla, la_proc, nlax, nlam
>   USE descriptors,        ONLY : nlar_ , nlac_ , ilar_ , ilac_ , nlax_ , la_myr_ , la_myc_
>   use electrons_base,     only : n => nbsp, ispin, f, nspin, iupdwn, nupdwn
>   use reciprocal_vectors, only : gstart
605,607c905,907
<   real(DP), intent(in)  :: dbec( :, :, :, : )
<   real(DP), intent(in)  :: bec_bgrp( :, : )
<   real(DP), intent(out) :: drhovan( :, :, :, :, : )
---
>   real(DP), intent(in)  :: dbec( nkb, 2*nlam, 3, 3 )
>   real(DP), intent(in)  :: bec( nkb, n )
>   real(DP), intent(out) :: drhovan( nhm*(nhm+1)/2, nat, nspin, 3, 3 )
609d908
<   TYPE(la_descriptor), intent(in) :: descla( : )
613,615c912
<   integer   :: istart, nss, ii, ir, nr, ibgrp, nrcx
<   !
<   nrcx = MAXVAL(descla(:)%nrcx)
---
>   integer   :: istart, nss, ii, ir, nr
619a917,919
>   IF( la_proc ) THEN
> 
> 
634,652c934,940
<                  IF( ( descla( iss )%active_node > 0 ) .AND. ( descla( iss )%myr == descla( iss )%myc ) ) THEN
<                     nr = descla( iss )%nr
<                     ir = descla( iss )%ir
<                     istart = iupdwn( iss )
<                     nss    = nupdwn( iss )
<                     do i=1,nr
<                        ii = i+istart-1+ir-1
<                        ibgrp = ibgrp_g2l( ii )
<                        IF( ibgrp > 0 ) THEN
<                           do k=1,3
<                              do j=1,3
<                                 dsums(iss,k,j)=dsums(iss,k,j)+f_bgrp(ibgrp)*       &
<  &                          (dbec(inl,i+(iss-1)*nrcx,k,j)*bec_bgrp(jnl,ibgrp)          &
<  &                          + bec_bgrp(inl,ibgrp)*dbec(jnl,i+(iss-1)*nrcx,k,j))
<                              enddo
<                           enddo
<                        END IF
<                     end do
<                     dsum=0.d0
---
>                  IF( descla( la_myr_ , iss ) == descla( la_myc_ , iss ) ) THEN
>                  nr = descla( nlar_ , iss )
>                  ir = descla( ilar_ , iss )
>                  istart = iupdwn( iss )
>                  nss    = nupdwn( iss )
>                  do i=1,nr
>                     ii = i+istart-1+ir-1
655,656c943,945
<                           drhovan(ijv,isa,iss,j,k)=dsums(iss,j,k)
<                           dsum(j,k)=dsum(j,k)+dsums(iss,j,k)
---
>                           dsums(iss,k,j)=dsums(iss,k,j)+f(ii)*       &
>  &                          (dbec(inl,i+(iss-1)*nlam,k,j)*bec(jnl,ii)          &
>  &                          + bec(inl,ii)*dbec(jnl,i+(iss-1)*nlam,k,j))
659,660c948,962
<                     if(iv.ne.jv) dsum=2.d0*dsum
<                     denl = denl + dsum * dvan(jv,iv,is)
---
>                  end do
>                  END IF
>               end do
>               !
>               do iss=1,nspin
>                  IF( descla( la_myr_ , iss ) == descla( la_myc_ , iss ) ) THEN
>                  dsum=0.d0
>                  do k=1,3
>                     do j=1,3
>                        drhovan(ijv,isa,iss,j,k)=dsums(iss,j,k)
>                        dsum(j,k)=dsum(j,k)+dsums(iss,j,k)
>                     enddo
>                  enddo
>                  if(iv.ne.jv) dsum=2.d0*dsum
>                  denl = denl + dsum * dvan(jv,iv,is)
668,669c970,977
<   CALL mp_sum( denl,    intra_bgrp_comm )
<   CALL mp_sum( drhovan, intra_bgrp_comm )
---
>   END IF
> 
>   CALL mp_sum( denl,    intra_image_comm )
>   do k=1,3
>      do j=1,3
>         CALL mp_sum( drhovan(:,:,:,j,k), intra_image_comm )
>      end do
>   end do
681c989
< end subroutine dennl_x
---
> end subroutine dennl
686d993
< 
688c995
< subroutine nlfq_bgrp_x( c_bgrp, eigr, bec_bgrp, becdr_bgrp, fion )
---
> subroutine nlfq( c, eigr, bec, becdr, fion )
695c1002,1003
<   use uspp_param,     only : nhm, nh, ish, nvb
---
>   use uspp_param,     only : nhm, nh
>   use cvan,           only : ish, nvb
697c1005
<   use electrons_base, only : nbsp_bgrp, f_bgrp, nbspx_bgrp, ispin_bgrp
---
>   use electrons_base, only : n => nbsp, ispin, f, nspin, iupdwn, nupdwn
700c1008
<   use mp_global,      only : intra_bgrp_comm, nbgrp, inter_bgrp_comm
---
>   use mp_global,      only : me_image, intra_image_comm, nproc_image
702c1010,1012
<   use cp_interfaces,  only : nlsm2_bgrp
---
>   USE cp_main_variables, ONLY: nlax, descla, la_proc
>   USE descriptors,       ONLY: nlar_ , nlac_ , ilar_ , ilac_ , lambda_node_ , &
>                                la_myr_ , la_myc_
706,709c1016,1019
<   COMPLEX(DP), INTENT(IN)  ::  c_bgrp( :, : ), eigr( :, : )
<   REAL(DP),    INTENT(IN)  ::  bec_bgrp( :, : )
<   REAL(DP),    INTENT(OUT)  ::  becdr_bgrp( :, :, : )
<   REAL(DP),    INTENT(OUT) ::  fion( :, : )
---
>   real(DP),    intent(in)  :: bec( nkb, n ), c( 2, ngw, n )
>   real(DP),    intent(out) :: becdr( nkb, nspin*nlax, 3 )
>   complex(DP), intent(in)  :: eigr( ngw, nat )
>   real(DP),    intent(out) :: fion( 3, nat )
711c1021
<   integer  :: k, is, ia, isa, inl, iv, jv, i
---
>   integer   :: k, is, ia, isa, iss, inl, iv, jv, i, ir, nr, nss, istart, ioff
713d1022
<   real(DP) :: sum_tmpdr
722a1032
>   !
725c1035
<   call nlsm2_bgrp( ngw, nkb, eigr, c_bgrp, becdr_bgrp, nbspx_bgrp, nbsp_bgrp )
---
>   call nlsm2( ngw, nkb, n, nspin, eigr, c, becdr )
729a1040
> 
733,736c1044,1045
< !$omp parallel default(none), &
< !$omp shared(becdr_bgrp,bec_bgrp,fion_loc,k,f_bgrp,deeq,dvan,nbsp_bgrp,ish,nh,na,nsp,nhm,nbspx_bgrp,ispin_bgrp), &
< !$omp private(tmpbec,tmpdr,isa,is,ia,iv,jv,inl,temp,i,mytid,ntids,sum_tmpdr)
< 
---
> !$omp parallel default(shared), &
> !$omp private(tmpbec,tmpdr,isa,is,ia,iss,nss,istart,ir,nr,ioff,iv,jv,inl,temp,i,mytid,ntids)
742c1051
<      allocate ( tmpbec( nhm, nbspx_bgrp ), tmpdr( nhm, nbspx_bgrp ) )
---
>      allocate ( tmpbec( nhm, nlax ), tmpdr( nhm, nlax ) )
755a1065,1075
>            DO iss = 1, nspin
> 
>               nss = nupdwn( iss )
>               istart = iupdwn( iss )
> 
>               IF( la_proc .AND. &
>                   ( descla( la_myr_ , iss ) == descla( la_myc_ , iss ) ) ) THEN
> 
>                  ! only processors on the diagonal of the square proc grid enter here.
>                  ! This is to distribute the load among different multi-core nodes,
>                  ! and maximize the memory bandwith per core.
759a1080,1084
>                  ir = descla( ilar_ , iss )
>                  nr = descla( nlar_ , iss )
> 
>                  ioff = istart-1+ir-1
> 
763,765c1088,1090
<                        do i = 1, nbsp_bgrp
<                           temp = dvan(iv,jv,is) + deeq(jv,iv,isa,ispin_bgrp( i ) )
<                           tmpbec(iv,i) = tmpbec(iv,i) + temp * bec_bgrp(inl,i)
---
>                        temp=dvan(iv,jv,is)+deeq(jv,iv,isa,iss)
>                        do i=1,nr
>                           tmpbec(iv,i)=tmpbec(iv,i)+temp*bec(inl,i+ioff)
772,773c1097,1098
<                     do i = 1, nbsp_bgrp
<                        tmpdr(iv,i) = f_bgrp( i ) * becdr_bgrp( inl, i, k )
---
>                     do i=1,nr
>                        tmpdr(iv,i)=f(i+ioff)*becdr( inl, i+(iss-1)*nlax, k )
777,780c1102,1104
<                  sum_tmpdr = 0.0d0
<                  do i = 1, nbsp_bgrp
<                     do iv = 1, nh(is)
<                        sum_tmpdr = sum_tmpdr + tmpdr(iv,i)*tmpbec(iv,i)
---
>                  do i=1,nr
>                     do iv=1,nh(is)
>                        tmpdr(iv,i)=tmpdr(iv,i)*tmpbec(iv,i)
784c1108
<                  fion_loc(k,isa) = fion_loc(k,isa)-2.d0*sum_tmpdr
---
>                  fion_loc(k,isa) = fion_loc(k,isa)-2.d0*SUM(tmpdr)
785a1110,1111
>               END IF
>            END DO
790d1115
< 
793,795c1118
<   IF( nbgrp > 1 ) THEN
<      CALL mp_sum( fion_loc, inter_bgrp_comm )
<   END IF
---
>   CALL mp_sum( fion_loc, intra_image_comm )
806c1129,1130
< end subroutine nlfq_bgrp_x
---
> end subroutine nlfq
> 
Only in ../../../ffn2_tsvdw_master/CPV: nl_base.F90
Only in ../../../ffn2_tsvdw_master/CPV: nl_base.o
diff ./nlcc.f90 ../../../ffn2_tsvdw_master/CPV/nlcc.f90
20d19
<      use uspp,               ONLY : nlcc_any
22c21
<      use smallbox_gvec,      ONLY : ngb, gb
---
>      use gvecb,              ONLY : ngb, gb
24a24
>      use cp_interfaces,      ONLY : build_cctab, chkpstab
28,30c28,29
<      use gvect,              ONLY : ngm
<      use gvect,              ONLY : gg, gstart
<      USE core,               ONLY : rhocb, rhocg, drhocg
---
>      use reciprocal_vectors, ONLY : ngm, g, gstart
>      USE core,               ONLY : rhocb, rhocg, drhocg, nlcc_any
46a46,51
>      IF( tpstab ) THEN
>         !
>         CALL build_cctab( )
>         !
>      END IF
>      !
66c71
<                     xg = SQRT( gg(ig) ) * tpiba
---
>                     xg = SQRT( g(ig) ) * tpiba
74c79
<                                      rgrid(is)%rab, upf(is)%rho_atc(:), gg, &
---
>                                      rgrid(is)%rab, upf(is)%rho_atc(:), g, &
98c103
<       use control_flags,      only: iverbosity
---
>       use control_flags,      only: iprsta
100c105
<       use mp_global,          only: intra_bgrp_comm
---
>       use mp_global,          only: intra_image_comm
101a107
>       use recvecs_indexes,    only: np
106,108c112,116
<       use gvect, only: gstart
<       use gvect,              only: ngm, nl
<       USE fft_interfaces,     ONLY: fwfft
---
>       use reciprocal_vectors, only: gstart
>       use gvecp,              only: ngm
>       use grid_dimensions,    only: nr1, nr2, nr3, &
>                                     nr1x, nr2x, nr3x, nnrx
>       USE cp_interfaces,      ONLY: fwfft
113,114c121,122
<       REAL(DP),    INTENT(IN)   :: rhoc( dfftp%nnr )
<       REAL(DP),    INTENT(INOUT):: rhor( dfftp%nnr, nspin )
---
>       REAL(DP),    INTENT(IN)   :: rhoc( nnrx )
>       REAL(DP),    INTENT(INOUT):: rhor( nnrx, nspin )
122,124c130,132
<       IF( iverbosity > 2 ) THEN
<          rsum = SUM( rhoc ) * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
<          CALL mp_sum( rsum, intra_bgrp_comm )
---
>       IF( iprsta > 2 ) THEN
>          rsum = SUM( rhoc ) * omega / DBLE(nr1*nr2*nr3)
>          CALL mp_sum( rsum, intra_image_comm )
133c141
<          call daxpy(dfftp%nnr,1.d0,rhoc,1,rhor(1,iss),1)
---
>          call daxpy(nnrx,1.d0,rhoc,1,rhor(1,iss),1)
137,138c145,146
<          call daxpy(dfftp%nnr,0.5d0,rhoc,1,rhor(1,isup),1)
<          call daxpy(dfftp%nnr,0.5d0,rhoc,1,rhor(1,isdw),1)
---
>          call daxpy(nnrx,0.5d0,rhoc,1,rhor(1,isup),1)
>          call daxpy(nnrx,0.5d0,rhoc,1,rhor(1,isdw),1)
143c151
<       allocate( wrk1( dfftp%nnr ) )
---
>       allocate( wrk1( nnrx ) )
153c161
<             rhog(ig,iss)=rhog(ig,iss)+wrk1(nl(ig))
---
>             rhog(ig,iss)=rhog(ig,iss)+wrk1(np(ig))
157,158c165,166
<             rhog(ig,isup)=rhog(ig,isup)+0.5d0*wrk1(nl(ig))
<             rhog(ig,isdw)=rhog(ig,isdw)+0.5d0*wrk1(nl(ig))
---
>             rhog(ig,isup)=rhog(ig,isup)+0.5d0*wrk1(np(ig))
>             rhog(ig,isdw)=rhog(ig,isdw)+0.5d0*wrk1(np(ig))
177,187c185,198
<       USE kinds,             ONLY: DP
<       use electrons_base,    only: nspin
<       use smallbox_gvec,     only: gxb, ngb, npb, nmb
<       use cell_base,         only: omega
<       use ions_base,         only: nsp, na, nat
<       use small_box,         only: tpibab
<       use uspp_param,        only: upf
<       use core,              only: rhocb
<       use fft_interfaces,    only: invfft
<       use fft_base,          only: dfftb, dfftp
<       use gvect,             only: gstart
---
>       USE kinds,           ONLY: DP
>       use electrons_base,  only: nspin
>       use gvecb,           only: gxb, ngb, npb, nmb
>       use grid_dimensions, only: nr1, nr2, nr3, nnr => nnrx
>       use cell_base,       only: omega
>       use ions_base,       only: nsp, na, nat
>       use small_box,       only: tpibab
>       use uspp_param,      only: upf
>       use core,            only: rhocb
>       use cp_interfaces,   only: invfft
>       use fft_base,        only: dfftb
>       use reciprocal_vectors, only: gstart
>       use smallbox_grid_dimensions, only: nr1b, nr2b, nr3b, &
>             nr1bx, nr2bx, nr3bx, nnrb => nnrbx
193,194c204,205
<       complex(dp), intent(in):: eigrb(ngb,nat)
<       real(dp), intent(in)   :: vxc(dfftp%nnr,nspin)
---
>       complex(8), intent(in):: eigrb(ngb,nat)
>       real(8), intent(in)   :: vxc(nnr,nspin)
196c207
<       real(dp), intent(inout):: fion1(3,nat)
---
>       real(8), intent(inout):: fion1(3,nat)
198,202c209,212
<       integer :: iss, ix, ig, is, ia, nfft, isa
<       real(dp) :: fac, res, boxdotgrid
<       complex(dp) ci, facg
<       complex(dp), allocatable :: qv(:)
<       real(dp), allocatable :: fcc(:,:)
---
>       integer iss, ix, ig, is, ia, nfft, isa
>       real(8) fcc(3,nat), fac, boxdotgrid
>       complex(8) ci, facg
>       complex(8), allocatable :: qv(:)
204,208d213
< 
< #ifdef __OPENMP
<       INTEGER :: itid, mytid, ntids, omp_get_thread_num, omp_get_num_threads
<       EXTERNAL :: omp_get_thread_num, omp_get_num_threads
< #endif
211a217,218
>       fac = omega/DBLE(nr1*nr2*nr3*nspin)
>       fcc = 0.d0
213,224c220
<       fac = omega/DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3*nspin)
< 
< !$omp parallel default(none) &      
< !$omp          shared(nsp, na, ngb, eigrb, dfftb, irb, nmb, npb, ci, rhocb, &
< !$omp                 gxb, nat, fac, upf, vxc, nspin, tpibab, fion1 ) &
< !$omp          private(mytid, ntids, is, ia, nfft, ig, isa, qv, itid, res, ix, fcc, facg, iss )
< 
< 
<       allocate( fcc( 3, nat ) )
<       allocate( qv( dfftb%nnr ) )
< 
<       fcc(:,:) = 0.d0
---
>       allocate( qv( nnrb ) )
228,245c224,229
< #ifdef __OPENMP
<       mytid = omp_get_thread_num()  ! take the thread ID
<       ntids = omp_get_num_threads() ! take the number of threads
<       itid  = 0
< #endif
< 
<       do is = 1, nsp
< 
<          if( .not. upf(is)%nlcc ) then
<             isa = isa + na(is) 
<             cycle
<          end if 
< 
< #ifdef __MPI
< 
<          do ia = 1, na(is)
<             nfft = 1
<             if ( dfftb%np3( ia + isa ) <= 0 ) cycle
---
>       do is=1,nsp
>          if( .not. upf(is)%nlcc ) go to 10
> #ifdef __PARA
>          do ia=1,na(is)
>             nfft=1
>             if ( dfftb%np3( ia + isa ) <= 0 ) go to 15
247,249d230
<          !
<          ! two fft's on two atoms at the same time (when possible)
<          !
250a232,234
> !
> ! two fft's on two atoms at the same time (when possible)
> !
252c236
<             if( ia .eq. na(is) ) nfft=1
---
>             if(ia.eq.na(is)) nfft=1
254,263d237
< 
< #ifdef __OPENMP
<             IF ( mytid /= itid ) THEN
<                itid = MOD( itid + 1, ntids )
<                CYCLE
<             ELSE
<                itid = MOD( itid + 1, ntids )
<             END IF
< #endif
< 
282c256
<                call invfft( 'Box', qv, dfftb, ia+isa )
---
>                call invfft('Box',qv,dfftb,ia+isa)
287,292c261,265
<                   res = boxdotgrid(irb(1,ia  +isa),1,qv,vxc(1,iss))
<                   fcc(ix,ia+isa) = fcc(ix,ia+isa) + fac * res
<                   if (nfft.eq.2) then
<                      res = boxdotgrid(irb(1,ia+1+isa),2,qv,vxc(1,iss))
<                      fcc(ix,ia+1+isa) = fcc(ix,ia+1+isa) + fac * res 
<                   end if
---
>                   fcc(ix,ia+isa) = fcc(ix,ia+isa) + fac *               &
>      &                 boxdotgrid(irb(1,ia  +isa),1,qv,vxc(1,iss))
>                   if (nfft.eq.2)                                         &
>      &               fcc(ix,ia+1+isa) = fcc(ix,ia+1+isa) + fac *           &
>      &                    boxdotgrid(irb(1,ia+1+isa),2,qv,vxc(1,iss))
294a268
> 15          continue
296c270
< 
---
> 10       continue
298d271
< 
300d272
< 
302d273
< !$omp critical
306d276
< !$omp end critical
309,311d278
<       deallocate( fcc )
< 
< !$omp end parallel
314d280
< 
326,334c292,302
< ! 
<       use kinds, only: dp
<       use ions_base,         only: nsp, na, nat
<       use uspp_param,        only: upf
<       use smallbox_gvec,     only: ngb, npb, nmb
<       use control_flags,     only: iprint
<       use core,              only: rhocb
<       use fft_interfaces,    only: invfft
<       use fft_base,          only: dfftb, dfftp
---
> !
>       use ions_base,       only: nsp, na, nat
>       use uspp_param,      only: upf
>       use grid_dimensions, only: nr3, nnr => nnrx
>       use gvecb,           only: ngb, npb, nmb
>       use control_flags,   only: iprint
>       use core,            only: rhocb
>       use cp_interfaces,   only: invfft
>       use fft_base,        only: dfftb
>       use smallbox_grid_dimensions, only: nr1b, nr2b, nr3b, &
>             nr1bx, nr2bx, nr3bx, nnrb => nnrbx
339c307
<       complex(dp), intent(in):: eigrb(ngb,nat)
---
>       complex(8), intent(in):: eigrb(ngb,nat)
341c309
<       real(dp), intent(out)  :: rhoc(dfftp%nnr)
---
>       real(8), intent(out)  :: rhoc(nnr)
344,351c312,314
<       complex(dp) ci
<       complex(dp), allocatable :: wrk1(:)
<       complex(dp), allocatable :: qv(:)
< 
< #ifdef __OPENMP
<       INTEGER :: itid, mytid, ntids, omp_get_thread_num, omp_get_num_threads
<       EXTERNAL :: omp_get_thread_num, omp_get_num_threads
< #endif
---
>       complex(8) ci
>       complex(8), allocatable :: wrk1(:)
>       complex(8), allocatable :: qv(:)
355,357d317
< 
<       allocate( wrk1 ( dfftp%nnr ) )
<       wrk1 (:) = (0.d0, 0.d0)
359,364c319,321
< !$omp parallel default(none) &      
< !$omp          shared(nsp, na, ngb, eigrb, dfftb, irb, nmb, npb, ci, rhocb, &
< !$omp                 nat, upf, wrk1 ) &
< !$omp          private(mytid, ntids, is, ia, nfft, ig, isa, qv, itid )
< 
<       allocate( qv ( dfftb%nnr ) )
---
>       allocate( qv ( nnrb ) )
>       allocate( wrk1 ( nnr ) )
>       wrk1 (:) = (0.d0, 0.d0)
367,381c324,326
< 
< #ifdef __OPENMP
<       mytid = omp_get_thread_num()  ! take the thread ID
<       ntids = omp_get_num_threads() ! take the number of threads
<       itid  = 0
< #endif
< 
<       do is = 1, nsp
<          !
<          if (.not.upf(is)%nlcc) then
<             isa = isa + na(is)
<             cycle
<          end if
<          !
< #ifdef __MPI
---
>       do is=1,nsp
>          if (.not.upf(is)%nlcc) go to 10
> #ifdef __PARA
384c329
<             if ( dfftb%np3( ia + isa ) <= 0 ) cycle
---
>             if ( dfftb%np3( ia + isa ) <= 0 ) go to 15
386,388d330
<          !
<          ! two ffts at the same time, on two atoms (if possible: nfft=2)
<          !
391a334,336
> !
> ! two ffts at the same time, on two atoms (if possible: nfft=2)
> !
393,402d337
< 
< #ifdef __OPENMP
<             IF ( mytid /= itid ) THEN
<                itid = MOD( itid + 1, ntids )
<                CYCLE
<             ELSE
<                itid = MOD( itid + 1, ntids )
<             END IF
< #endif
< 
418c353
<             call invfft( 'Box', qv, dfftb, isa+ia )
---
>             call invfft('Box',qv,dfftb,isa+ia)
422a358
> 15          continue
423a360
> 10       continue
427,431c364
<       deallocate( qv  )
< 
< !$omp end parallel
< 
<       call dcopy( dfftp%nnr, wrk1, 2, rhoc, 1 )
---
>       call dcopy(nnr,wrk1,2,rhoc,1)
432a366
>       deallocate( qv  )
Only in ../../../ffn2_tsvdw_master/CPV: nlcc.F90
Only in ../../../ffn2_tsvdw_master/CPV: nlcc.o
diff ./ortho_base.f90 ../../../ffn2_tsvdw_master/CPV/ortho_base.f90
36c36
<       PUBLIC :: updatc, calphi_bgrp
---
>       PUBLIC :: updatc, calphi
42d41
<       PUBLIC :: bec_bgrp2ortho
94c93
<       USE descriptors
---
>       USE descriptors, ONLY: lambda_node_ , nlax_ 
105c104
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER,   INTENT(IN) :: desc(:)
115c114
<       IF ( desc%active_node > 0 ) THEN
---
>       IF ( desc( lambda_node_ ) > 0 ) THEN
117c116
<          IF( SIZE(s,1) /= desc%nrcx ) &
---
>          IF( SIZE(s,1) /= desc( nlax_ ) ) &
125c124
<          CALL pdsyevd_drv( .true. , n, desc%nrcx, s, SIZE(s,1), rhod, ortho_cntx )
---
>          CALL pdsyevd_drv( .true. , n, desc( nlax_ ), s, SIZE(s,1), rhod, ortho_cntx )
142c141
<       USE mp_global,   ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm, root_bgrp
---
>       USE mp_global,   ONLY: nproc_image, me_image, intra_image_comm, root_image
147c146,147
<       USE descriptors, ONLY: la_descriptor, descla_init
---
>       USE descriptors, ONLY: descla_siz_ , descla_init , nlar_ , nlac_ , &
>                              ilar_ , ilac_ , nlax_ , lambda_node_ , la_myc_ , la_myr_
155c155
<       TYPE(la_descriptor) :: desc
---
>       INTEGER  :: desc( descla_siz_ )
172c172
<       IF( desc%active_node > 0 ) nx = desc%nrcx
---
>       IF( desc( lambda_node_ ) > 0 ) nx = desc( nlax_ )
174,177c174,177
<       nr = desc%nr
<       nc = desc%nc
<       ir = desc%ir
<       ic = desc%ic
---
>       nr = desc( nlar_ )
>       nc = desc( nlac_ )
>       ir = desc( ilar_ )
>       ic = desc( ilac_ )
191c191
<       CALL mp_barrier( intra_bgrp_comm )
---
>       CALL mp_barrier( intra_image_comm )
197c197
<       CALL mp_max( tpar, intra_bgrp_comm )
---
>       CALL mp_max( tpar, intra_image_comm )
201c201,202
<       IF( desc%myc == 0 .AND. desc%myr == 0 .AND. desc%active_node > 0  .AND. n < paradim ) THEN
---
>       IF( desc( la_myc_ ) == 0 .AND. desc( la_myr_ ) == 0 .AND. &
>           desc( lambda_node_ ) > 0  .AND. n < paradim ) THEN
227c228
<       CALL mp_max( tser, intra_bgrp_comm )
---
>       CALL mp_max( tser, intra_image_comm )
229c230
< #if defined __MPI
---
> #if defined __PARA
252c253
<       CALL mp_bcast( use_parallel_diag, root_bgrp, intra_bgrp_comm )
---
>       CALL mp_bcast( use_parallel_diag, root_image, intra_image_comm )
262c263
<          IF( desc%active_node < 0 ) RETURN
---
>          IF( desc( lambda_node_ ) < 0 ) RETURN
285,286c286,287
<       USE mp_global,   ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm, &
<                              root_bgrp, ortho_comm, nproc_ortho, np_ortho, &
---
>       USE mp_global,   ONLY: nproc_image, me_image, intra_image_comm, &
>                              root_image, ortho_comm, nproc_ortho, np_ortho, &
291c292
<       USE descriptors, ONLY: descla_init , la_descriptor
---
>       USE descriptors, ONLY: descla_siz_ , descla_init , nlar_ , nlac_ , la_comm_ , lambda_node_
300c301
<       TYPE(la_descriptor) :: desc
---
>       INTEGER  :: desc( descla_siz_ )
313c314
<       CALL init_ortho_group( np * np, intra_bgrp_comm )
---
>       CALL init_ortho_group( np * np, intra_image_comm )
317,318c318,319
<       nr = desc%nr
<       nc = desc%nc
---
>       nr = desc( nlar_ )
>       nc = desc( nlac_ )
329c330
<       CALL mp_barrier( intra_bgrp_comm )
---
>       CALL mp_barrier( intra_image_comm )
335c336
<       CALL mp_max( tcan, intra_bgrp_comm )
---
>       CALL mp_max( tcan, intra_image_comm )
340c341
< #if defined __MPI
---
> #if defined __PARA
357c358
< #if defined __MPI
---
> #if defined __PARA
385c386
<       USE mp_global,         ONLY: intra_bgrp_comm, me_bgrp, nproc_bgrp
---
>       USE mp_global,         ONLY: intra_image_comm, me_image, nproc_image
387c388,389
<       USE descriptors,       ONLY: la_descriptor
---
>       USE descriptors,       ONLY: nlar_ , nlac_ , ilar_ , ilac_ , lambda_node_ , &
>                                    la_myr_ , la_myc_ , la_comm_ , descla_siz_ , nlax_
392c394
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER, INTENT(IN) :: desc( descla_siz_ )
418c420
<       IF( desc%active_node < 0 ) then
---
>       IF( desc( lambda_node_ ) < 0 ) then
426,429c428,431
<       nr = desc%nr
<       nc = desc%nc
<       ir = desc%ir
<       ic = desc%ic
---
>       nr = desc( nlar_ )
>       nc = desc( nlac_ )
>       ir = desc( ilar_ )
>       ic = desc( ilac_ )
431c433
<       IF( ldx/= desc%nrcx ) &
---
>       IF( ldx/= desc( nlax_ ) ) &
483,484c485
<          CALL mp_max( diff, desc%comm )
< 
---
>          CALL mp_max( diff, desc( la_comm_ ) )
518c519
<       CALL mp_max( iter, intra_bgrp_comm ) 
---
>       CALL mp_max( iter, intra_image_comm ) 
537c538
<       USE mp_global,         ONLY: intra_bgrp_comm, me_bgrp, nproc_bgrp
---
>       USE mp_global,         ONLY: intra_image_comm, me_image, nproc_image
539c540,541
<       USE descriptors,       ONLY: la_descriptor
---
>       USE descriptors,       ONLY: nlar_ , nlac_ , ilar_ , ilac_ , lambda_node_ , &
>                                    la_myr_ , la_myc_ , la_comm_ , descla_siz_ , nlax_
544c546
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER, INTENT(IN) :: desc( descla_siz_ )
566c568
<       if( desc%active_node < 0 ) then
---
>       if( desc( lambda_node_ ) < 0 ) then
574,577c576,579
<       nr = desc%nr
<       nc = desc%nc
<       ir = desc%ir
<       ic = desc%ic
---
>       nr = desc( nlar_ )
>       nc = desc( nlac_ )
>       ir = desc( ilar_ )
>       ic = desc( ilac_ )
579c581
<       IF( ldx/= desc%nrcx ) &
---
>       IF( ldx/= desc( nlax_ ) ) &
637c639
<         IF( desc%myr == desc%myc ) THEN
---
>         IF( desc( la_myr_ ) == desc( la_myc_ ) ) THEN
643c645
<         CALL mp_sum( sigd, desc%comm )
---
>         CALL mp_sum( sigd, desc( la_comm_ ) )
666c668
<         CALL mp_max( diff, desc%comm )
---
>         CALL mp_max( diff, desc( la_comm_ ) )
681c683
<       CALL mp_max( iter, intra_bgrp_comm ) 
---
>       CALL mp_max( iter, intra_image_comm ) 
688c690
<    SUBROUTINE sigset( cp, ngwx, becp_dist, nkbx, qbecp, n, nss, ist, sig, ldx, desc )
---
>    SUBROUTINE sigset( cp, ngwx, becp, nkbx, qbecp, n, nss, ist, sig, ldx, desc )
698c700
<       USE uspp_param,         ONLY: nvb
---
>       USE cvan,               ONLY: nvb
700,702c702,704
<       USE gvect, ONLY: gstart
<       USE mp,                 ONLY: mp_root_sum, mp_sum
<       USE control_flags,      ONLY: iverbosity
---
>       USE reciprocal_vectors, ONLY: gstart
>       USE mp,                 ONLY: mp_root_sum
>       USE control_flags,      ONLY: iprsta
704,705c706,709
<       USE mp_global,          ONLY: intra_bgrp_comm, leg_ortho, inter_bgrp_comm, my_bgrp_id, nbgrp
<       USE descriptors,        ONLY: la_descriptor, descla_init
---
>       USE mp_global,          ONLY: intra_image_comm, leg_ortho
>       USE descriptors,        ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                     descla_init , la_comm_ , ilar_ , ilac_ , nlar_ , &
>                                     nlac_ , la_myr_ , la_myc_ , la_nx_ , la_n_ , nlax_
712,713c716
<       REAL(DP)    :: qbecp( nkbx, ldx )
<       REAL(DP)    :: becp_dist( nkbx, ldx )
---
>       REAL(DP)    :: becp( nkbx, n ), qbecp( nkbx, ldx )
715c718
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER     :: desc( descla_siz_ )
719c722
<       TYPE(la_descriptor):: desc_ip
---
>       INTEGER :: desc_ip( descla_siz_ )
726,727c729,730
<       np(1) = desc%npr
<       np(2) = desc%npc
---
>       np(1) = desc( la_npr_ )
>       np(2) = desc( la_npc_ )
729c732
<       nx = desc%nrcx
---
>       nx = desc( nlax_ )
733,734c736,737
<       IF( desc%active_node > 0 ) THEN
<          IF( desc%nrcx /= ldx ) &
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
>          IF( desc( nlax_ ) /= ldx ) &
740,743d742
<       IF( nbgrp > 1 ) THEN
<          sig = 0.0d0
<       END IF
< 
745d743
< 
751c749
<             CALL descla_init( desc_ip, desc%n, desc%nx, np, coor_ip, desc%comm, 1 )
---
>             CALL descla_init( desc_ip, desc( la_n_ ), desc( la_nx_ ), np, coor_ip, desc( la_comm_ ), 1 )
753,756c751,754
<             nr = desc_ip%nr
<             nc = desc_ip%nc
<             ir = desc_ip%ir
<             ic = desc_ip%ic
---
>             nr = desc_ip( nlar_ )
>             nc = desc_ip( nlac_ )
>             ir = desc_ip( ilar_ )
>             ic = desc_ip( ilac_ )
758,761c756,757
<             CALL GRID2D_RANK( 'R', desc_ip%npr, desc_ip%npc, &
<                                    desc_ip%myr, desc_ip%myc, root )
< 
<             IF( MOD( root , nbgrp ) == my_bgrp_id ) THEN
---
>             CALL GRID2D_RANK( 'R', desc_ip( la_npr_ ), desc_ip( la_npc_ ), &
>                                    desc_ip( la_myr_ ), desc_ip( la_myc_ ), root )
763c759
<                root = root * leg_ortho
---
>             root = root * leg_ortho
765,776c761,770
<                CALL dgemm( 'T', 'N',  nr, nc, 2*ngw, -2.0d0, cp( 1, ist + ir - 1), 2*ngwx, &
<                            cp( 1, ist + ic - 1 ), 2*ngwx, 0.0d0, sigp, nx )
<                !
<                !     q = 0  components has weight 1.0
<                !
<                IF ( gstart == 2 ) THEN
<                   CALL DGER( nr, nc, 1.D0, cp(1,ist+ir-1), 2*ngwx, cp(1,ist+ic-1), 2*ngwx, sigp, nx )
<                END IF
<                !
<                CALL mp_root_sum( sigp, sig, root, intra_bgrp_comm )
<                !
<             ENDIF
---
>             CALL dgemm( 'T', 'N',  nr, nc, 2*ngw, -2.0d0, cp( 1, ist + ir - 1), 2*ngwx, &
>                         cp( 1, ist + ic - 1 ), 2*ngwx, 0.0d0, sigp, nx )
>             !
>             !     q = 0  components has weight 1.0
>             !
>             IF ( gstart == 2 ) THEN
>                CALL DGER( nr, nc, 1.D0, cp(1,ist+ir-1), 2*ngwx, cp(1,ist+ic-1), 2*ngwx, sigp, nx )
>             END IF
>             !
>             CALL mp_root_sum( sigp, sig, root, intra_image_comm )
784,787d777
<       IF( nbgrp > 1 ) THEN
<          CALL mp_sum( sig, inter_bgrp_comm )
<       END IF
<       !
790c780
<       IF( desc%active_node > 0 ) THEN
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
792,795c782,785
<          nr = desc%nr
<          nc = desc%nc
<          ir = desc%ir
<          ic = desc%ic
---
>          nr = desc( nlar_ )
>          nc = desc( nlac_ )
>          ir = desc( ilar_ )
>          ic = desc( ilac_ )
797c787
<          IF( desc%myr == desc%myc ) THEN
---
>          IF( desc( la_myr_ ) == desc( la_myc_ ) ) THEN
804c794
<             CALL dgemm( 'T', 'N', nr, nc, nkbus, -1.0d0, becp_dist( 1, 1 ), &
---
>             CALL dgemm( 'T', 'N', nr, nc, nkbus, -1.0d0, becp( 1, ist+ir-1 ), &
808c798
<          IF( iverbosity > 3 ) THEN
---
>          IF( iprsta > 4 ) THEN
834c824
<       USE gvect,              ONLY: gstart
---
>       USE reciprocal_vectors, ONLY: gstart
836c826
<       USE uspp_param,         ONLY: nvb
---
>       USE cvan,               ONLY: nvb
838,841c828,830
<       USE mp,                 ONLY: mp_root_sum, mp_sum
<       USE mp_global,          ONLY: intra_bgrp_comm, me_bgrp, leg_ortho
<       USE mp_global,          ONLY: inter_bgrp_comm, my_bgrp_id, nbgrp
<       USE control_flags,      ONLY: iverbosity
---
>       USE mp,                 ONLY: mp_root_sum
>       USE mp_global,          ONLY: intra_image_comm, me_image, leg_ortho
>       USE control_flags,      ONLY: iprsta
843c832,835
<       USE descriptors,        ONLY: la_descriptor, descla_init
---
>       USE descriptors,        ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                     descla_init , la_comm_ , ilar_ , ilac_ , nlar_ , &
>                                     nlac_ , la_myr_ , la_myc_ , la_nx_ , la_n_ , nlax_
> 
851c843
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER     :: desc( descla_siz_ )
855c847
<       TYPE(la_descriptor) :: desc_ip
---
>       INTEGER :: desc_ip( descla_siz_ )
866,867c858,859
<       np(1) = desc%npr
<       np(2) = desc%npc
---
>       np(1) = desc( la_npr_ )
>       np(2) = desc( la_npc_ )
869c861
<       nx = desc%nrcx
---
>       nx = desc( nlax_ )
871,872c863,864
<       IF( desc%active_node > 0 ) THEN
<          IF( desc%nrcx /= ldx ) &
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
>          IF( desc( nlax_ ) /= ldx ) &
881,883d872
<       IF( nbgrp > 1 ) THEN
<          rho = 0.0d0
<       END IF
891c880
<             CALL descla_init( desc_ip, desc%n, desc%nx, np, coor_ip, desc%comm, 1 )
---
>             CALL descla_init( desc_ip, desc( la_n_ ), desc( la_nx_ ), np, coor_ip, desc( la_comm_ ), 1 )
893,896c882,885
<             nr = desc_ip%nr
<             nc = desc_ip%nc
<             ir = desc_ip%ir
<             ic = desc_ip%ic
---
>             nr = desc_ip( nlar_ )
>             nc = desc_ip( nlac_ )
>             ir = desc_ip( ilar_ )
>             ic = desc_ip( ilac_ )
898,899c887,888
<             CALL GRID2D_RANK( 'R', desc_ip%npr, desc_ip%npc, &
<                                    desc_ip%myr, desc_ip%myc, root )
---
>             CALL GRID2D_RANK( 'R', desc_ip( la_npr_ ), desc_ip( la_npc_ ), &
>                                    desc_ip( la_myr_ ), desc_ip( la_myc_ ), root )
901,902d889
<             IF( MOD( root , nbgrp ) == my_bgrp_id ) THEN
< 
914,916c901
<             CALL mp_root_sum( rhop, rho, root, intra_bgrp_comm )
< 
<             END IF
---
>             CALL mp_root_sum( rhop, rho, root, intra_image_comm )
923,927c908
<       IF( nbgrp > 1 ) THEN
<          CALL mp_sum( rho, inter_bgrp_comm )
<       END IF
< 
<       IF( desc%active_node > 0 ) THEN
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
929,930c910,911
<          nr = desc%nr
<          nc = desc%nc
---
>          nr = desc( nlar_ )
>          nc = desc( nlac_ )
945c926
<          IF ( iverbosity > 3 ) THEN
---
>          IF ( iprsta > 4 ) THEN
969c950
<       USE uspp_param,         ONLY: nvb
---
>       USE cvan,               ONLY: nvb
972,974c953,955
<       USE gvect,              ONLY: gstart
<       USE mp,                 ONLY: mp_root_sum, mp_sum
<       USE control_flags,      ONLY: iverbosity
---
>       USE reciprocal_vectors, ONLY: gstart
>       USE mp,                 ONLY: mp_root_sum
>       USE control_flags,      ONLY: iprsta
976,978c957,960
<       USE mp_global,          ONLY: intra_bgrp_comm, leg_ortho
<       USE mp_global,          ONLY: inter_bgrp_comm, my_bgrp_id, nbgrp
<       USE descriptors,        ONLY: la_descriptor, descla_init
---
>       USE mp_global,          ONLY: intra_image_comm, leg_ortho
>       USE descriptors,        ONLY: lambda_node_ , la_npc_ , la_npr_ , descla_siz_ , &
>                                     descla_init , la_comm_ , ilar_ , ilac_ , nlar_ , &
>                                     nlac_ , la_myr_ , la_myc_ , la_nx_ , la_n_ , nlax_
987c969
<       TYPE(la_descriptor), INTENT(IN) :: desc
---
>       INTEGER     :: desc( descla_siz_ )
991c973
<       TYPE(la_descriptor) :: desc_ip
---
>       INTEGER :: desc_ip( descla_siz_ )
1000,1001c982,983
<       np(1) = desc%npr
<       np(2) = desc%npc
---
>       np(1) = desc( la_npr_ )
>       np(2) = desc( la_npc_ )
1003c985
<       nx = desc%nrcx
---
>       nx = desc( nlax_ )
1005,1006c987,988
<       IF( desc%active_node > 0 ) THEN
<          IF( desc%nrcx /= ldx ) &
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
>          IF( desc( nlax_ ) /= ldx ) &
1016,1019d997
<       IF( nbgrp > 1 ) THEN
<          tau = 0.0d0
<       END IF
<       !
1029c1007
<             CALL descla_init( desc_ip, desc%n, desc%nx, np, coor_ip, desc%comm, 1 )
---
>             CALL descla_init( desc_ip, desc( la_n_ ), desc( la_nx_ ), np, coor_ip, desc( la_comm_ ), 1 )
1031,1034c1009,1012
<             nr = desc_ip%nr
<             nc = desc_ip%nc
<             ir = desc_ip%ir
<             ic = desc_ip%ic
---
>             nr = desc_ip( nlar_ )
>             nc = desc_ip( nlac_ )
>             ir = desc_ip( ilar_ )
>             ic = desc_ip( ilac_ )
1036,1037c1014,1015
<             CALL GRID2D_RANK( 'R', desc_ip%npr, desc_ip%npc, &
<                                    desc_ip%myr, desc_ip%myc, root )
---
>             CALL GRID2D_RANK( 'R', desc_ip( la_npr_ ), desc_ip( la_npc_ ), &
>                                    desc_ip( la_myr_ ), desc_ip( la_myc_ ), root )
1039,1040d1016
<             IF( MOD( root , nbgrp ) == my_bgrp_id ) THEN
< 
1055,1057c1031
<             CALL mp_root_sum( taup, tau, root, intra_bgrp_comm )
<             !
<             END IF
---
>             CALL mp_root_sum( taup, tau, root, intra_image_comm )
1065,1068d1038
<       IF( nbgrp > 1 ) THEN
<          CALL mp_sum( tau, inter_bgrp_comm )
<       END IF
<       !
1071c1041
<       IF( desc%active_node > 0 ) THEN
---
>       IF( desc( lambda_node_ ) > 0 ) THEN
1073,1074c1043,1044
<          nr = desc%nr
<          nc = desc%nc
---
>          nr = desc( nlar_ )
>          nc = desc( nlac_ )
1086c1056
<          IF( iverbosity > 3 ) THEN
---
>          IF( iprsta > 4 ) THEN
1101c1071
<    SUBROUTINE updatc( ccc, x0, phi, bephi, becp_bgrp, bec_bgrp, cp_bgrp, desc )
---
>    SUBROUTINE updatc( ccc, n, x0, nx0, phi, ngwx, bephi, nkbx, becp, bec, cp, nss, istart, desc )
1114a1085
>       USE cvan,              ONLY: nvb, ish
1116c1087
<       USE uspp_param,        ONLY: nh, nvb, ish
---
>       USE uspp_param,        ONLY: nh
1118c1089
<       USE control_flags,     ONLY: iverbosity
---
>       USE control_flags,     ONLY: iprint, iprsta
1120,1122c1091,1094
<       USE mp_global,         ONLY: intra_bgrp_comm, leg_ortho, me_bgrp, inter_bgrp_comm
<       USE electrons_base,    ONLY: nbspx_bgrp, ibgrp_g2l, nbsp, nspin,  nupdwn, iupdwn, nbspx
<       USE descriptors,       ONLY: descla_init, la_descriptor
---
>       USE mp_global,         ONLY: intra_image_comm, leg_ortho, me_image
>       USE descriptors,       ONLY: nlar_ , nlac_ , ilar_ , ilac_ , lambda_node_ , descla_siz_ , la_comm_ , &
>                                    la_npc_ , la_npr_ , nlax_ , la_n_ , la_nx_ , la_myr_ , la_myc_ , &
>                                    descla_init
1126,1127c1098,1100
<       TYPE(la_descriptor), INTENT(IN) :: desc( : )
<       COMPLEX(DP) :: cp_bgrp( :, : ), phi( :, : )
---
>       INTEGER, INTENT(IN) :: n, nx0, ngwx, nkbx, istart, nss
>       INTEGER, INTENT(IN) :: desc( descla_siz_ )
>       COMPLEX(DP) :: cp( ngwx, n ), phi( ngwx, n )
1129,1131c1102,1103
<       REAL(DP)    :: bec_bgrp( :, : ), x0( :, :, : )
<       REAL(DP)    :: bephi( :, : )
<       REAL(DP)    :: becp_bgrp( :, : )
---
>       REAL(DP)    :: bec( nkbx, n ), x0( nx0, nx0 )
>       REAL(DP)    :: bephi( :, : ), becp( nkbx, n )
1135,1137c1107
<       INTEGER :: i, j, ig, is, iv, ia, inl, nr, nc, ir, ic, nx0, ngwx, nkbx, iss, nrcx
<       INTEGER :: ipr, ipc, root, i1, i2, nss, istart
<       INTEGER :: ibgrp_i, ibgrp_i_first, nbgrp_i, i_first
---
>       INTEGER :: i, j, ig, is, iv, ia, inl, nr, nc, ir, ic
1140a1111,1112
>       REAL(DP) :: beta
>       INTEGER :: ipr, ipc, nx, root
1142c1114,1132
<       TYPE(la_descriptor) :: desc_ip
---
>       INTEGER :: desc_ip( descla_siz_ )
>       !
>       !     lagrange multipliers
>       !
>       IF( nss < 1 ) RETURN
>       !
>       IF( desc( lambda_node_ ) > 0 ) THEN
>          IF( nx0 /= desc( nlax_ ) ) &
>             CALL errore( " updatc ", " inconsistent dimension nx0 ", nx0 )
>       END IF
>       !
>       !  size of the local block
>       !
>       nx = desc( nlax_ )
>       !
>       np(1) = desc( la_npr_ )
>       np(2) = desc( la_npc_ )
>       !
>       CALL start_clock( 'updatc' )
1144,1168c1134,1147
<       DO iss = 1, nspin
<          !
<          !  size of the local block
<          !
<          nrcx = desc( iss )%nrcx
<          !
<          nss = nupdwn(iss)
<          istart = iupdwn(iss)
<          i1 = (iss-1)*nrcx+1
<          i2 = iss*nrcx
<          nx0 = SIZE( x0, 1 )
<          ngwx = SIZE( phi, 1 )
<          nkbx = SIZE( bephi, 1 )
<          !
<          !     lagrange multipliers
<          !
<          IF( nss < 1 ) CYCLE
<          !
<          IF( desc( iss )%active_node > 0 ) THEN
<             IF( nx0 /= desc( iss )%nrcx ) &
<                CALL errore( " updatc ", " inconsistent dimension nx0 ", nx0 )
<          END IF
<          !
<          np(1) = desc( iss )%npr
<          np(2) = desc( iss )%npc
---
>       ALLOCATE( xd( nx, nx ) )
> 
>       IF( nvb > 0 )THEN
>          ALLOCATE( wtemp( nx, nkb ) )
>          ALLOCATE( bephi_tmp( nkbx, nx ) )
>          DO i = 1, nss
>             DO inl = 1, nkbus
>                bec( inl, i + istart - 1 ) = 0.0d0
>             END DO
>          END DO
>       END IF
> 
> 
>       DO ipc = 1, np(2)
1170,1173d1148
<          CALL start_clock( 'updatc' )
<    
<          ALLOCATE( xd( nrcx, nrcx ) )
<    
1175,1184c1150,1164
<             DO i = 1, nss
<                ibgrp_i = ibgrp_g2l( i + istart - 1 )
<                IF( ibgrp_i > 0 ) THEN
<                   DO inl = 1, nkbus
<                      bec_bgrp( inl, ibgrp_i ) = becp_bgrp( inl, ibgrp_i )
<                   END DO
<                END IF
<             END DO
<             ALLOCATE( wtemp( nrcx, nkb ) )
<             ALLOCATE( bephi_tmp( nkbx, nrcx ) )
---
>             ! 
>             ! For the inner loop we need the block of bebhi( :, ic : ic + nc - 1 )
>             ! this is the same of block bephi( :, ir : ir + nr - 1 ) on processor
>             ! with coords ipr == ipc
>             !
>             ! get the right processor owning the block of bephi
>             !
>             CALL GRID2D_RANK( 'R', np(1), np(2), ipc-1, ipc-1, root )
>             root = root * leg_ortho
>             !
>             ! broadcast the block to all processors 
>             ! 
>             IF( me_image == root ) bephi_tmp = bephi
>             CALL mp_bcast( bephi_tmp, root, intra_image_comm )
>             !
1186,1188c1166,1167
<    
<    
<          DO ipc = 1, np(2)
---
> 
>          DO ipr = 1, np(1)
1190,1205c1169,1185
<             IF( nvb > 0 )THEN
<                ! 
<                ! For the inner loop we need the block of bebhi( :, ic : ic + nc - 1 )
<                ! this is the same of block bephi( :, ir : ir + nr - 1 ) on processor
<                ! with coords ipr == ipc
<                !
<                ! get the right processor owning the block of bephi
<                !
<                CALL GRID2D_RANK( 'R', np(1), np(2), ipc-1, ipc-1, root )
<                root = root * leg_ortho
<                !
<                ! broadcast the block to all processors 
<                ! 
<                IF( me_bgrp == root ) bephi_tmp = bephi(:,i1:i2)
<                CALL mp_bcast( bephi_tmp, root, intra_bgrp_comm )
<                !
---
>             coor_ip(1) = ipr - 1
>             coor_ip(2) = ipc - 1
> 
>             CALL descla_init( desc_ip, desc( la_n_ ), desc( la_nx_ ), np, coor_ip, desc( la_comm_ ), 1 )
> 
>             nr = desc_ip( nlar_ )
>             nc = desc_ip( nlac_ )
>             ir = desc_ip( ilar_ )
>             ic = desc_ip( ilac_ )
>             !
>             CALL GRID2D_RANK( 'R', desc_ip( la_npr_ ), desc_ip( la_npc_ ), &
>                                    desc_ip( la_myr_ ), desc_ip( la_myc_ ), root )
> 
>             root = root * leg_ortho
> 
>             IF( desc( la_myr_ ) == ipr - 1 .AND. desc( la_myc_ ) == ipc - 1 .AND. desc( lambda_node_ ) > 0 ) THEN
>                xd = x0 * ccc
1207,1210c1187,1195
<    
<             DO ipr = 1, np(1)
<                !
<                ! Compute the descriptor of processor with coord: ( ipr-1, ipc-1 ), in the ortho group
---
> 
>             CALL mp_bcast( xd, root, intra_image_comm )
> 
>             CALL dgemm( 'N', 'N', 2*ngw, nc, nr, 1.0d0, phi(1,istart+ir-1), 2*ngwx, &
>                         xd, nx, 1.0d0, cp(1,istart+ic-1), 2*ngwx )
> 
>             IF( nvb > 0 )THEN
> 
>                !     updating of the <beta|c(n,g)>
1212,1220c1197
<                coor_ip(1) = ipr - 1
<                coor_ip(2) = ipc - 1
<    
<                CALL descla_init( desc_ip, desc( iss )%n, desc( iss )%nx, np, coor_ip, desc( iss )%comm, 1 )
<    
<                nr = desc_ip%nr
<                nc = desc_ip%nc
<                ir = desc_ip%ir
<                ic = desc_ip%ic
---
>                !     bec of vanderbilt species are updated 
1222,1223c1199
<                CALL GRID2D_RANK( 'R', desc_ip%npr, desc_ip%npc, &
<                                       desc_ip%myr, desc_ip%myc, root )
---
>                CALL dgemm( 'N', 'T', nr, nkbus, nc, 1.0d0, xd, nx, bephi_tmp, nkbx, 0.0d0, wtemp, nx )
1225,1226c1201
<                ! we need to update only states local to the current band group,
<                ! so here we compute the overlap between ortho and band group.
---
>                ! here nr and ir are still valid, since they are the same for all procs in the same row
1228,1269c1203,1205
<                nbgrp_i = 0
<                DO i = 1, nc
<                   ibgrp_i = ibgrp_g2l( i + istart + ic - 2 )
<                   IF( ibgrp_i > 0 ) THEN
<                      IF( nbgrp_i == 0 ) THEN
<                         ibgrp_i_first = ibgrp_i
<                         i_first = i
<                      END IF
<                      nbgrp_i = nbgrp_i + 1
<                   END IF
<                END DO
<    
<                root = root * leg_ortho
<    
<                IF( desc( iss )%myr == ipr - 1 .AND. &
<                    desc( iss )%myc == ipc - 1 .AND. &
<                    desc( iss )%active_node > 0 ) THEN
<                   xd = x0(:,:,iss) * ccc
<                END IF
<    
<                CALL mp_bcast( xd, root, intra_bgrp_comm )
<    
<                CALL dgemm( 'N', 'N', 2*ngw, nbgrp_i, nr, 1.0d0, phi(1,istart+ir-1), 2*ngwx, &
<                            xd(1,i_first), nrcx, 1.0d0, cp_bgrp(1,ibgrp_i_first), 2*ngwx )
<    
<                IF( nvb > 0 )THEN
<    
<                   !     updating of the <beta|c(n,g)>
<                   !
<                   !     bec of vanderbilt species are updated 
<                   !
<                   CALL dgemm( 'N', 'T', nr, nkbus, nc, 1.0d0, xd, nrcx, bephi_tmp, nkbx, 0.0d0, wtemp, nrcx )
<                   !
<                   ! here nr and ir are still valid, since they are the same for all procs in the same row
<                   !
<                   DO i = 1, nr
<                      ibgrp_i = ibgrp_g2l( i + istart + ir - 2 )
<                      IF( ibgrp_i > 0 ) THEN
<                         DO inl = 1, nkbus
<                            bec_bgrp( inl, ibgrp_i ) = bec_bgrp( inl, ibgrp_i ) + wtemp( i, inl ) 
<                         END DO
<                      END IF
---
>                DO i = 1, nr
>                   DO inl = 1, nkbus
>                      bec( inl, i + istart + ir - 2 ) = bec( inl, i + istart + ir - 2 ) + wtemp( i, inl ) 
1271,1273c1207,1220
<                   !
<                END IF
<    
---
>                END DO
>                !
>             END IF
> 
>          END DO
>          !    
>       END DO
> 
>       IF( nvb > 0 )THEN
>          DEALLOCATE( wtemp )
>          DEALLOCATE( bephi_tmp )
>          DO i = istart, istart + nss - 1
>             DO inl = 1, nkbus
>                bec( inl, i ) = bec( inl, i ) + becp( inl, i ) 
1275d1221
<             !    
1277,1283c1223,1238
<    
<          IF( nvb > 0 )THEN
<             DEALLOCATE( wtemp )
<             DEALLOCATE( bephi_tmp )
<          END IF
<          !
<          IF ( iverbosity > 2 ) THEN
---
>       END IF
> !
>       IF ( iprsta > 2 ) THEN
>          WRITE( stdout,*)
>          DO is = 1, nvb
>             IF( nvb > 1 ) THEN
>                WRITE( stdout,'(33x,a,i4)') ' updatc: bec (is)',is
>                WRITE( stdout,'(8f9.4)')                                       &
>      &            ((bec(ish(is)+(iv-1)*na(is)+1,i+istart-1),iv=1,nh(is)),i=1,nss)
>             ELSE
>                DO ia=1,na(is)
>                   WRITE( stdout,'(33x,a,i4)') ' updatc: bec (ia)',ia
>                   WRITE( stdout,'(8f9.4)')                                    &
>      &            ((bec(ish(is)+(iv-1)*na(is)+ia,i+istart-1),iv=1,nh(is)),i=1,nss)
>                END DO
>             END IF
1285,1303c1240,1243
<             DO is = 1, nvb
<                IF( nvb > 1 ) THEN
<                   WRITE( stdout,'(33x,a,i4)') ' updatc: bec (is)',is
<                   WRITE( stdout,'(8f9.4)')                                       &
<         &            ((bec_bgrp(ish(is)+(iv-1)*na(is)+1,i+istart-1),iv=1,nh(is)),i=1,nss)
<                ELSE
<                   DO ia=1,na(is)
<                      WRITE( stdout,'(33x,a,i4)') ' updatc: bec (ia)',ia
<                      WRITE( stdout,'(8f9.4)')                                    &
<         &            ((bec_bgrp(ish(is)+(iv-1)*na(is)+ia,i+istart-1),iv=1,nh(is)),i=1,nss)
<                   END DO
<                END IF
<                WRITE( stdout,*)
<             END DO
<          ENDIF
<          !
<          DEALLOCATE( xd )
<          !
<       END DO
---
>          END DO
>       ENDIF
>       !
>       DEALLOCATE( xd )
1311a1252
> 
1313c1254
<       SUBROUTINE calphi_bgrp( c0_bgrp, ngwx, bec_bgrp, nkbx, betae, phi_bgrp, nbspx_bgrp, ema0bg )
---
>       SUBROUTINE calphi( c0, ngwx, bec, nkbx, betae, phi, n, ema0bg )
1323,1324c1264,1266
<       USE mp_global,      ONLY: intra_bgrp_comm, inter_bgrp_comm
<       USE uspp_param,     ONLY: nh, ish, nvb
---
>       USE mp_global,      ONLY: intra_image_comm
>       USE cvan,           ONLY: ish, nvb
>       USE uspp_param,     ONLY: nh
1327d1268
<       USE electrons_base, ONLY: nbsp_bgrp, nbsp
1329c1270
<       USE control_flags,  ONLY: iverbosity
---
>       USE control_flags,  ONLY: iprint, iprsta
1334,1336c1275,1277
<       INTEGER, INTENT(IN) :: ngwx, nkbx, nbspx_bgrp
<       COMPLEX(DP)         :: c0_bgrp( ngwx, nbspx_bgrp ), phi_bgrp( ngwx, nbspx_bgrp ), betae( ngwx, nkbx )
<       REAL(DP)            :: bec_bgrp( nkbx, nbspx_bgrp ), emtot
---
>       INTEGER, INTENT(IN) :: ngwx, nkbx, n
>       COMPLEX(DP)         :: c0( ngwx, n ), phi( ngwx, n ), betae( ngwx, nkbx )
>       REAL(DP)            :: bec( nkbx, n ), emtot
1345c1286
<       IF( nbsp_bgrp < 1 ) RETURN
---
>       IF( n < 1 ) RETURN
1348,1349c1289
<       !
<       ! Note that phi here is computed only for my band group
---
> 
1353c1293
<          ALLOCATE( qtemp( nkbus, nbspx_bgrp ) )
---
>          ALLOCATE( qtemp( nkbus, n ) )
1363,1364c1303,1304
<                      DO i=1,nbsp_bgrp
<                         CALL daxpy( na(is), qqf, bec_bgrp(jnl+1,i),1,qtemp(inl+1,i), 1 )
---
>                      DO i=1,n
>                         CALL daxpy( na(is), qqf, bec(jnl+1,i),1,qtemp(inl+1,i), 1 )
1371,1372c1311,1312
<          CALL dgemm ( 'N', 'N', 2*ngw, nbsp_bgrp, nkbus, 1.0d0, betae, &
<                        2*ngwx, qtemp, nkbus, 0.0d0, phi_bgrp, 2*ngwx )
---
>          CALL dgemm ( 'N', 'N', 2*ngw, n, nkbus, 1.0d0, betae, &
>                        2*ngwx, qtemp, nkbus, 0.0d0, phi, 2*ngwx )
1378c1318
<          phi_bgrp = (0.d0, 0.d0)
---
>          phi = (0.d0, 0.d0)
1384c1324
<          DO j=1,nbsp_bgrp
---
>          DO j=1,n
1386c1326
<                phi_bgrp(i,j)=(phi_bgrp(i,j)+c0_bgrp(i,j))*ema0bg(i)
---
>                phi(i,j)=(phi(i,j)+c0(i,j))*ema0bg(i)
1392c1332
<          DO j=1,nbsp_bgrp
---
>          DO j=1,n
1394c1334
<                phi_bgrp(i,j)=phi_bgrp(i,j)+c0_bgrp(i,j)
---
>                phi(i,j)=phi(i,j)+c0(i,j)
1402c1342
<       IF(iverbosity > 2) THEN
---
>       IF(iprsta > 2) THEN
1405c1345
<             DO j=1,nbsp_bgrp
---
>             DO j=1,n
1407c1347
<                   emtot=emtot +2.0d0*DBLE(phi_bgrp(i,j)*CONJG(c0_bgrp(i,j)))*ema0bg(i)**(-2.0d0)
---
>                   emtot=emtot +2.0d0*DBLE(phi(i,j)*CONJG(c0(i,j)))*ema0bg(i)**(-2.0d0)
1411c1351
<             DO j=1,nbsp_bgrp
---
>             DO j=1,n
1413c1353
<                   emtot=emtot +2.0d0*DBLE(phi_bgrp(i,j)*CONJG(c0_bgrp(i,j)))
---
>                   emtot=emtot +2.0d0*DBLE(phi(i,j)*CONJG(c0(i,j)))
1417c1357
<          emtot=emtot/nbsp
---
>          emtot=emtot/n
1419,1420c1359
<          CALL mp_sum( emtot, intra_bgrp_comm )
<          CALL mp_sum( emtot, inter_bgrp_comm )
---
>          CALL mp_sum( emtot, intra_image_comm )
1428c1367
<      &            ((bec_bgrp(ish(is)+(iv-1)*na(is)+1,i),iv=1,nh(is)),i=1,nbsp_bgrp)
---
>      &            ((bec(ish(is)+(iv-1)*na(is)+1,i),iv=1,nh(is)),i=1,n)
1433c1372
<      &               ((bec_bgrp(ish(is)+(iv-1)*na(is)+ia,i),iv=1,nh(is)),i=1,nbsp_bgrp)
---
>      &               ((bec(ish(is)+(iv-1)*na(is)+ia,i),iv=1,nh(is)),i=1,n)
1443,1493c1382
<       END SUBROUTINE calphi_bgrp
< 
< 
<    SUBROUTINE bec_bgrp2ortho( bec_bgrp, bec_ortho, nrcx, desc )
<       USE kinds,             ONLY: DP
<       USE uspp,              ONLY: nkb, nkbus
<       USE mp,                ONLY: mp_sum
<       USE mp_global,         ONLY: intra_bgrp_comm, leg_ortho, me_bgrp, inter_bgrp_comm
<       USE electrons_base,    ONLY: nbspx_bgrp, ibgrp_g2l, nspin
<       USE descriptors,       ONLY: la_descriptor
<       !
<       IMPLICIT NONE
<       !
<       INTEGER, INTENT(IN) :: nrcx
<       TYPE(la_descriptor), INTENT(IN) :: desc( : )
<       REAL(DP), INTENT(IN)  :: bec_bgrp(:,:)
<       REAL(DP), INTENT(OUT) :: bec_ortho(:,:)
<       !
<       INTEGER :: ir, nr, i, ibgrp_i, nup
<       !
<       bec_ortho = 0.0d0
<       !
<       IF( desc( 1 )%active_node > 0 ) THEN
<          ir = desc( 1 )%ir
<          nr = desc( 1 )%nr
<          do i = 1, nr
<             ibgrp_i = ibgrp_g2l( i + ir - 1 )
<             IF( ibgrp_i > 0 ) THEN
<                bec_ortho( :, i ) = bec_bgrp( :, ibgrp_i )
<             END IF
<          end do
<       END IF
<       !
<       IF( nspin == 2 ) THEN
<          IF( desc( 2 )%active_node > 0 ) THEN
<             nup = desc( 1 )%n
<             ir = desc( 2 )%ir
<             nr = desc( 2 )%nr
<             do i = 1, nr
<                ibgrp_i = ibgrp_g2l( i + ir - 1 + nup )
<                IF( ibgrp_i > 0 ) THEN
<                   bec_ortho( :, i + nrcx ) = bec_bgrp( :, ibgrp_i )
<                END IF
<             end do
<          END IF
<       END IF
<       !
<       CALL mp_sum( bec_ortho, inter_bgrp_comm )
<       !
<       RETURN
<    END SUBROUTINE bec_bgrp2ortho
---
>       END SUBROUTINE calphi
1495c1384
< END MODULE orthogonalize_base
---
>    END MODULE orthogonalize_base
Only in ../../../ffn2_tsvdw_master/CPV: ortho_base.F90
Only in ../../../ffn2_tsvdw_master/CPV: ortho_base.o
diff ./ortho.f90 ../../../ffn2_tsvdw_master/CPV/ortho.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
11c11
<    SUBROUTINE ortho_gamma_x( iopt, cp, ngwx, phi, becp_dist, qbecp, nkbx, bephi, qbephi, &
---
>    SUBROUTINE ortho_gamma_x( iopt, cp, ngwx, phi, becp, qbecp, nkbx, bephi, qbephi, &
19,20c19,21
<       USE descriptors,        ONLY: la_descriptor
<       USE mp_global,          ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm
---
>       USE descriptors,        ONLY: lambda_node_ , nlar_ , nlac_ , ilar_ , ilac_ , &
>                                     nlax_ , la_comm_ , descla_siz_
>       USE mp_global,          ONLY: nproc_image, me_image, intra_image_comm
21a23
>       USE cp_main_variables,  ONLY: nlam, la_proc, nlax
31,32c33
<       REAL(DP)    :: bephi( :, : )
<       REAL(DP)    :: becp_dist( :, : )
---
>       REAL(DP)    :: bephi( :, : ), becp( :, : )
35c36
<       TYPE(la_descriptor),  INTENT(IN)  :: descla
---
>       INTEGER,  INTENT(IN)  :: descla( descla_siz_ )
47c48
<       IF( descla%active_node > 0 ) THEN
---
>       IF( la_proc ) THEN
49c50
<          IF( nx0 /= descla%nrcx ) &
---
>          IF( nx0 /= descla( nlax_ ) ) &
50a52,53
>          IF( nlam /= descla( nlax_ ) ) &
>             CALL errore( ' ortho_gamma ', ' inconsistent dimensions nlam ' , nlam )
52,53c55,56
<          nr = descla%nr
<          nc = descla%nc
---
>          nr = descla( nlar_ )
>          nc = descla( nlac_ )
55,56c58,59
<          ir = descla%ir
<          ic = descla%ic
---
>          ir = descla( ilar_ )
>          ic = descla( ilac_ )
62a66,67
>          IF( nlam /= 1 ) &
>             CALL errore( ' ortho_gamma ', ' inconsistent dimensions nlam, should be 1 ' , nlam )
68,86c73,79
<       ALLOCATE( rhos( nx0, nx0 ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating rhos ', ABS( info ) )
<       ALLOCATE( rhoa( nx0, nx0 ), STAT = info )   !   antisymmetric part of rho
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating rhoa ', ABS( info ) )
<       ALLOCATE( s( nx0, nx0 ), STAT = info ) 
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating s ', ABS( info ) )
<       ALLOCATE( sig( nx0, nx0 ), STAT = info ) 
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating sig ', ABS( info ) )
<       ALLOCATE( tau( nx0, nx0 ), STAT = info ) 
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating tau ', ABS( info ) )
<       !
<       ALLOCATE( rhod( nss ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho_gamma ', ' allocating tau ', ABS( rhod ) )
---
>       ALLOCATE( rhos( nlam, nlam ) )
>       ALLOCATE( rhoa( nlam, nlam ) )   !   antisymmetric part of rho
>       ALLOCATE( s( nlam, nlam ) ) 
>       ALLOCATE( sig( nlam, nlam ) ) 
>       ALLOCATE( tau( nlam, nlam ) ) 
>       !
>       ALLOCATE( rhod( nss ) )
92c85
<       CALL rhoset( cp, ngwx, phi, bephi, nkbx, qbecp, n, nss, istart, rhos, nx0, descla )
---
>       CALL rhoset( cp, ngwx, phi, bephi, nkbx, qbecp, n, nss, istart, rhos, nlam, descla )
94c87
<       IF( descla%active_node > 0 ) THEN
---
>       IF( la_proc ) THEN
96,98c89
<          ALLOCATE( rhot( nx0, nx0 ), STAT = info )   !   transpose of rho
<          IF( info /= 0 ) &
<             CALL errore( ' ortho_gamma ', ' allocating rhot ', ABS( rhod ) )
---
>          ALLOCATE( rhot( nlam, nlam ) )   !   transpose of rho
103c94
<          CALL sqr_tr_cannon( nss, rhos, nx0, rhot, nx0, descla )
---
>          CALL sqr_tr_cannon( nss, rhos, nlam, rhot, nlam, descla )
143c134
<          IF( descla%active_node > 0 ) THEN
---
>          IF( la_proc ) THEN
146c137
<             IF( info /= 0 ) CALL errore( ' ortho_gamma ', ' allocating wrk ', 1 )
---
>             IF( info /= 0 ) CALL errore( ' ortho ', ' allocating matrixes ', 1 )
164,166c155
<       CALL start_clock( 'sigset' )
<       CALL sigset( cp, ngwx, becp_dist, nkbx, qbecp, n, nss, istart, sig, nx0, descla )
<       CALL stop_clock( 'sigset' )
---
>       CALL sigset( cp, ngwx, becp, nkbx, qbecp, n, nss, istart, sig, nlam, descla )
170,172c159
<       CALL start_clock( 'tauset' )
<       CALL tauset( phi, ngwx, bephi, nkbx, qbephi, n, nss, istart, tau, nx0, descla )
<       CALL stop_clock( 'tauset' )
---
>       CALL tauset( phi, ngwx, bephi, nkbx, qbephi, n, nss, istart, tau, nlam, descla )
178c165
<          CALL ortho_iterate( iter, diff, s, nx0, rhod, x0, nx0, sig, rhoa, rhos, tau, nss, descla)
---
>          CALL ortho_iterate( iter, diff, s, nlam, rhod, x0, nx0, sig, rhoa, rhos, tau, nss, descla)
182c169
<          CALL ortho_alt_iterate( iter, diff, s, nx0, rhod, x0, nx0, sig, rhoa, tau, nss, descla)
---
>          CALL ortho_alt_iterate( iter, diff, s, nlam, rhod, x0, nx0, sig, rhoa, tau, nss, descla)
190c177
<       IF( descla%active_node > 0 )  CALL consistency_check( x0 )
---
>       IF( la_proc )  CALL consistency_check( x0 )
199c186
<          IF( descla%active_node > 0 ) THEN
---
>          IF( la_proc ) THEN
213c200
<          IF( descla%active_node > 0 ) THEN
---
>          IF( la_proc ) THEN
220c207
<          CALL mp_sum( a, descla%comm )
---
>          CALL mp_sum( a, descla( la_comm_ ) )
247c234,235
<    SUBROUTINE ortho_x( eigr, cp_bgrp, phi_bgrp, x0, descla, diff, iter, ccc, bephi, becp_bgrp )
---
>    SUBROUTINE ortho_cp( eigr, cp, phi, ngwx, x0, descla, diff, iter, ccc, &
>                         bephi, becp, nbsp, nspin, nupdwn, iupdwn )
262a251
>       USE cvan,           ONLY: ish, nvb
264,265c253,254
<       USE uspp_param,     ONLY: nh, ish, nvb
<       USE electrons_base, ONLY: f, nbsp_bgrp, iupdwn_bgrp, nupdwn_bgrp, i2gupdwn_bgrp, nbsp, nspin, nupdwn, iupdwn
---
>       USE uspp_param,     ONLY: nh
>       USE electrons_base, ONLY: f
267c256
<       USE control_flags,  ONLY: iprint, iverbosity, ortho_max
---
>       USE control_flags,  ONLY: iprint, iprsta, ortho_max
270,274c259,262
<       USE cp_interfaces,  ONLY: ortho_gamma, c_bgrp_expand, c_bgrp_pack, nlsm1, collect_bec
<       USE descriptors,    ONLY: la_descriptor
<       USE mp_global,          ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm, inter_bgrp_comm  ! DEBUG
<       USE orthogonalize_base, ONLY: bec_bgrp2ortho
<       USE mp,                 ONLY : mp_sum
---
>       USE cp_interfaces,  ONLY: ortho_gamma
>       USE descriptors,    ONLY: nlac_ , ilac_ , descla_siz_ , nlar_ , ilar_
>       USE cp_main_variables,  ONLY: nlam, la_proc, nlax
>       USE mp_global,          ONLY: nproc_image, me_image, intra_image_comm  ! DEBUG
278,280c266,269
<       TYPE(la_descriptor), INTENT(IN) :: descla(:)
<       COMPLEX(DP) :: eigr(:,:)
<       COMPLEX(DP) :: cp_bgrp(:,:), phi_bgrp(:,:)
---
>       INTEGER,    INTENT(IN) :: ngwx, nbsp, nspin
>       INTEGER,    INTENT(IN) :: nupdwn( nspin ), iupdwn( nspin )
>       INTEGER,    INTENT(IN) :: descla(descla_siz_,nspin)
>       COMPLEX(DP) :: cp(ngwx,nbsp), phi(ngwx,nbsp), eigr(ngwx,nat)
283,284c272
<       REAL(DP)    :: bephi(:,:)
<       REAL(DP)    :: becp_bgrp(:,:)
---
>       REAL(DP)    :: bephi(:,:), becp(:,:)
286,287c274,275
<       REAL(DP), ALLOCATABLE :: xloc(:,:), becp_dist(:,:)
<       REAL(DP), ALLOCATABLE :: qbephi(:,:,:), qbecp(:,:,:), bec_col(:,:)
---
>       REAL(DP), ALLOCATABLE :: xloc(:,:)
>       REAL(DP), ALLOCATABLE :: qbephi(:,:,:), qbecp(:,:,:), bephi_c(:,:)
290,293c278,280
<       INTEGER :: info, i, j, iss, iv, jv, ia, is, inl, jnl
<       INTEGER :: n1, n2, m1, m2
<       INTEGER :: nspin_sub, nx0, ngwx, nrcx
<       REAL(DP) :: qqf, dum
---
>       INTEGER :: istart, nss, ifail, i, j, iss, iv, jv, ia, is, inl, jnl
>       INTEGER :: nspin_sub, nx0, nc, ic, icc, nr, ir
>       REAL(DP) :: qqf
296d282
<       ngwx = SIZE( cp_bgrp, 1 )
299a286,289
>       IF( nx0 /= nlam ) &
>          CALL errore( " ortho_cp ", " inconsistent dimensions for x0 ", nx0 )
>       !
>       !
304c294
<       nrcx = MAXVAL( descla( : )%nrcx )
---
>       CALL nlsm1( nbsp, 1, nvb, eigr,  cp,  becp )
306,322c296
<       ALLOCATE( becp_dist( nkbx, nrcx*nspin ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho ', ' allocating becp_dist ', ABS( info ) )
< 
<       IF( nvb > 0 ) THEN
<          !
<          becp_bgrp = 0.0d0
<          !
<          CALL nlsm1 ( nbsp_bgrp, 1, nvb, eigr, phi_bgrp, becp_bgrp )
<          CALL bec_bgrp2ortho( becp_bgrp, bephi, nrcx, descla )
<          !
<          becp_bgrp = 0.0d0
<          !
<          CALL nlsm1 ( nbsp_bgrp, 1, nvb, eigr, cp_bgrp, becp_bgrp )
<          CALL bec_bgrp2ortho( becp_bgrp, becp_dist, nrcx, descla )
<          !
<       END IF
---
>       CALL nlsm1_dist ( nbsp, 1, nvb, eigr, phi, bephi, nlax, nspin, descla )
326,328c300
<       ALLOCATE( qbephi( nkbx, nx0, nspin ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho ', ' allocating qbephi ', ABS( info ) )
---
>       ALLOCATE( qbephi( nkbx, nx0, nspin ) )
331,334c303,304
<          ALLOCATE( bec_col ( nkbx, nrcx*nspin ), STAT = info )
<          IF( info /= 0 ) &
<             CALL errore( ' ortho ', ' allocating bec_col ', ABS( info ) )
<          CALL redist_row2col( nupdwn(1), bephi, bec_col, nkbx, nrcx, descla(1) )
---
>          ALLOCATE( bephi_c ( nkbx, nlax*nspin ) )
>          CALL redist_row2col( nupdwn(1), bephi, bephi_c, nkbx, nlax, descla(1,1) )
336c306
<             CALL redist_row2col( nupdwn(2), bephi(1,nrcx+1), bec_col(1,nrcx+1), nkbx, nrcx, descla(2) )
---
>             CALL redist_row2col( nupdwn(2), bephi(1,nlax+1), bephi_c(1,nlax+1), nkbx, nlax, descla(1,2) )
350,352c320,326
<                      IF( descla( iss )%active_node > 0 ) THEN
<                         DO i = 1, descla( iss )%nc
<                            CALL daxpy( na(is), qqf, bec_col(jnl+1,i+(iss-1)*nrcx),1,qbephi(inl+1,i,iss), 1 )
---
>                      istart = iupdwn(iss)
>                      nc     = descla( nlac_ , iss )
>                      ic     = descla( ilac_ , iss ) + istart - 1
>                      IF( la_proc ) THEN
>                         DO i = 1, nc
>                            icc=i+ic-1
>                            CALL daxpy( na(is), qqf, bephi_c(jnl+1,i+(iss-1)*nlax),1,qbephi(inl+1,i,iss), 1 ) 
359a334,335
> 
>       IF( nvb > 0 ) DEALLOCATE( bephi_c )
361,363c337
<       ALLOCATE( qbecp ( nkbx, nx0, nspin ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho ', ' allocating qbecp ', ABS( info ) )
---
>       ALLOCATE( qbecp ( nkbx, nx0, nspin ) )
367,373d340
<       IF( nvb > 0 ) THEN
<          CALL redist_row2col( nupdwn(1), becp_dist, bec_col, nkbx, nrcx, descla(1) )
<          IF( nspin == 2 ) THEN
<             CALL redist_row2col( nupdwn(2), becp_dist(1,nrcx+1), bec_col(1,nrcx+1), nkbx, nrcx, descla(2) )
<          END IF
<       END IF
< 
382,384c349,355
<                      IF( descla( iss )%active_node > 0 ) THEN
<                         DO i = 1, descla( iss )%nc
<                            CALL daxpy( na(is), qqf, bec_col(jnl+1,i+(iss-1)*nrcx),1, qbecp(inl+1,i,iss), 1 )
---
>                      istart = iupdwn(iss)
>                      nc     = descla( nlac_ , iss )
>                      ic     = descla( ilac_ , iss ) + istart - 1
>                      IF( la_proc ) THEN
>                         DO i = 1, nc
>                            icc=i+ic-1
>                            CALL daxpy( na(is), qqf, becp (jnl+1,icc),1, qbecp(inl+1,i,iss), 1 )
393,402c364
<       IF( nvb > 0 ) DEALLOCATE( bec_col )
<       !
<       ! Expand cp and phi to contain all electronic band
<       !
<       CALL c_bgrp_expand( cp_bgrp )
<       CALL c_bgrp_expand( phi_bgrp )
<       !
<       ALLOCATE( xloc( nx0, nx0 ), STAT = info )
<       IF( info /= 0 ) &
<          CALL errore( ' ortho ', ' allocating xloc ', ABS( info ) )
---
>       ALLOCATE( xloc( nx0, nx0 ) )
409c371,374
<          IF( descla( iss )%active_node > 0 ) xloc = x0(:,:,iss) * ccc
---
>          nss    = nupdwn(iss)
>          istart = iupdwn(iss)
> 
>          IF( la_proc ) xloc = x0(:,:,iss) * ccc
411,413c376,377
<          CALL ortho_gamma( 0, cp_bgrp, ngwx, phi_bgrp, becp_dist(:,(iss-1)*nrcx+1:iss*nrcx), qbecp(:,:,iss), nkbx, &
<                            bephi(:,((iss-1)*nrcx+1):iss*nrcx), &
<                            qbephi(:,:,iss), xloc, nx0, descla(iss), diff, iter, nbsp, nupdwn(iss), iupdwn(iss) )
---
>          CALL ortho_gamma( 0, cp, ngwx, phi, becp, qbecp(:,:,iss), nkbx, bephi(:,((iss-1)*nlax+1):iss*nlax), &
>                            qbephi(:,:,iss), xloc, nx0, descla(:,iss), diff, iter, nbsp, nss, istart )
420c384
<          IF( iverbosity > 2 ) THEN
---
>          IF( iprsta > 2 ) THEN
424c388
<          IF( descla( iss )%active_node > 0 ) x0( :, :, iss ) = xloc / ccc
---
>          IF( la_proc ) x0( :, :, iss ) = xloc / ccc
428c392
<       IF( force_pairing ) cp_bgrp(:, iupdwn(2):iupdwn(2)+nupdwn(2)-1 ) = cp_bgrp(:,1:nupdwn(2))
---
>       IF( force_pairing ) cp(:, iupdwn(2):iupdwn(2)+nupdwn(2)-1 ) = cp(:,1:nupdwn(2))
433,437d396
<       DEALLOCATE( becp_dist )
<       !
<       ! pack cp so that it contains only the bands in the band subgroup
<       !
<       CALL c_bgrp_pack( cp_bgrp )
445c404
<    END SUBROUTINE ortho_x
---
>    END SUBROUTINE ortho_cp
Only in ../../../ffn2_tsvdw_master/CPV: ortho.F90
Only in ../../../ffn2_tsvdw_master/CPV: orthogonalize_base.mod
Only in ../../../ffn2_tsvdw_master/CPV: ortho.o
Only in ../../../ffn2_tsvdw_master/CPV: path_routines.f90
Only in ../../../ffn2_tsvdw_master/CPV: path_routines.F90
Only in ../../../ffn2_tsvdw_master/CPV: path_routines.mod
Only in ../../../ffn2_tsvdw_master/CPV: path_routines.o
diff ./phasefactor.f90 ../../../ffn2_tsvdw_master/CPV/phasefactor.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
11,56d10
<    subroutine phfac_x( tau0, ei1, ei2, ei3, eigr)
< !=----------------------------------------------------------------------------=!
<       !
<       !  this subroutine generates the complex matrices ei1, ei2, and ei3
<       !  used to compute the structure factor and forces on atoms :
<       !     ei1(n1,ia,is) = exp(-i*n1*b1*tau(ia,is)) -nr1<n1<nr1
<       !  and similar definitions for ei2 and ei3 ; and :
<       !     eigr(n,ia,is) = ei1*ei2*ei3 = exp(-i g*tau(ia,is))
<       !  The value of n1,n2,n3 for a vector g is supplied by array mill
<       !  calculated in ggen .
<       !
<       use kinds,              only: DP
<       use control_flags,      only: iverbosity
<       use io_global,          only: stdout
<       use ions_base,          only: nsp, na, nat
<       use cell_base,          only: ainv, r_to_s
<       use fft_base,           only: dfftp
<       use gvect, only: mill
<       use gvecw,              only: ngw
<       use cp_interfaces,      only: phfacs
< !
<       implicit none
<       real(DP) tau0(3,nat)
< !
<       complex(DP) ei1(-dfftp%nr1:dfftp%nr1,nat), ei2(-dfftp%nr2:dfftp%nr2,nat),      &
<      &                ei3(-dfftp%nr3:dfftp%nr3,nat), eigr(ngw,nat)
< !
<       integer :: i, isa
<       real(DP), allocatable :: taus(:,:)
< !
<       allocate( taus(3,nat) )
< !
<       if( iverbosity > 3 ) then
<          WRITE( stdout,*) ' phfac: tau0 '
<          WRITE( stdout,*) ( ( tau0(i,isa), i=1, 3 ), isa=1, nat )
<       endif
<       CALL r_to_s( tau0, taus, na, nsp, ainv )
<       CALL phfacs( ei1, ei2, ei3, eigr, mill, taus, dfftp%nr1, dfftp%nr2, dfftp%nr3, nat )
< 
<       deallocate( taus )
< !
<       return
<    end subroutine phfac_x
< 
< 
< !=----------------------------------------------------------------------------=!
157c111
<             CALL errore(' phfacs ',' inconsistent size for eigr ',ngw)
---
>             CALL errore(' phfacs ',' eigr inconsisten size ',ngw)
196c150
<       use fft_base,         only: dfftp
---
>       use grid_dimensions,  only: nr1, nr2, nr3
202,204c156,158
<       COMPLEX(DP) :: ei1( -dfftp%nr1 : dfftp%nr1, nat )
<       COMPLEX(DP) :: ei2( -dfftp%nr2 : dfftp%nr2, nat )
<       COMPLEX(DP) :: ei3( -dfftp%nr3 : dfftp%nr3, nat )
---
>       COMPLEX(DP) :: ei1( -nr1 : nr1, nat )
>       COMPLEX(DP) :: ei2( -nr2 : nr2, nat )
>       COMPLEX(DP) :: ei3( -nr3 : nr3, nat )
235a190,307
> 
> 
> !-----------------------------------------------------------------------
> 
>    subroutine phfac_x( tau0, ei1, ei2, ei3, eigr)
> 
>       !-----------------------------------------------------------------------
>       !  this subroutine generates the complex matrices ei1, ei2, and ei3
>       !  used to compute the structure factor and forces on atoms :
>       !     ei1(n1,ia,is) = exp(-i*n1*b1*tau(ia,is)) -nr1<n1<nr1
>       !  and similar definitions for ei2 and ei3 ; and :
>       !     eigr(n,ia,is) = ei1*ei2*ei3 = exp(-i g*tau(ia,is))
>       !  The value of n1,n2,n3 for a vector g is supplied by arrays mill_l
>       !  calculated in ggen .
>       !
>       use kinds,              only: DP
>       use control_flags,      only: iprsta
>       use io_global,          only: stdout
>       use ions_base,          only: nsp, na, nat
>       use cell_base,          only: ainv, r_to_s
>       use grid_dimensions,    only: nr1, nr2, nr3
>       use reciprocal_vectors, only: mill_l
>       use gvecw,              only: ngw
>       use cp_interfaces,      only: phfacs
> !
>       implicit none
>       real(DP) tau0(3,nat)
> !
>       complex(DP) ei1(-nr1:nr1,nat), ei2(-nr2:nr2,nat),      &
>      &                ei3(-nr3:nr3,nat), eigr(ngw,nat)
> !
>       integer :: i, isa
>       real(DP), allocatable :: taus(:,:)
> !
>       allocate( taus(3,nat) )
> !
>       if(iprsta.gt.3) then
>          WRITE( stdout,*) ' phfac: tau0 '
>          WRITE( stdout,*) ( ( tau0(i,isa), i=1, 3 ), isa=1, nat )
>       endif
>       CALL r_to_s( tau0, taus, na, nsp, ainv )
>       CALL phfacs( ei1, ei2, ei3, eigr, mill_l, taus, nr1, nr2, nr3, nat )
> 
>       deallocate( taus )
> !
>       return
>    end subroutine phfac_x
> 
> 
> !-----------------------------------------------------------------------
>       SUBROUTINE phbox( taub, eigrb, ainvb )
> !-----------------------------------------------------------------------
> !     calculates the phase factors for the g's of the little box
> !     eigrt=exp(-i*g*tau) .
> !     Uses the same logic for fast calculation as in phfac (see below)
> !        
>       USE kinds,         only: DP
>       use io_global,     only: stdout
>       use control_flags, only: iprsta
>       use ions_base,     only: nsp, na, nat
>       use gvecb,         only: ngb, mill_b
>       use cell_base,     only: r_to_s
>       use smallbox_grid_dimensions, only: nr1b, nr2b, nr3b
>       use cp_interfaces, only: phfacs
> !                 
>       IMPLICIT NONE    
>       REAL(DP)    :: taub(3,nat)
>       COMPLEX(DP) :: eigrb(ngb,nat)
>       REAL(DP)    :: ainvb(3,3)
> ! local           
>       integer :: i,j,k, is, ia, ig, isa
>       complex(8), allocatable:: ei1b(:,:), ei2b(:,:), ei3b(:,:)
>       real(8), allocatable :: taus(:,:)
> !
>       allocate(ei1b(-nr1b:nr1b,nat))
>       allocate(ei2b(-nr2b:nr2b,nat))
>       allocate(ei3b(-nr3b:nr3b,nat))
>       allocate( taus( 3, nat ) )
> !
>       if(iprsta.gt.3) then
>          WRITE( stdout,*) ' phbox: taub '
>          WRITE( stdout,*) ( (taub(i,isa), i=1, 3 ), isa=1, nat )
>       endif
>       CALL r_to_s( taub, taus, na, nsp, ainvb )
>       CALL phfacs( ei1b, ei2b, ei3b, eigrb, mill_b, taus, nr1b, nr2b, nr3b, nat )
> !
>       if(iprsta.gt.4) then
>          WRITE( stdout,*)
>          if(nsp.gt.1) then
>             isa = 0
>             do is=1,nsp
>                WRITE( stdout,'(33x,a,i4)') ' ei1b, ei2b, ei3b (is)',is
>                do ig=1,4
>                   WRITE( stdout,'(6f9.4)')                                    &
>      &                 ei1b(ig,1+isa),ei2b(ig,1+isa),ei3b(ig,1+isa)
>                end do
>                WRITE( stdout,*)
>                isa = isa + na(is)
>             end do
>          else
>             do ia=1,na(1)
>                WRITE( stdout,'(33x,a,i4)') ' ei1b, ei2b, ei3b (ia)',ia
>                do ig=1,4
>                   WRITE( stdout,'(6f9.4)')                                    &
>      &                 ei1b(ig,ia),ei2b(ig,ia),ei3b(ig,ia)
>                end do
>                WRITE( stdout,*)
>             end do
>          endif
>       endif
> !
>       deallocate(ei3b)
>       deallocate(ei2b)
>       deallocate(ei1b)
>       deallocate( taus )
> !
>       RETURN
>       END SUBROUTINE phbox
Only in ../../../ffn2_tsvdw_master/CPV: phasefactor.F90
Only in ../../../ffn2_tsvdw_master/CPV: phasefactor.o
Only in .: plugin_forces.f90
Only in .: plugin_initialization.f90
diff ./polarization.f90 ../../../ffn2_tsvdw_master/CPV/polarization.f90
24c24
<         REAL(DP) :: cost1, cost2, cost3, fac
---
>         REAL(DP) :: cost1, cost2, cost3, fac, bgm1( 3, 3 ), bg( 3, 3 )
83c83
<       USE mp_global,   ONLY: me_bgrp, nproc_bgrp, intra_bgrp_comm
---
>       USE mp_global,   ONLY: me_image, nproc_image, intra_image_comm
108c108
<       REAL(DP)    :: bg(3,3), bgm1(3,3), b1( 3 ), b2( 3 ), b3( 3 )
---
>       REAL(DP)    :: bg( 3, 3 ), b1( 3 ), b2( 3 ), b3( 3 )
120c120
<       me = me_bgrp + 1
---
>       me = me_image + 1
194c194
<           dest_indi(:,1), n_indi_rcv(1), n_indi_snd(1), icntix(1), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,1), n_indi_rcv(1), n_indi_snd(1), icntix(1), me_image, nproc_image, intra_image_comm )
197c197
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
201c201
<           dest_indi(:,3), n_indi_rcv(3), n_indi_snd(3), icntix(3), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,3), n_indi_rcv(3), n_indi_snd(3), icntix(3), me_image, nproc_image, intra_image_comm )
204c204
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
208c208
<           dest_indi(:,2), n_indi_rcv(2), n_indi_snd(2), icntix(2), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,2), n_indi_rcv(2), n_indi_snd(2), icntix(2), me_image, nproc_image, intra_image_comm )
211c211
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
238c238
<           dest_indi(:,4), n_indi_rcv(4), n_indi_snd(4), icntix(4), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,4), n_indi_rcv(4), n_indi_snd(4), icntix(4), me_image, nproc_image, intra_image_comm )
242c242
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
246c246
<           dest_indi(:,6), n_indi_rcv(6), n_indi_snd(6), icntix(6), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,6), n_indi_rcv(6), n_indi_snd(6), icntix(6), me_image, nproc_image, intra_image_comm )
249c249
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
253c253
<           dest_indi(:,5), n_indi_rcv(5), n_indi_snd(5), icntix(5), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,5), n_indi_rcv(5), n_indi_snd(5), icntix(5), me_image, nproc_image, intra_image_comm )
256c256
<           call mp_sum( ztmp, intra_bgrp_comm ) 
---
>           call mp_sum( ztmp, intra_image_comm ) 
283c283
<           dest_indi(:,7), n_indi_rcv(7), n_indi_snd(7), icntix(7), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,7), n_indi_rcv(7), n_indi_snd(7), icntix(7), me_image, nproc_image, intra_image_comm )
287c287
<           call mp_sum( ztmp, intra_bgrp_comm ) 
---
>           call mp_sum( ztmp, intra_image_comm ) 
291c291
<           dest_indi(:,8), n_indi_rcv(8), n_indi_snd(8), icntix(8), me_bgrp, nproc_bgrp, intra_bgrp_comm )
---
>           dest_indi(:,8), n_indi_rcv(8), n_indi_snd(8), icntix(8), me_image, nproc_image, intra_image_comm )
294c294
<           call mp_sum( ztmp, intra_bgrp_comm )
---
>           call mp_sum( ztmp, intra_image_comm )
Only in ../../../ffn2_tsvdw_master/CPV: polarization.F90
Only in ../../../ffn2_tsvdw_master/CPV: polarization.mod
Only in ../../../ffn2_tsvdw_master/CPV: polarization.o
diff ./potentials.f90 ../../../ffn2_tsvdw_master/CPV/potentials.f90
28a29,124
>      
> 
>    SUBROUTINE vofmean_x( sfac, rhops, rhoeg )
> 
>         USE kinds,              ONLY: DP
>         USE control_flags,      ONLY: vhrmin, vhrmax, vhasse
>         USE cp_main_variables,  ONLY: nfi
>         USE constants,          ONLY: fpi
>         USE cell_base,          ONLY: tpiba2, tpiba
>         USE mp,                 ONLY: mp_sum
>         USE mp_global,          ONLY: nproc_image, me_image, intra_image_comm
>         USE io_global,          ONLY: ionode
>         USE io_files,           ONLY: opt_unit
>         USE gvecp,              ONLY: ngm
>         USE reciprocal_vectors, ONLY: gstart, gx, g
> 
>         IMPLICIT NONE
> 
>         REAL(DP),    INTENT(IN)   :: RHOPS(:,:)
>         COMPLEX(DP), INTENT(IN)   :: RHOEG(:)
>         COMPLEX(DP), INTENT(IN)   :: sfac(:,:)
> 
>         COMPLEX(DP) :: fpi_tpiba2, rp, vcg
>         REAL(DP)    :: gxt, dr, r
>         REAL(DP), ALLOCATABLE :: vrmean(:) 
>         
>         INTEGER :: ig, is, iasse, ipiano1, ipiano2
>         INTEGER :: ir
>         INTEGER :: vhnr = 640
> 
>         IF( (vhasse.NE.'X') .AND. (vhasse.NE.'Y') .AND. (vhasse.NE.'Z') ) THEN
>           CALL errore( ' vofmean ', ' wrong asse ',0)
>         END IF 
>         IF( vhrmax .LE. vhrmin ) THEN
>           CALL errore( ' vofmean ', ' wrong rmax or rmin ',0)
>         END IF 
>         IF( vhnr .LE. 0 ) THEN
>           CALL errore( ' vofmean ', ' wrong nr ',0)
>         END IF 
> 
>         fpi_tpiba2 = CMPLX(FPI/TPIBA2,0.0d0,kind=DP)
>         dr = ( vhrmax - vhrmin ) / vhnr
> 
>         ALLOCATE(vrmean(vhnr))
> 
>         IF( vhasse.EQ.'X' ) THEN
>           iasse = 1
>           ipiano1 = 2
>           ipiano2 = 3
>         ELSE IF(vhasse.EQ.'Y') THEN
>           iasse = 2
>           ipiano1 = 1
>           ipiano2 = 3
>         ELSE
>           iasse = 3
>           ipiano1 = 1
>           ipiano2 = 2
>         END IF
> 
>         DO ir = 1, vhnr
>           vrmean(ir) = 0.0d0
>           r = vhrmin + (ir-1)*dr
>           DO ig = gstart, ngm
>             rp   = (0.D0,0.D0)
>             DO is = 1, SIZE( sfac, 2 )
>               rp = rp + sfac( ig, is ) * rhops( ig, is )
>             END DO
>             IF((gx(ipiano1,IG).EQ.0.d0).AND. &
>                (gx(ipiano2,IG).EQ.0.d0))THEN
>               vcg       = fpi_tpiba2 * (rhoeg(ig) + rp) / g(ig)
>               gxt       = gx(iasse, ig) * tpiba
>               vrmean(ir) = vrmean(ir) + DBLE(vcg)  * COS(gxt*r) 
>               vrmean(ir) = vrmean(ir) - AIMAG(vcg) * SIN(gxt*r)
>             END IF
>           END DO
>           vrmean(ir) = 2.0d0 * vrmean(ir)
>         END DO
>         CALL mp_sum( vrmean, intra_image_comm )
> 
> 
>         IF(ionode) THEN
>           OPEN( unit = opt_unit, file = 'Vh_mean.out', position = 'append' )
>           WRITE(opt_unit,*) nfi
>           DO ir = 1, vhnr
>             r = vhrmin + (ir-1)*dr
>             WRITE(opt_unit,100) r, vrmean(ir)
>           END DO
>           CLOSE( unit = opt_unit )
>  100      FORMAT(2X,F14.8,F14.8)
>         END IF
>         
>         DEALLOCATE(vrmean)
> 
>         RETURN
>       END SUBROUTINE vofmean_x
> 
35c131
<       USE mp_global,       ONLY: me_bgrp
---
>       USE mp_global,       ONLY: me_image
37,38c133,134
<       USE fft_interfaces,  ONLY: fwfft
<       USE gvect,           ONLY: ngm
---
>       USE cp_interfaces,   ONLY: fwfft
>       USE gvecp,           ONLY: ngm
40a137
>       use grid_dimensions, only: nr1, nr2, nr3, nr1l, nr2l, nr3l, nnrx
56c153
<       INTEGER   :: ir1, ir2, ir3, nr3l
---
>       INTEGER   :: ir1, ir2, ir3
61c158
<       DO k = 1, me_bgrp
---
>       DO k = 1, me_image
64d160
<       nr3l = dfftp%npl
66c162
<       ALLOCATE( grr( dfftp%nnr ) )
---
>       ALLOCATE( grr( nnrx ) )
75,76c171,172
<       fact  = omega / ( dfftp%nr1 * dfftp%nr2 * dfftp%nr3 )
<       IF( MOD(dfftp%nr1 * dfftp%nr2 * dfftp%nr3, 2) /= 0 ) fact = -fact
---
>       fact  = omega / ( nr1 * nr2 * nr3 )
>       IF( MOD(nr1 * nr2 * nr3, 2) /= 0 ) fact = -fact
79,83c175,179
<         s(3) = DBLE ( (k-1) + (ir3 - 1) ) / dfftp%nr3 - 0.5d0
<         DO j = 1, dfftp%nr2
<           s(2) = DBLE ( (j-1) + (ir2 - 1) ) / dfftp%nr2 - 0.5d0
<           DO i = 1, dfftp%nr1
<             s(1) = DBLE ( (i-1) + (ir1 - 1) ) / dfftp%nr1 - 0.5d0
---
>         s(3) = DBLE ( (k-1) + (ir3 - 1) ) / nr3 - 0.5d0
>         DO j = 1, nr2l
>           s(2) = DBLE ( (j-1) + (ir2 - 1) ) / nr2 - 0.5d0
>           DO i = 1, nr1l
>             s(1) = DBLE ( (i-1) + (ir1 - 1) ) / nr1 - 0.5d0
133,135c229,231
<       USE gvect,              ONLY: ngm
<       USE gvect, ONLY: gstart
<       USE mp_global,          ONLY: intra_bgrp_comm
---
>       USE gvecp,              ONLY: ngm
>       USE reciprocal_vectors, ONLY: gstart, gx, g
>       USE mp_global,          ONLY: intra_image_comm
183c279
<       CALL mp_sum( eps, intra_bgrp_comm )
---
>       CALL mp_sum( eps, intra_image_comm )
212c308
<       USE gvect, ONLY: gstart, gg
---
>       USE reciprocal_vectors, ONLY: gstart, g
214,215c310,311
<       USE gvect,              ONLY: ngm
<       USE mp_global,          ONLY: intra_bgrp_comm
---
>       USE gvecp,              ONLY: ngm
>       USE mp_global,          ONLY: intra_image_comm
256c352
<           fpibg     = fpi / ( gg(ig) * tpiba2 ) + screen_coul(ig)
---
>           fpibg     = fpi / ( g(ig) * tpiba2 ) + screen_coul(ig)
258c354
<           fpibg     = fpi / ( gg(ig) * tpiba2 )
---
>           fpibg     = fpi / ( g(ig) * tpiba2 )
292,294c388,390
<       CALL mp_sum(eh  , intra_bgrp_comm)
<       CALL mp_sum(ehte, intra_bgrp_comm)
<       CALL mp_sum(ehti, intra_bgrp_comm)
---
>       CALL mp_sum(eh  , intra_image_comm)
>       CALL mp_sum(ehte, intra_image_comm)
>       CALL mp_sum(ehti, intra_image_comm)
323c419,420
<       USE gvect, ONLY: mill, gstart, g, gg
---
>       USE grid_dimensions,    ONLY: nr1, nr2, nr3
>       USE reciprocal_vectors, ONLY: mill_l, gstart, gx, g
325,327c422,423
<       USE gvect,              ONLY: ngm
<       USE gvecs,              ONLY: ngms
<       USE fft_base,           ONLY: dfftp
---
>       USE gvecp,              ONLY: ngm
>       USE gvecs,              ONLY: ngs
338,340c434,436
<       COMPLEX(DP) :: ei1(-dfftp%nr1:dfftp%nr1,nat)
<       COMPLEX(DP) :: ei2(-dfftp%nr2:dfftp%nr2,nat)
<       COMPLEX(DP) :: ei3(-dfftp%nr3:dfftp%nr3,nat)
---
>       COMPLEX(DP) :: ei1(-nr1:nr1,nat)
>       COMPLEX(DP) :: ei2(-nr2:nr2,nat)
>       COMPLEX(DP) :: ei3(-nr3:nr3,nat)
358c454
<       DO ig = gstart, ngms 
---
>       DO ig = gstart, ngs 
369c465
<           FPIBG     = fpi / ( gg(ig) * tpiba2 ) + screen_coul(ig)
---
>           FPIBG     = fpi / ( g(ig) * tpiba2 ) + screen_coul(ig)
371c467
<           FPIBG     = fpi / ( gg(ig) * tpiba2 )
---
>           FPIBG     = fpi / ( g(ig) * tpiba2 )
374,379c470,475
<         ig1  = mill(1,IG)
<         ig2  = mill(2,IG)
<         ig3  = mill(3,IG)
<         GXC  = CMPLX(0.D0,g(1,IG),kind=DP)
<         GYC  = CMPLX(0.D0,g(2,IG),kind=DP)
<         GZC  = CMPLX(0.D0,g(3,IG),kind=DP)
---
>         ig1  = mill_l(1,IG)
>         ig2  = mill_l(2,IG)
>         ig3  = mill_l(3,IG)
>         GXC  = CMPLX(0.D0,gx(1,IG),kind=DP)
>         GYC  = CMPLX(0.D0,gx(2,IG),kind=DP)
>         GZC  = CMPLX(0.D0,gx(3,IG),kind=DP)
414c510
<       USE mp_global,   ONLY : nproc_bgrp, me_bgrp, intra_bgrp_comm
---
>       USE mp_global,   ONLY : nproc_image, me_image, intra_image_comm
432c528,529
<       INTEGER, EXTERNAL :: ldim_block, gind_block
---
>       INTEGER :: ldim_block, gind_block
>       EXTERNAL ldim_block, gind_block
459c556
<       me = me_bgrp + 1
---
>       me = me_image + 1
534,535c631,632
<       NA_LOC = ldim_block( npt, nproc_bgrp, me_bgrp)
<       IA_S   = gind_block( 1, npt, nproc_bgrp, me_bgrp )
---
>       NA_LOC = ldim_block( npt, nproc_image, me_image)
>       IA_S   = gind_block( 1, npt, nproc_image, me_image )
619c716
<       CALL mp_sum(esr, intra_bgrp_comm)
---
>       CALL mp_sum(esr, intra_image_comm)
642,644c739,741
<       USE cell_base,          ONLY: tpiba2
<       USE gvect,              ONLY: ngm
<       USE gvect, ONLY: gstart, gg
---
>       USE cell_base,          ONLY: tpiba2, boxdimensions
>       USE gvecp,              ONLY: ngm
>       USE reciprocal_vectors, ONLY: gstart, g
646c743
<       USE mp_global,          ONLY: intra_bgrp_comm
---
>       USE mp_global,          ONLY: intra_image_comm
672c769
<         CALL cluster_bc( screen_coul, gg, omega, hmat )
---
>         CALL cluster_bc( screen_coul, g, omega, hmat )
684c781
<           FPIBG     = fpi / ( gg(ig) * tpiba2 ) + screen_coul(ig)
---
>           FPIBG     = fpi / ( g(ig) * tpiba2 ) + screen_coul(ig)
686c783
<           FPIBG     = fpi / ( gg(ig) * tpiba2 )
---
>           FPIBG     = fpi / ( g(ig) * tpiba2 )
716c813
<       CALL mp_sum( self_ehte, intra_bgrp_comm )
---
>       CALL mp_sum( self_ehte, intra_image_comm )
741,742c838,839
<       USE gvect, ONLY: gstart, gg
<       USE gvect, ONLY: ngm
---
>       USE reciprocal_vectors, ONLY: gstart, g
>       USE gvecp, ONLY: ngm
744c841,842
<       USE fft_interfaces, ONLY: fwfft, invfft
---
>       use grid_dimensions, only: nr1, nr2, nr3, nr1l, nr2l, nr3l, nnrx
>       USE cp_interfaces, ONLY: fwfft, invfft
767d864
<       INTEGER      :: nr3l
774c871
<         CALL cluster_bc( screen_coul, gg, ht%deth, ht%hmat )
---
>         CALL cluster_bc( screen_coul, g, ht%deth, ht%hmat )
777c874
<       nr3l = dfftp%npl
---
> 
780,781c877,878
<       ALLOCATE( density( dfftp%nnr ) )
<       ALLOCATE( psi( dfftp%nnr ) )
---
>       ALLOCATE( density( nnrx ) )
>       ALLOCATE( psi( nnrx ) )
813c910
<             work  = dfftp%nr1
---
>             work  = nr1l
819c916
<             IF ( Xmax > dfftp%nr1 ) Xmax = dfftp%nr1
---
>             IF ( Xmax > nr1l ) Xmax = nr1l
822c919
<             work  = dfftp%nr2
---
>             work  = nr2l
828c925
<             IF ( Ymax > dfftp%nr2 ) Ymax = dfftp%nr2
---
>             IF ( Ymax > nr2l ) Ymax = nr2l
860c957
<                 FPIBG     = fpi / ( gg(ig) * tpiba2 ) + screen_coul(ig)
---
>                 FPIBG     = fpi / ( g(ig) * tpiba2 ) + screen_coul(ig)
862c959
<                 FPIBG     = fpi / ( gg(ig) * tpiba2 )
---
>                 FPIBG     = fpi / ( g(ig) * tpiba2 )
Only in ../../../ffn2_tsvdw_master/CPV: potentials.F90
Only in ../../../ffn2_tsvdw_master/CPV: potentials.o
Only in ../../../ffn2_tsvdw_master/CPV: pres_ai_mod.F90
Only in ../../../ffn2_tsvdw_master/CPV: pres_ai_mod.mod
Only in ../../../ffn2_tsvdw_master/CPV: pres_ai_mod.o
Only in .: printout_base.f90
diff ./print_out.f90 ../../../ffn2_tsvdw_master/CPV/print_out.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 FPMD-CPV groups
14,15c14
<        vnhh, xnhh0, vnhp, xnhp0, atot, ekin, epot, print_forces, print_stress, &
<        tstdout)
---
>        vnhh, xnhh0, vnhp, xnhp0, atot, ekin, epot, print_forces, print_stress )
20,21c19,20
<       USE control_flags,     ONLY : iprint, textfor, do_makov_payne
<       USE energies,          ONLY : print_energies, dft_energy_type
---
>       USE control_flags,     ONLY : iprint, textfor, iprsta, do_makov_payne, lwfpbe0, lwfpbe0nscf  ! Lingzhu Kong
>       USE energies,          ONLY : print_energies, dft_energy_type, exx
24,26c23,25
<       USE constants,         ONLY : au_gpa, bohr_radius_cm, amu_au, &
<                                     BOHR_RADIUS_ANGS, pi
<       USE ions_base,         ONLY : na, nsp, nat, ind_bck, atm, ityp, amass, cdmi, &
---
>       USE constants,         ONLY : au_gpa, amu_si, bohr_radius_cm, &
>                                     amu_au, BOHR_RADIUS_ANGS, pi
>       USE ions_base,         ONLY : na, nsp, nat, ind_bck, atm, ityp, pmass, cdmi, &
35a35
> 
42,43c42,46
<       USE control_flags,     ONLY : lwfpbe0, lwfpbe0nscf  ! Lingzhu Kong
<       USE energies,          ONLY : exx  ! Lingzhu Kong
---
>       !========================================================================
>       !Charles Swartz
>       USE input_parameters,  ONLY : ts_vdw  
>       USE tsvdw_module,      ONLY : EtsvdW  
>       !========================================================================
61,63c64,65
<       LOGICAL, INTENT(IN) :: print_forces, print_stress, tstdout
<    
<    !
---
>       LOGICAL, INTENT(IN) :: print_forces, print_stress
>       !
70,71c72,73
<       REAL(DP), ALLOCATABLE :: tauw(:, :)
<       LOGICAL  :: tsic, tfile
---
>       REAL(DP),         ALLOCATABLE :: tauw( :, : )
>       LOGICAL  :: tsic, tfile, tstdout
78c80
<      
---
>       tstdout = ( MOD( nfi, iprint_stdout ) == 0 )
139c141
<               totalmass = totalmass + amass(is) * na(is)
---
>               totalmass = totalmass + pmass(is) * na(is) / amu_au
147c149
<             CALL ions_cofmass( tau0, amass, na, nsp, cdm0 )
---
>             CALL ions_cofmass( tau0, pmass, na, nsp, cdm0 )
240c242,250
<             IF( tfile ) WRITE( 33, 2948 ) nfi, ekinc, temphc, tempp, etot, enthal, &
---
> !==============================================================================================
> !Jia Chen
> !        
>              IF (tfile) then
>                  IF(lwfpbe0 .or. lwfpbe0nscf)THEN
>                      WRITE( 33, 2948 ) nfi, ekinc, temphc, tempp, etot-exx*0.25, enthal, &
>                                           econs, econt, volume, out_press, tps
>                  ELSE
>                      WRITE( 33, 2948 ) nfi, ekinc, temphc, tempp, etot, enthal, &
241a252,255
>                  END IF
>             END IF
> !==================================================================================================
> !
261,262c275,278
< !======================================================
< !Lingzhu Kong
---
> !==============================================================================
> !Lingzhu Kong/Charles Swartz
> 
> !        WRITE( stdout, 1947 )
264c280,286
<            WRITE( stdout, 19470 )
---
>             IF(ts_vdw) THEN
>                WRITE( stdout, 19472 )
>             ELSE
>                WRITE( stdout, 19470)
>             ENDIF
>          ELSEIF (ts_vdw) THEN
>                WRITE( stdout, 19471)
266,268c288,292
<           WRITE( stdout, 1947)
<          END IF
< !======================================================
---
>             WRITE( stdout, 1947)
>          END IF                           
> 
> !==============================================================================
> 
288,289c312,316
< !===================================================================
< !Lingzhu Kong
---
> !============================================================================== 
> !Lingzhu Kong/Charles Swartz
> 
> !        WRITE( stdout, 1948 ) nfi, ekinc, temphc, tempp, etot, enthal, econs, &
> !                           econt, vnhh(3,3), xnhh0(3,3), vnhp(1),  xnhp0(1)
291,293c318,337
<             WRITE( stdout, 19480 ) nfi, ekinc, temphc, tempp, -exx*0.25, &
<                                   etot-exx*0.25, enthal, econs, econt,   &
<                                   vnhh(3,3), xnhh0(3,3), vnhp(1),  xnhp0(1)
---
>             !
>             IF(ts_vdw) THEN
>                !
>                WRITE( stdout, 19482) nfi,ekinc,temphc,tempp,(-exx*0.25),(etot-exx*0.25), &
>                                       enthal,econs,econt,vnhh(3,3),xnhh0(3,3),vnhp(1),   &
>                                       xnhp0(1),EtsvdW
>                !
>             ELSE
>                !
>                WRITE( stdout, 19480 ) nfi, ekinc, temphc, tempp, (-exx*0.25), (etot-exx*0.25),  &
>                                        enthal, econs, econt, vnhh(3,3), xnhh0(3,3), vnhp(1),    &  
>                                        xnhp0(1)
>                !
>             ENDIF
>             !
>          ELSEIF (ts_vdw) THEN
>             !
>             WRITE ( stdout, 19481 ) nfi,ekinc,temphc,tempp,etot,enthal,econs, &
>                                      econt,vnhh(3,3),xnhh0(3,3),vnhp(1),xnhp0(1),EtsvdW 
>             !
295,296c339,342
<             WRITE( stdout, 1948 ) nfi, ekinc, temphc, tempp, etot, enthal, &
<                       econs, econt, vnhh(3,3), xnhh0(3,3), vnhp(1),  xnhp0(1)
---
>             !
>             WRITE( stdout, 1948 ) nfi, ekinc, temphc, tempp, etot, enthal, econs, &
>                                    econt, vnhh(3,3), xnhh0(3,3), vnhp(1),  xnhp0(1)
>             !
298c344,347
< !===================================================================
---
> 
> !==============================================================================
> 
> 
325,334c374,410
< 1947  FORMAT( 2X,'nfi',4X,'ekinc',2X,'temph',2X,'tempp',8X,'etot',6X,'enthal', &
<            & 7X,'econs',7X,'econt',4X,'vnhh',3X,'xnhh0',4X,'vnhp',3X,'xnhp0' )
< 1948  FORMAT( I5,1X,F8.5,1X,F6.1,1X,F6.1,4(1X,F11.5),4(1X,F7.4) )
< !===============================================================================
< !Lingzhu Kong
< 19470 FORMAT( 2X,'nfi',4X,'ekinc',2X,'temph',2X,'tempp',8X,'exx', 8X,'etot', &
<               6X,'enthal',7X,'econs',7X,'econt',4X,'vnhh',3X,'xnhh0',4X, &
<               'vnhp',3X,'xnhp0')
< 19480  FORMAT( I6,1X,F8.5,1X,F6.1,1X,F6.1,5(1X,F11.5),4(1X,F7.4) )
< !===============================================================================
---
> 
> !==============================================================================
> !Charles Swartz
> 
> !-------------
> !'Standard CP'
> 1947  FORMAT (3X, 'nfi', 5X, 'ekinc', 2X, 'temph', 2X, 'tempp', 9X, 'etot', 7X, &
>              & 'enthal', 8X, 'econs', 8X, 'econt', 4X, 'vnhh', 3X, 'xnhh0', 4X, &
>              & 'vnhp', 3X, 'xnhp0') 
> 1948  FORMAT ( I6, 1X, F9.6, 2(2X, F5.1), 4(2X, F11.5), 4(1X, F7.3) )
> !------------
> 
> !------------
> !cp-wf-pbe0 and pbe0-nscf
> 19470 FORMAT(3X, 'nfi', 5X, 'ekinc', 2X, 'temph', 2X, 'tempp', 9X, 'exx', 8X, 'etot',  &
>              & 6X, 'enthal', 7X, 'econs', 7X, 'econt', 3X, 'vnhh', 2X, 'xnhh0', 3X, &
>              & 'vnhp', 2X, 'xnhp0')
> 19480 FORMAT( I6, 1X, F9.6, 2(2X, F5.1), 5(1X, F11.5), 4(1X, F6.3) )
> !------------
> 
> !------------
> !ts_vdw
> 19471  FORMAT (3X, 'nfi', 5X, 'ekinc', 2X, 'temph', 2X, 'tempp', 9X, 'etot', 7X, &
>              & 'enthal', 8X, 'econs', 8X, 'econt', 4X, 'vnhh', 3X, 'xnhh0', 4X, &
>              & 'vnhp', 3X, 'xnhp0', 6X, 'evdw')
> 19481  FORMAT ( I6, 1X, F9.6, 2(2X, F5.1), 4(2X, F11.5), 4(1X, F7.3), 1X, F9.5 )
> !------------
> 
> !------------
> !cp-wf-pbe0, pbe0-nscf, ts_vdw
> 19472 FORMAT(3X, 'nfi', 5X, 'ekinc', 2X, 'temph', 2X, 'tempp', 9X, 'exx', 8X, 'etot',  &
>              & 6X, 'enthal', 7X, 'econs', 7X, 'econt', 3X, 'vnhh', 2X, 'xnhh0', 3X, &
>              & 'vnhp', 2X, 'xnhp0', 5X, 'evdw')
> 19482 FORMAT( I6, 1X, F9.6, 2(2X, F5.1), 5(1X, F11.5), 4(1X, F6.3) 1X, F8.4)
> !------------
> !==============================================================================
> 
341a418,419
> 
> 
441a520,560
> 
> 
> 
> 
> !=----------------------------------------------------------------------------=!
>    SUBROUTINE print_projwfc_x ( c0, lambda, eigr, vkb )
> !=----------------------------------------------------------------------------=!
>       USE kinds,            ONLY: DP
>       USE electrons_base,   ONLY: nspin, nbnd, nbsp, iupdwn, nupdwn
>       USE electrons_module, ONLY: ei
>       USE cp_interfaces,    ONLY: set_evtot, set_eitot
>       !
>       IMPLICIT NONE
>       !
>       COMPLEX(DP), INTENT(IN)  :: c0(:,:), eigr(:,:), vkb(:,:)
>       REAL(DP),    INTENT(IN)  :: lambda(:,:,:)
>       !
>       INTEGER  :: nupdwn_tot( 2 ), iupdwn_tot( 2 )
>       COMPLEX(DP), ALLOCATABLE :: ctmp(:,:)
>       REAL(DP),    ALLOCATABLE :: eitot(:,:)
>       !
>       nupdwn_tot = nupdwn
>       iupdwn_tot(1) = iupdwn(1)
>       iupdwn_tot(2) = nupdwn(1) + 1
>       !
>       ALLOCATE( eitot( nupdwn_tot(1), nspin ) )
>       !
>       CALL set_eitot( eitot )
>       !
>       ALLOCATE( ctmp( SIZE( c0, 1 ), nupdwn_tot(1) * nspin ) )
>       ! 
>       CALL set_evtot( c0, ctmp, lambda, iupdwn_tot, nupdwn_tot )
>       !
>       CALL projwfc( ctmp, SIZE(ctmp,2), eigr, vkb, nupdwn_tot(1), eitot(1,1)  )
>       !
>       DEALLOCATE( eitot )
>       DEALLOCATE( ctmp )
> 
>       RETURN
>    END SUBROUTINE
> 
Only in ../../../ffn2_tsvdw_master/CPV: print_out.F90
Only in ../../../ffn2_tsvdw_master/CPV: print_out.o
diff ./problem_size.f90 ../../../ffn2_tsvdw_master/CPV/problem_size.f90
22,24c22,23
<       use gvecw,              only: ngwx
<       use gvect,              only: ngmx
<       use smallbox_gvec,              only: ngb
---
>       use reciprocal_vectors, only: ngwx, ngmx, ngmt
>       use gvecb,              only: ngb
Only in ../../../ffn2_tsvdw_master/CPV: problem_size.F90
Only in ../../../ffn2_tsvdw_master/CPV: problem_size.mod
Only in ../../../ffn2_tsvdw_master/CPV: problem_size.o
diff ./pseudo_base.f90 ../../../ffn2_tsvdw_master/CPV/pseudo_base.f90
47c47
<         use control_flags, only: iverbosity
---
>         use control_flags, only: iprsta
68,70d67
< !$omp parallel default(none) private(ig,c,xg,fint,jl,djl,ir) &
< !$omp          shared(mesh,what,omegab,ngb,tpibab2,gb,r,rho_atc,rhocb,rab,drhocb)
< 
81d77
< !$omp do
98d93
< !$omp do
103d97
< !$omp do
107a102,105
> 
>         if(iprsta >= 4) &
>              WRITE( stdout,'(a,f12.8)') ' integrated core charge= ',omegab*rhocb(1)
>         
112,115d109
< !$omp end parallel
< 
<         if(iverbosity > 3) WRITE( stdout,'(a,f12.8)') &
<                            ' integrated core charge= ',omegab*rhocb(1)
218c212
<         allocate( vscr(mesh), figl(ngs) )
---
>         allocate( figl(ngs), f(mesh), vscr(mesh) )
220c214
<            allocate( dfigl(ngs) )
---
>            allocate( dfigl(ngs), df(mesh) )
246,252d239
< !$omp parallel default(none) private( ig, xg, ir, f, df ) &
< !$omp          shared( irmax, r, rcmax, mesh, oldvan, rab, dv0, tpiba2, g, ngs, vscr, tpre, zv, figl, vps, dvps, omega, dfigl )
< 
<         allocate( f(mesh) )
<         if (tpre) then
<            allocate( df(mesh) )
<         end if
259,260d245
< 
< !$omp master
266d250
< !$omp end master
268,269d251
< 
< !$omp do
319d300
< !$omp do
341,347d321
< 
<         deallocate( f )
<         if (tpre) then
<            deallocate( df )
<         end if
< 
< !$omp end parallel
349c323
<         deallocate( figl, vscr )
---
>         deallocate( figl, f, vscr )
351c325
<            deallocate( dfigl )
---
>            deallocate( dfigl, df )
Only in ../../../ffn2_tsvdw_master/CPV: pseudo_base.F90
Only in ../../../ffn2_tsvdw_master/CPV: pseudo_base.mod
Only in ../../../ffn2_tsvdw_master/CPV: pseudo_base.o
Only in ../../../ffn2_tsvdw_master/CPV: pseudopotential.mod
Only in ../../../ffn2_tsvdw_master/CPV: pseudopot.F90
Only in ../../../ffn2_tsvdw_master/CPV: pseudopot.o
diff ./pseudopot_sub.f90 ../../../ffn2_tsvdw_master/CPV/pseudopot_sub.f90
57a58
>       use cvan,       only: ish      !
60,61c61
<       use uspp_param, only: ish,    &!
<                             upf,    &!
---
>       use uspp_param, only: upf,  &!
141c141,174
<    SUBROUTINE compute_xgtab_x( xgmin, xgmax )
---
>    LOGICAL FUNCTION chkpstab_x(hg, xgtabmax)
>       !
>       USE kinds,         ONLY: DP
>       USE mp,            ONLY: mp_max
>       USE io_global,     ONLY: stdout
>       USE mp_global,     ONLY: intra_image_comm
>       USE cell_base,     ONLY: tpiba
>       USE control_flags, ONLY: iprsta
>       !
>       IMPLICIT NONE
>       !
>       REAL(DP), INTENT(IN) :: hg(:)
>       REAL(DP), INTENT(IN) :: xgtabmax
>       REAL(DP) :: xgmax
> 
>       chkpstab_x = .FALSE.
>       !
>       xgmax = tpiba * SQRT( MAXVAL( hg ) )
>       CALL mp_max( xgmax, intra_image_comm )
>       !
>       IF( xgmax > xgtabmax ) THEN
>          chkpstab_x = .TRUE.
>          IF( iprsta > 2 ) &
>             WRITE( stdout, fmt='(  "CHKPSTAB: recalculate pseudopotential table" )' )
>       END IF
>       !
>       RETURN
>    END FUNCTION chkpstab_x
> 
> 
> !------------------------------------------------------------------------------!
> 
> 
>    SUBROUTINE compute_xgtab_x( xgmin, xgmax, xgtabmax )
146,147c179,180
<       USE mp_global,          ONLY : intra_bgrp_comm
<       USE gvect,              ONLY : gg
---
>       USE mp_global,          ONLY : intra_image_comm
>       USE reciprocal_vectors, ONLY : g
149c182
<       USE betax,              ONLY : mmx, refg
---
>       USE betax,              ONLY : mmx
153c186
<       REAL(DP), INTENT(OUT)  :: xgmax, xgmin
---
>       REAL(DP), INTENT(OUT)  :: xgmax, xgmin, xgtabmax
155c188
<       INTEGER   :: ig
---
>       INTEGER    :: ig, nval
158,161c191,192
<       IF( ALLOCATED( xgtab ) )  & 
<          DEALLOCATE( xgtab )
< 
<       ALLOCATE( xgtab( mmx ) )
---
>       IF( .NOT. ALLOCATED( xgtab ) )     ALLOCATE( xgtab( mmx ) )
>       nval = mmx
164,165c195,198
<       xgmax = SQRT( refg * mmx )
<       dxg   = (xgmax - xgmin) / DBLE( mmx - 1 )
---
>       xgmax = tpiba * SQRT( MAXVAL( g ) )
>       CALL mp_max(xgmax, intra_image_comm)
>       xgmax = xgmax + (xgmax-xgmin)
>       dxg   = (xgmax - xgmin) / DBLE(nval-1)
170a204
>       xgtabmax = xgtab( SIZE( xgtab ) )
190,191c224,225
<       use gvect, ONLY : gg, gstart
<       USE cp_interfaces,      ONLY : compute_xgtab
---
>       use reciprocal_vectors, ONLY : g, gstart
>       USE cp_interfaces,      ONLY : compute_xgtab, chkpstab
200a235
>       REAL(DP)  :: xgtabmax = 0.0d0
207c242,246
<       IF( ALLOCATED( vps_sp ) .AND. ALLOCATED( dvps_sp ) ) THEN
---
>       compute_tab = chkpstab( g, xgtabmax ) 
>       !
>       IF( ALLOCATED( vps_sp ) ) THEN
>          !
>          IF( .NOT. compute_tab ) return
218,222c257
<       IF(  ALLOCATED( vps_sp ) .OR. ALLOCATED( dvps_sp ) ) THEN
<          CALL errore( ' build_pstab_x ', ' inconsistent allocation ', 1 )
<       END IF
<       !
<       CALL compute_xgtab( xgmin, xgmax )
---
>       CALL compute_xgtab( xgmin, xgmax, xgtabmax )
268,269c303,304
<       USE gvect, ONLY : gg, gstart
<       USE cp_interfaces,      ONLY : compute_xgtab
---
>       USE reciprocal_vectors, ONLY : g, gstart
>       USE cp_interfaces,      ONLY : compute_xgtab, chkpstab
277a313
>       REAL(DP) :: xgtabmax = 0.0d0
284c320,324
<       IF( ALLOCATED( rhoc1_sp ) .AND. ALLOCATED( rhocp_sp ) ) THEN
---
>       compute_tab = chkpstab( g, xgtabmax )
>       !
>       IF( ALLOCATED( rhoc1_sp ) ) THEN
>          !
>          IF( .NOT. compute_tab ) return
295,299c335
<       IF(  ALLOCATED( rhoc1_sp ) .OR. ALLOCATED( rhocp_sp ) ) THEN
<          CALL errore( ' build_cctab_x ', ' inconsistent allocation ', 1 )
<       END IF
<       !
<       CALL compute_xgtab( xgmin, xgmax )
---
>       CALL compute_xgtab( xgmin, xgmax, xgtabmax )
351,352d386
<       CALL start_clock('betagx')
<       !
367a402,409
>          if ( tpre ) then
>             allocate( dfint( nr ) )
>             allocate( djl  ( nr ) )
>          end if
>          !
>          allocate( fint ( nr ) )
>          allocate( jl   ( nr ) )
>          !
372,383c414
< !$omp parallel default(none), private( dfint, djl, fint, jl, il, xg, ir ), &
< !$omp shared( tpre, nr, mmx, refg, l, is, rgrid, upf, indv, iv, betagx, dbetagx, oldvan )
<             if ( tpre ) then
<                allocate( dfint( nr ) )
<                allocate( djl  ( nr ) )
<             end if
<             !
<             allocate( fint ( nr ) )
<             allocate( jl   ( nr ) )
<             !
< !$omp do
<             interp_tab : do il = 1, mmx
---
>             do il = 1, mmx
418,430c449
<             end do interp_tab
< !$omp end do
<             !
<             deallocate(jl)
<             deallocate(fint)
<             !
<             if (tpre) then
<                deallocate(djl)
<                deallocate(dfint)
<             end if
<             !
< !$omp end parallel
<          !
---
>             end do
431a451,458
> !
>          deallocate(jl)
>          deallocate(fint)
>          !
>          if (tpre) then
>             deallocate(djl)
>             deallocate(dfint)
>          end if
434d460
<       CALL stop_clock('betagx')
454c480
<       USE uspp_param,    ONLY : upf, nh, nhm, nbetam, lmaxq, oldvan, ish, nvb
---
>       USE uspp_param,    ONLY : upf, nh, nhm, nbetam, lmaxq, oldvan
458c484,485
<       use smallbox_gvec,         only : ngb
---
>       USE cvan,          only : ish, nvb
>       use gvecb,         only : ngb
470,471d496
<       CALL start_clock('qradx')
< 
493a519,525
>          IF ( tpre ) THEN
>             ALLOCATE( djl  ( nr ) )
>             ALLOCATE( dfint( nr ) )
>          END IF
>          !
>          ALLOCATE( fint( nr ) )
>          ALLOCATE( jl  ( nr ) )
500,510c532
< !$omp parallel default(none), private( djl, dfint, fint, jl, il, iv, jv, ijv, xg, ir ), &
< !$omp shared( tpre, nr, mmx, refg, rgrid, l, upf, qrl, oldvan, qradx, dqradx, is )
<             IF ( tpre ) THEN
<                ALLOCATE( djl  ( nr ) )
<                ALLOCATE( dfint( nr ) )
<             END IF
<             !
<             ALLOCATE( fint( nr ) )
<             ALLOCATE( jl  ( nr ) )
< !$omp do
<             interp_tab : do il = 1, mmx
---
>             do il = 1, mmx
557,569c579
<             end do interp_tab
< !$omp end do
<             !
<             DEALLOCATE (  jl )
<             DEALLOCATE ( fint  )
<             !
<             if ( tpre ) then
<                DEALLOCATE(djl)
<                DEALLOCATE ( dfint )
<             end if
<             !
< !$omp end parallel
<          !
---
>             end do
571a582
>          DEALLOCATE (  jl )
572a584,590
>          DEALLOCATE ( fint  )
>          !
>          if ( tpre ) then
>             DEALLOCATE(djl)
>             DEALLOCATE ( dfint )
>          end if
>          !
583,584d600
<       CALL stop_clock('qradx')
< 
596c612
<       use uspp_param, only: lmaxkb, ish, nvb
---
>       use uspp_param, only: lmaxkb
601,602c617,619
<       use smallbox_gvec,      only: ngb
<       use control_flags, only: iprint, iverbosity
---
>       USE cvan,       only: ish, nvb
>       use gvecb,      only: ngb
>       use control_flags, only: iprint, iprsta
605,606c622,623
<       use qgb_mod,    only: qgb, dqgb
<       use smallbox_gvec,      only: gb, gxb
---
>       use qgb_mod,    only: qgb
>       use gvecb,      only: gb, gxb
607a625
>       use dqgb_mod,   only: dqgb
617c635
<       REAL(DP) :: xg, c, betagl, dbetagl
---
>       REAL(DP) :: xg, c, betagl, dbetagl, gg
748c766
<          if( iverbosity > 3 ) WRITE( stdout,*)  '  qradb  '
---
>          if( iprsta .ge. 4 ) WRITE( stdout,*)  '  qradb  '
859c877
<     LOGICAL FUNCTION check_tables_x( gmax )
---
>     LOGICAL FUNCTION check_tables_x( )
867c885
<       USE mp_global,          ONLY : intra_bgrp_comm
---
>       USE mp_global,          ONLY : intra_image_comm
871,872c889,890
<       USE smallbox_gvec,      ONLY : gb, ngb
<       USE gvect, ONLY : gg, ngm
---
>       USE gvecb,              ONLY : gb, ngb
>       USE reciprocal_vectors, ONLY : g
876,879c894
<       REAL(DP), INTENT(OUT) :: gmax
<       REAL(DP) :: g2, g2b
<       !
<       g2  = MAXVAL( gg( 1:ngm ) )
---
>       REAL(DP) :: gg, ggb, gmax
881c896,897
<       g2  = g2 * tpiba2 / refg
---
>       gg  = MAXVAL( g( 1:ngw ) )
>       gg  = gg * tpiba2 / refg
885,887c901,903
<          g2b = MAXVAL( gb( 1:ngb ) )
<          g2b = g2b * tpibab * tpibab / refg
<          gmax = MAX( g2, g2b )
---
>          ggb = MAXVAL( gb( 1:ngb ) )
>          ggb = ggb * tpibab * tpibab / refg
>          gmax = MAX( gg, ggb )
891c907
<          gmax = g2
---
>          gmax = gg
895c911
<       CALL mp_max( gmax, intra_bgrp_comm )
---
>       CALL mp_max( gmax, intra_image_comm )
898c914
<       IF( INT( gmax ) + 2 >= mmx ) check_tables_x = .TRUE.
---
>       IF( ( INT( gmax ) + 2 ) > mmx ) check_tables_x = .TRUE.
913c929
<       USE control_flags, only: iverbosity
---
>       USE control_flags, only: iprsta
918c934
<       USE gvect, only: gg, g, gstart
---
>       USE reciprocal_vectors, only: g, gx, gstart
920c936
<       USE uspp, only: qq, nhtolm, beta, dbeta
---
>       USE uspp, only: qq, nhtolm, beta
922a939
>       USE cdvan, ONLY : dbeta
929c946
<       REAL(DP) :: c, g2, betagl, dbetagl
---
>       REAL(DP) :: c, gg, betagl, dbetagl
933c950
<       CALL ylmr2 ( (lmaxkb+1)**2, ngw, g, gg, ylm)
---
>       CALL ylmr2 ( (lmaxkb+1)**2, ngw, gx, g, ylm)
940c957
<          if( iverbosity > 3 ) WRITE( stdout,*)  '  beta  '
---
>          if( iprsta .ge. 4 ) WRITE( stdout,*)  '  beta  '
945,947c962,964
<                g2 = gg( ig ) * tpiba * tpiba / refg
<                jj = int( g2 ) + 1
<                betagl = betagx( jj+1, iv, is ) * ( g2 - DBLE(jj-1) ) + betagx( jj, iv, is ) * ( DBLE(jj) - g2 )
---
>                gg = g( ig ) * tpiba * tpiba / refg
>                jj = int( gg ) + 1
>                betagl = betagx( jj+1, iv, is ) * ( gg - DBLE(jj-1) ) + betagx( jj, iv, is ) * ( DBLE(jj) - gg )
962c979
<          call dylmr2_( (lmaxkb+1)**2, ngw, g, gg, ainv, dylm )
---
>          call dylmr2_( (lmaxkb+1)**2, ngw, gx, g, ainv, dylm )
965c982
<             if( iverbosity > 3 ) WRITE( stdout,*)  '  dbeta  '
---
>             if( iprsta .ge. 4 ) WRITE( stdout,*)  '  dbeta  '
969,975c986,990
<                if( ngw > 0 ) then
<                   betagl = betagx(1,iv,is)
<                   do i=1,3
<                      do j=1,3
<                         dbeta( 1, iv, is, i, j ) = -0.5d0 * beta( 1, iv, is ) * ainv( j, i )    &
<      &                                             - c * dylm( 1, lp, i, j ) * betagl         ! SEGNO
<                      enddo
---
>                betagl = betagx(1,iv,is)
>                do i=1,3
>                   do j=1,3
>                      dbeta( 1, iv, is, i, j ) = -0.5d0 * beta( 1, iv, is ) * ainv( j, i )    &
>      &                                          - c * dylm( 1, lp, i, j ) * betagl         ! SEGNO
977c992
<                end if
---
>                enddo
979,984c994,999
<                   g2 = gg(ig) * tpiba * tpiba / refg
<                   jj=int(g2)+1
<                   betagl = betagx(  jj+1, iv, is ) * ( g2 - DBLE(jj-1) ) +         &
<      &                     betagx(  jj  , iv, is ) * ( DBLE(jj) - g2 )
<                   dbetagl= dbetagx( jj+1, iv, is ) * ( g2 - DBLE(jj-1) ) +        &
<      &                     dbetagx( jj  , iv, is ) * ( DBLE(jj) - g2 )
---
>                   gg = g(ig) * tpiba * tpiba / refg
>                   jj=int(gg)+1
>                   betagl = betagx(  jj+1, iv, is ) * ( gg - DBLE(jj-1) ) +         &
>      &                     betagx(  jj  , iv, is ) * ( DBLE(jj) - gg )
>                   dbetagl= dbetagx( jj+1, iv, is ) * ( gg - DBLE(jj-1) ) +        &
>      &                     dbetagx( jj  , iv, is ) * ( DBLE(jj) - gg )
990,991c1005,1006
<      &                    - c * ylm ( ig, lp )       *dbetagl * g(i,ig)/gg(ig)&
<      &                    * ( g( 1, ig ) * ainv( j, 1 ) + g( 2, ig ) * ainv( j, 2 ) + g( 3, ig ) * ainv( j, 3 ) )
---
>      &                    - c * ylm ( ig, lp )       * dbetagl * gx( i, ig ) / g( ig )         &
>      &                    * ( gx( 1, ig ) * ainv( j, 1 ) + gx( 2, ig ) * ainv( j, 2 ) + gx( 3, ig ) * ainv( j, 3 ) )
1017c1032
<       use control_flags, only: iprint, iverbosity
---
>       use control_flags, only: iprint, iprsta
1020a1036
>       use cvan, only: nvb
1024,1026c1040,1042
<       use uspp_param, only: upf, lmaxq, lmaxkb, nbetam, nh, nvb
<       use qgb_mod, only: qgb, dqgb
<       use smallbox_gvec, only: gb, gxb, ngb
---
>       use uspp_param, only: upf, lmaxq, lmaxkb, nbetam, nh
>       use qgb_mod, only: qgb
>       use gvecb, only: gb, gxb, ngb
1027a1044
>       use dqgb_mod, only: dqgb
1035,1036c1052,1053
<       real(dp), allocatable:: fint(:), jl(:), dqradb(:,:,:,:)
<       real(dp), allocatable:: ylmb(:,:), dylmb(:,:,:,:)
---
>       real(8), allocatable:: fint(:), jl(:), dqradb(:,:,:,:)
>       real(8), allocatable:: ylmb(:,:), dylmb(:,:,:,:)
1039,1040c1056,1057
<       complex(dp), allocatable:: dqgbs(:,:,:)
<       real(dp) xg, c, betagl, dbetagl, g2
---
>       complex(8), allocatable:: dqgbs(:,:,:)
>       real(8) xg, c, betagl, dbetagl, gg
1064c1081
<          if( iverbosity > 3 ) WRITE( stdout,*)  '  qradb  '
---
>          if( iprsta .ge. 4 ) WRITE( stdout,*)  '  qradb  '
1075,1076c1092,1093
<                   g2=gb(ig)*tpibab*tpibab/refg
<                   jj=int(g2)+1
---
>                   gg=gb(ig)*tpibab*tpibab/refg
>                   jj=int(gg)+1
1082,1083c1099,1100
<      &                       c*qradx(jj+1,ijv,l,is)*(g2-DBLE(jj-1))+  &
<      &                       c*qradx(jj,ijv,l,is)*(DBLE(jj)-g2)
---
>      &                       c*qradx(jj+1,ijv,l,is)*(gg-DBLE(jj-1))+  &
>      &                       c*qradx(jj,ijv,l,is)*(DBLE(jj)-gg)
1129,1130c1146,1147
<                         g2=gb(ig)*tpibab*tpibab/refg
<                         jj=int(g2)+1
---
>                         gg=gb(ig)*tpibab*tpibab/refg
>                         jj=int(gg)+1
1135,1136c1152,1153
<                                 dqradx(jj+1,ijv,l,is)*(g2-DBLE(jj-1)) +  &
<                                 dqradx(jj,ijv,l,is)*(DBLE(jj)-g2)
---
>                                 dqradx(jj+1,ijv,l,is)*(gg-DBLE(jj-1)) +  &
>                                 dqradx(jj,ijv,l,is)*(DBLE(jj)-gg)
1194c1211
<       USE control_flags, only : iverbosity
---
>       USE control_flags, only : iprsta
1201c1218
<       USE uspp,          only : qq, nhtolm, beta, nhtol, indv, dbeta
---
>       USE uspp,          only : qq, nhtolm, beta, nhtol, indv
1202a1220
>       USE cdvan,         ONLY : dbeta
1204c1222
<       USE gvect, only : gg, g, gstart
---
>       USE reciprocal_vectors, only : g, gx, gstart
1211c1229
<       REAL(DP) :: c, g2, betagl, dbetagl
---
>       REAL(DP) :: c, gg, betagl, dbetagl
1227c1245
<       CALL ylmr2 ( (lmaxkb+1)**2, ngw, g, gg, ylm)
---
>       CALL ylmr2 ( (lmaxkb+1)**2, ngw, gx, g, ylm)
1248c1266
<                xg = sqrt( gg( il ) * tpiba * tpiba )
---
>                xg = sqrt( g( il ) * tpiba * tpiba )
1298c1316
<          if( iverbosity > 3 ) WRITE( stdout,*)  '  beta  '
---
>          if( iprsta .ge. 4 ) WRITE( stdout,*)  '  beta  '
1315c1333
<          call dylmr2_( (lmaxkb+1)**2, ngw, g, gg, ainv, dylm )
---
>          call dylmr2_( (lmaxkb+1)**2, ngw, gx, g, ainv, dylm )
1318c1336
<             if( iverbosity > 3 ) WRITE( stdout,*)  '  dbeta  '
---
>             if( iprsta .ge. 4 ) WRITE( stdout,*)  '  dbeta  '
1335c1353
<      &                    -0.5d0*beta(ig,iv,is)*ainv(j,i)               &
---
>      &                    -0.5d0*beta(ig,iv,is)*ainv(j,i)                 &
1337,1340c1355,1358
<      &                    -c*ylm (ig,lp)*dbetagl*g(i,ig)/gg(ig)        &
<      &                    *(g(1,ig)*ainv(j,1)+                         &
<      &                      g(2,ig)*ainv(j,2)+                         &
<      &                      g(3,ig)*ainv(j,3))
---
>      &                    -c*ylm (ig,lp)*dbetagl*gx(i,ig)/g(ig)         &
>      &                    *(gx(1,ig)*ainv(j,1)+                         &
>      &                      gx(2,ig)*ainv(j,2)+                         &
>      &                      gx(3,ig)*ainv(j,3))
Only in ../../../ffn2_tsvdw_master/CPV: pseudopot_sub.F90
Only in ../../../ffn2_tsvdw_master/CPV: pseudopot_sub.o
Only in ../../../ffn2_tsvdw_master/CPV: qgb_mod.mod
diff ./qmatrixd.f90 ../../../ffn2_tsvdw_master/CPV/qmatrixd.f90
25a26
>   use cvan,  only: nvb, ish
27,28c28,30
<   use gvect, only: gstart
<   use uspp_param, only: nh, nhm, nvb, ish
---
>   use cell_base, only: a1, a2, a3
>   use reciprocal_vectors, only: gstart
>   use uspp_param, only: nh, nhm
32c34
<   use mp_global, only: intra_bgrp_comm, nproc_bgrp
---
>   use mp_global, only: intra_image_comm, nproc_image
99c101
< #ifdef __MPI
---
> #ifdef __PARA
103c105
<              allocate(sndbuf(n_g_missing_p(ipol),2,nproc_bgrp))
---
>              allocate(sndbuf(n_g_missing_p(ipol),2,nproc_image))
105c107
<              allocate(rcvbuf(n_g_missing_p(ipol),2,nproc_bgrp))
---
>              allocate(rcvbuf(n_g_missing_p(ipol),2,nproc_image))
107c109
<              do ip=1,nproc_bgrp
---
>              do ip=1,nproc_image
133c135
<              CALL mp_alltoall( sndbuf, rcvbuf, intra_bgrp_comm )
---
>              CALL mp_alltoall( sndbuf, rcvbuf, intra_image_comm )
136c138
<              do ip=1,nproc_bgrp
---
>              do ip=1,nproc_image
177c179
<           call mp_sum( sca, intra_bgrp_comm )
---
>           call mp_sum( sca, intra_image_comm )
Only in ../../../ffn2_tsvdw_master/CPV: qmatrixd.F90
Only in ../../../ffn2_tsvdw_master/CPV: qmatrixd.o
diff ./qqberry.f90 ../../../ffn2_tsvdw_master/CPV/qqberry.f90
17,18c17
<   use kinds,              only: dp
<   use uspp_param,         only: upf, lmaxq, nbetam, nh, nhm, oldvan, nvb
---
>   use uspp_param,         only: upf, lmaxq, nbetam, nh, nhm, oldvan
23c22
<   use gvect,              only: mill
---
>   use reciprocal_vectors, only: mill_l
25,27c24,28
<   use ions_base,          only: nas => nax, na, nsp
<   use cell_base,          only: at, alat
<   use gvect,              only: g, gg
---
>   use cvan,               only: nvb
>   use ions_base
>   use ions_base,          only: nas => nax
>   use cell_base,          only: a1, a2, a3
>   use reciprocal_vectors, only: ng0 => gstart, gx, g
29c30
<   use mp_global,          only: intra_bgrp_comm
---
>   use mp_global,          only: intra_image_comm
34,37c35,37
<   complex(dp) gqq(nhm,nhm,nas,nsp)
<   complex(dp) gqqm(nhm,nhm,nas,nsp)
<   real(dp) gmes
<   real(dp), external :: g_mes
---
>   complex(8) gqq(nhm,nhm,nas,nsp)
>   complex(8) gqqm(nhm,nhm,nas,nsp)
>   real(8) gmes
43,46c43,46
<   real(dp), allocatable:: fint(:),jl(:)
<   real(dp), allocatable:: qrl(:,:,:), qradb2(:,:,:,:) 
<   real(dp) c, xg
<   complex(dp) qgbs,sig
---
>   real(8), allocatable:: fint(:),jl(:)
>   real(8), allocatable:: qrl(:,:,:), qradb2(:,:,:,:) 
>   real(8) c, xg
>   complex(8) qgbs,sig
48c48
<   real(dp), allocatable:: ylm(:,:)
---
>   real(8), allocatable:: ylm(:,:)
60c60
<   CALL ylmr2( lmaxq*lmaxq, ngw, g, gg, ylm )
---
>   CALL ylmr2( lmaxq*lmaxq, ngw, gx, g, ylm )
75,76c75,86
<   gmes = g_mes ( ipol, at, alat )
< 
---
>   if(ipol.eq.1) then
>      gmes=a1(1)**2+a1(2)**2+a1(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.2) then
>      gmes=a2(1)**2+a2(2)**2+a2(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif
>   if(ipol.eq.3) then
>      gmes=a3(1)**2+a3(2)**2+a3(3)**2
>      gmes=2*pi/SQRT(gmes)
>   endif    
117c127
<         if(mill(1,ig).eq.1 .and. mill(2,ig).eq.0  .and. mill(3,ig).eq. 0) igi=ig
---
>         if(mill_l(1,ig).eq.1 .and. mill_l(2,ig).eq.0  .and. mill_l(3,ig).eq. 0) igi=ig
120c130
<         if(mill(1,ig).eq.0 .and. mill(2,ig).eq.1  .and. mill(3,ig).eq. 0) igi=ig
---
>         if(mill_l(1,ig).eq.0 .and. mill_l(2,ig).eq.1  .and. mill_l(3,ig).eq. 0) igi=ig
123c133
<         if(mill(1,ig).eq.0 .and. mill(2,ig).eq.0   .and. mill(3,ig).eq. 1) igi=ig
---
>         if(mill_l(1,ig).eq.0 .and. mill_l(2,ig).eq.0   .and. mill_l(3,ig).eq. 1) igi=ig
182,183c192,193
<   call mp_sum(gqq(:,:,:,:),intra_bgrp_comm)
<   call mp_sum(gqqm(:,:,:,:),intra_bgrp_comm)
---
>   call mp_sum(gqq(:,:,:,:),intra_image_comm)
>   call mp_sum(gqqm(:,:,:,:),intra_image_comm)
206c216
<   use kinds, only : dp
---
>   use cvan
209,210c219,220
<   use gvect, only: mill
<   use uspp_param, only: nh, nhm, nvb, ish
---
>   use reciprocal_vectors, only: mill_l
>   use uspp_param, only: nh, nhm
212c222
<   use mp_global, only: intra_bgrp_comm
---
>   use mp_global, only: intra_image_comm
217,220c227,230
<   complex(dp) eigr(ngw,nat)
<   complex(dp) gqq(nhm,nhm,nas,nsp)
<   complex(dp) gqqm(nhm,nhm,nas,nsp)
<   complex(dp) gqqm0(nhm,nhm,nas,nsp)
---
>   complex(8) eigr(ngw,nat)
>   complex(8) gqq(nhm,nhm,nas,nsp)
>   complex(8) gqqm(nhm,nhm,nas,nsp)
>   complex(8) gqqm0(nhm,nhm,nas,nsp)
241c251
<         if(mill(1,ig).eq.1 .and. mill(2,ig).eq.0  .and. mill(3,ig).eq. 0) igi=ig
---
>         if(mill_l(1,ig).eq.1 .and. mill_l(2,ig).eq.0  .and. mill_l(3,ig).eq. 0) igi=ig
244c254
<         if(mill(1,ig).eq.0 .and. mill(2,ig).eq.1  .and. mill(3,ig).eq. 0) igi=ig
---
>         if(mill_l(1,ig).eq.0 .and. mill_l(2,ig).eq.1  .and. mill_l(3,ig).eq. 0) igi=ig
247c257
<         if(mill(1,ig).eq.0 .and. mill(2,ig).eq.0  .and. mill(3,ig).eq. 1) igi=ig
---
>         if(mill_l(1,ig).eq.0 .and. mill_l(2,ig).eq.0  .and. mill_l(3,ig).eq. 1) igi=ig
268,269c278,279
<   call mp_sum(gqq(:,:,:,:),intra_bgrp_comm)
<   call mp_sum(gqqm(:,:,:,:),intra_bgrp_comm)
---
>   call mp_sum(gqq(:,:,:,:),intra_image_comm)
>   call mp_sum(gqqm(:,:,:,:),intra_image_comm)
Only in ../../../ffn2_tsvdw_master/CPV: qqberry.F90
Only in ../../../ffn2_tsvdw_master/CPV: qqberry.o
Only in ../../../ffn2_tsvdw_master/CPV: read_pseudo.f90
Only in ../../../ffn2_tsvdw_master/CPV: read_pseudo.F90
Only in ../../../ffn2_tsvdw_master/CPV: read_pseudo_module_fpmd.mod
Only in ../../../ffn2_tsvdw_master/CPV: read_pseudo.o
diff ./restart.f90 ../../../ffn2_tsvdw_master/CPV/restart.f90
12c12
<    SUBROUTINE writefile_x                                         &
---
>    SUBROUTINE writefile_cp                                         &
14c14
<      &       lambda,lambdam,descla,xnhe0,xnhem,vnhe,xnhp0,xnhpm,vnhp,nhpcl,nhpdim,ekincm,&
---
>      &       lambda,lambdam,xnhe0,xnhem,vnhe,xnhp0,xnhpm,vnhp,nhpcl,nhpdim,ekincm,&
22,23c22,23
<       USE cp_interfaces,    ONLY: set_evtot, set_eitot, c_bgrp_expand, c_bgrp_pack
<       USE electrons_base,   ONLY: nspin, nbnd, nbsp, iupdwn, nupdwn, nbspx
---
>       USE cp_interfaces,    ONLY: set_evtot, set_eitot
>       USE electrons_base,   ONLY: nspin, nbnd, nbsp, iupdwn, nupdwn
28,33c28,29
<       USE control_flags,    ONLY: tksw, ndw, io_level, twfcollect
<       USE xml_io_base,      ONLY: restart_dir, kpoint_dir
<       USE electrons_module, ONLY: collect_c
<       USE descriptors,      ONLY: la_descriptor
<       USE gvecw,            ONLY: ngw
< 
---
>       USE mp_global,        ONLY: root_image, intra_image_comm
>       USE control_flags,    ONLY: tksw, ndw
50d45
<       TYPE(la_descriptor), INTENT(IN) :: descla(:)
54a50
>       REAL(DP) :: htm1(3,3), omega
58a55
> 
68,70d64
<       CALL c_bgrp_expand( c0 )
<       CALL c_bgrp_expand( cm )
< 
88c82
<          CALL set_evtot( c0, ctot, lambda, descla, iupdwn_tot, nupdwn_tot )
---
>          CALL set_evtot( c0, ctot, lambda, iupdwn_tot, nupdwn_tot )
91a86,88
>       !  Sincronize lambdas, whose replicas could diverge on
>       !  different processors
>       !
94c91
<         CALL cp_writefile( ndw, .TRUE., nfi, tps, acc, nk, xk, wk,   &
---
>         CALL cp_writefile( ndw, tmp_dir, .TRUE., nfi, tps, acc, nk, xk, wk,   &
102c99
<         CALL cp_writefile( ndw, .TRUE., nfi, tps, acc, nk, xk, wk,  &
---
>         CALL cp_writefile( ndw, tmp_dir, .TRUE., nfi, tps, acc, nk, xk, wk,  &
113,115d109
<       !
<       CALL c_bgrp_pack( c0 )
<       CALL c_bgrp_pack( cm )
118c112
<       end subroutine writefile_x
---
>       end subroutine writefile_cp
121c115
<       subroutine readfile_x                                        &
---
>       subroutine readfile_cp                                        &
132,133c126,127
<       USE electrons_base, ONLY : nbnd, nbsp, nspin, nupdwn, iupdwn, keep_occ, nbspx
<       USE gvecw,          ONLY : ngw
---
>       USE electrons_base, ONLY : nbnd, nbsp, nspin, nupdwn, iupdwn, keep_occ
>       USE gvecw,          ONLY : ngw, ngwt
135c129
<       USE cp_restart,     ONLY : cp_readfile, cp_read_cell, cp_read_wfc
---
>       USE cp_restart,     ONLY : cp_readfile, cp_read_cell, cp_read_wfc, cp_read_wfc_Kong
140d133
<       USE cp_interfaces,  ONLY : c_bgrp_pack
162,163c155,157
<       REAL(DP) :: b1(3) , b2(3), b3(3)
< 
---
>       REAL(DP) :: htm1(3,3), b1(3) , b2(3), b3(3), omega
>         
>       LOGICAL::lopen
171,173c165
<       END IF
<  
<       IF ( flag == 0 ) THEN
---
>       ELSE IF ( flag == 0 ) THEN
177d168
<         CALL c_bgrp_pack( cm )
184c175
<          CALL cp_readfile( ndr, .TRUE., nfi, tps, acc, nk, xk, wk, &
---
>          CALL cp_readfile( ndr, tmp_dir, .TRUE., nfi, tps, acc, nk, xk, wk, &
190c181
<          CALL cp_readfile( ndr, .TRUE., nfi, tps, acc, nk, xk, wk, &
---
>          CALL cp_readfile( ndr, tmp_dir, .TRUE., nfi, tps, acc, nk, xk, wk, &
196c187
<       !
---
> 
215,217d205
<       CALL c_bgrp_pack( cm )
<       CALL c_bgrp_pack( c0 )
<       !
221c209
<       end subroutine readfile_x
---
>       end subroutine readfile_cp
247c235
<    SUBROUTINE set_evtot_x( c0, ctot, lambda, descla, iupdwn_tot, nupdwn_tot )
---
>    SUBROUTINE set_evtot_x( c0, ctot, lambda, iupdwn_tot, nupdwn_tot )
252,253c240,241
<       USE cp_interfaces,     ONLY: crot, collect_lambda
<       USE descriptors,       ONLY: la_descriptor
---
>       USE cp_interfaces,     ONLY: crot
>       USE cp_main_variables, ONLY: collect_lambda, descla
261d248
<       TYPE(la_descriptor), INTENT(IN) :: descla(:)
271c258
<       CALL collect_lambda( lambda_repl, lambda(:,:,1), descla(1) )
---
>       CALL collect_lambda( lambda_repl, lambda(:,:,1), descla(:,1) )
276c263
<          CALL collect_lambda( lambda_repl, lambda(:,:,2), descla(2) )
---
>          CALL collect_lambda( lambda_repl, lambda(:,:,2), descla(:,2) )
Only in ../../../ffn2_tsvdw_master/CPV: restart.F90
Only in ../../../ffn2_tsvdw_master/CPV: restart.o
diff ./restart_sub.f90 ../../../ffn2_tsvdw_master/CPV/restart_sub.f90
13c13
<                                      iverbosity, tsde, tzeroe, tzerop, nbeg, tranp, amprp, thdyn, &
---
>                                      iprsta, tsde, tzeroe, tzerop, nbeg, tranp, amprp, thdyn, &
15c15
<    USE wavefunctions_module,  ONLY : c0_bgrp, cm_bgrp
---
>    USE wavefunctions_module,  ONLY : c0, cm, phi => cp
17c17
<    USE electrons_base,        ONLY : nspin, iupdwn, nupdwn, f, nbsp, nbsp_bgrp
---
>    USE electrons_base,        ONLY : nspin, iupdwn, nupdwn, f, nbsp
19,20c19,20
<    USE cell_base,             ONLY : ainv, h, hold, deth, r_to_s, s_to_r, &
<                                      velh, at, alat
---
>    USE cell_base,             ONLY : ainv, h, hold, deth, r_to_s, s_to_r, boxdimensions, &
>                                      velh, a1, a2, a3
25c25,26
<    USE gvect,    ONLY : mill, eigts1, eigts2, eigts3 
---
>    USE grid_dimensions,       ONLY : nr1, nr2, nr3
>    USE reciprocal_vectors,    ONLY : mill_l
27c28
<    USE gvecs,                 ONLY : ngms
---
>    USE gvecs,                 ONLY : ngs
29c30
<    USE cp_interfaces,         ONLY : phfacs, strucf, prefor, calbec_bgrp, caldbec_bgrp
---
>    USE cp_interfaces,         ONLY : phfacs, strucf
31a33
>    USE mp_global,             ONLY : me_image, mpime
34,36c36,41
<    USE uspp,                  ONLY : okvan, vkb, nkb, nlcc_any
<    USE cp_main_variables,     ONLY : ht0, htm, lambdap, lambda, lambdam, eigr, &
<                                      sfac, taub, irb, eigrb, edft, bec_bgrp, dbec, descla
---
>    USE small_box,             ONLY : ainvb
>    USE uspp,                  ONLY : okvan, vkb, nkb
>    USE core,                  ONLY : nlcc_any
>    USE cp_main_variables,     ONLY : ht0, htm, lambdap, lambda, lambdam, ei1, ei2, ei3, eigr, &
>                                      sfac, bec, taub, irb, eigrb, edft
>    USE cdvan,                 ONLY : dbec
39d43
<    USE fft_base,              ONLY : dfftp
42,43d45
<    
<    INTEGER :: iss
97,98c99,100
<       cm_bgrp(:,iupdwn(2):nbsp) = cm_bgrp(:,1:nupdwn(2))
<       c0_bgrp(:,iupdwn(2):nbsp) = c0_bgrp(:,1:nupdwn(2))
---
>       cm(:,iupdwn(2):nbsp) = cm(:,1:nupdwn(2))
>       c0(:,iupdwn(2):nbsp) = c0(:,1:nupdwn(2))
108c110
<       cm_bgrp = c0_bgrp
---
>       cm = c0
118,119c120,121
<       CALL initbox( tau0, alat, at, ainv, taub, irb )
<       CALL phbox( taub, iverbosity, eigrb )
---
>       CALL initbox( tau0, taub, irb, ainv, a1, a2, a3 )
>       CALL phbox( taub, eigrb, ainvb )
122c124
<    CALL phfacs( eigts1, eigts2, eigts3, eigr, mill, taus, dfftp%nr1, dfftp%nr2, dfftp%nr3, nat )
---
>    CALL phfacs( ei1, ei2, ei3, eigr, mill_l, taus, nr1, nr2, nr3, nat )
124c126
<    CALL strucf( sfac, eigts1, eigts2, eigts3, mill, ngms )
---
>    CALL strucf( sfac, ei1, ei2, ei3, mill_l, ngs )
137c139,141
<       CALL rande_base( c0_bgrp, ampre )
---
>       CALL rande_base( c0, ampre )
> 
>       CALL gram( vkb, bec, nkb, c0, ngw, nbsp )
139c143
<       CALL gram_bgrp( vkb, bec_bgrp, nkb, c0_bgrp, ngw )
---
>       IF( force_pairing ) c0(:,iupdwn(2):nbsp) = c0(:,1:nupdwn(2))
141,143c145
<       IF( force_pairing ) c0_bgrp(:,iupdwn(2):nbsp) = c0_bgrp(:,1:nupdwn(2))
<       !
<       cm_bgrp = c0_bgrp
---
>       cm = c0
147c149
<    CALL calbec_bgrp( 1, nsp, eigr, c0_bgrp, bec_bgrp )
---
>    CALL calbec( 1, nsp, eigr, c0, bec )
149c151
<    IF ( tpre     ) CALL caldbec_bgrp( eigr, c0_bgrp, dbec, descla )
---
>    IF ( tpre     ) CALL caldbec( ngw, nkb, nbsp, 1, nsp, eigr, c0, dbec )
163a166
>    !
Only in ../../../ffn2_tsvdw_master/CPV: restart_sub.F90
Only in ../../../ffn2_tsvdw_master/CPV: restart_sub.o
diff ./runcp.f90 ../../../ffn2_tsvdw_master/CPV/runcp.f90
15c15
<       ( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec_bgrp, c0_bgrp, cm_bgrp, fromscra, restart )
---
>       ( nfi, fccc, ccc, ema0bg, dt2bye, rhos, bec, c0, cm, fromscra, restart )
21,22c21,22
<       !  c0_bgrp  wave functions at time t
<       !  cm_bgrp  wave functions at time t - dt 
---
>       !  c0  wave functions at time t
>       !  cm  wave functions at time t - dt 
25c25
<       !  cm_bgrp  wave functions at time t + dt, not yet othogonalized 
---
>       !  cm  wave functions at time t + dt, not yet othogonalized 
29,32c29,31
<       USE mp_global,           ONLY : me_bgrp, &
<                                       my_bgrp_id, nbgrp, inter_bgrp_comm
<       USE mp,                  ONLY : mp_sum
<       USE fft_base,            ONLY : dffts, tg_gather
---
>       USE mp_global,           ONLY : nogrp, ogrp_comm, me_image, nolist,&
>                                       use_task_groups
>       USE fft_base,            ONLY : dffts
36,37c35,36
<       use gvect,  only : gstart
<       use electrons_base,      only : nbsp_bgrp, ispin_bgrp, f_bgrp, nspin, nupdwn_bgrp, iupdwn_bgrp
---
>       use reciprocal_vectors,  only : gstart
>       use electrons_base,      only : n=>nbsp, ispin, f, nspin, nupdwn, iupdwn
42c41,42
<       USE ldaU_cp,             ONLY : lda_plus_u, vupsi
---
>       USE task_groups,         ONLY : tg_gather
>       USE ldaU
50,51c50,51
<       REAL(DP) :: bec_bgrp(:,:)
<       COMPLEX(DP) :: c0_bgrp(:,:), cm_bgrp(:,:)
---
>       REAL(DP) :: bec(:,:)
>       COMPLEX(DP) :: c0(:,:), cm(:,:)
59,61c59,60
<      complex(DP), allocatable :: c2(:), c3(:), c2tmp(:), c3tmp(:)
<      REAL(DP),    ALLOCATABLE :: tg_rhos(:,:), ftmp(:)
<      INTEGER,     ALLOCATABLE :: itmp(:)
---
>      complex(DP), allocatable :: c2(:), c3(:)
>      REAL(DP),    ALLOCATABLE :: tg_rhos(:,:)
78,80c77,79
<      IF( dffts%have_task_groups ) THEN
<         tg_rhos_siz = dffts%nogrp * dffts%tg_nnr
<         c2_siz      = dffts%nogrp * ngwx
---
>      IF( use_task_groups ) THEN
>         tg_rhos_siz = nogrp * dffts%nnrx
>         c2_siz      = nogrp * ngwx
109,114c108,110
< ! Lingzhu Kong
< !     IF( lwf ) THEN
<      IF( .false. ) THEN
<          call ef_potential( nfi, rhos, bec_bgrp, deeq, vkb, c0_bgrp, cm_bgrp,&
<                              emadt2, emaver, verl1, verl2 )
<      ELSE
---
> !    IF( lwf ) THEN
> 
> !       call ef_potential( nfi, rhos, bec, deeq, vkb, c0, cm, emadt2, emaver, verl1, verl2 )
115a112,113
> !    ELSE
> !============================================================================
122c120
<         IF( dffts%have_task_groups ) THEN
---
>         IF( use_task_groups ) THEN
132c130
<            incr = 2 * dffts%nogrp
---
>            incr = 2 * nogrp
139a138
>         
141c140
<         DO i = 1, nbsp_bgrp, incr
---
>         DO i = 1, n, incr
143c142
<            IF( dffts%have_task_groups ) THEN
---
>            IF( use_task_groups ) THEN
146,147c145,146
<               !Thus, in dforce the dummy arguments for c0_bgrp(1,i) and
<               !c0_bgrp(1,i+1) hold coefficients for eigenstates i,i+2*NOGRP-2,2
---
>               !Thus, in dforce the dummy arguments for c0(1,i) and
>               !c0(1,i+1) hold coefficients for eigenstates i,i+2*NOGRP-2,2
159,217c158
<               IF( nspin > 1 .AND. ispin_bgrp(i) /= ispin_bgrp( MIN( nbsp_bgrp, i+incr-1 ) ) ) THEN
< 
<                  ! when computing force with task group and states with different spin,
<                  ! we need to compute spin up and spin down separately because the logics 
<                  ! of computing two states with different spin at the same time do not work any longer
< 
<                  ALLOCATE( c2tmp( c2_siz ) )
<                  ALLOCATE( c3tmp( c2_siz ) )
<                  ALLOCATE( ftmp( nbsp_bgrp ) )
<                  ALLOCATE( itmp( nbsp_bgrp ) )
< 
<                  !  spin up
<                  itmp = ispin_bgrp(i)
<                  ftmp = f_bgrp(i)
<                  c2tmp = 0.0d0
<                  c3tmp = 0.0d0
<                  CALL dforce( i, bec_bgrp, vkb, c0_bgrp, c2tmp, c3tmp, tg_rhos, tg_rhos_siz, itmp, ftmp, nbsp_bgrp, nspin )
<                  idx_in = 1
<                  DO idx = 1, incr, 2
<                     IF( i + idx - 1 <= nbsp_bgrp ) THEN
<                        IF( ispin_bgrp( i + idx - 1 ) == ispin_bgrp(i) ) THEN
<                           c2( (idx_in-1)*ngw+1 : idx_in*ngw ) = c2tmp( (idx_in-1)*ngw+1 : idx_in*ngw )
<                        END IF
<                        IF( ispin_bgrp( i + idx     ) == ispin_bgrp(i) ) THEN
<                           c3( (idx_in-1)*ngw+1 : idx_in*ngw ) = c3tmp( (idx_in-1)*ngw+1 : idx_in*ngw )
<                        END IF
<                     END IF
<                     idx_in = idx_in + 1
<                  END DO
< 
<                  !  spin down
<                  itmp = ispin_bgrp( MIN( nbsp_bgrp, i+incr-1 ) )
<                  ftmp = f_bgrp( MIN( nbsp_bgrp, i+incr-1 ) )
<                  c2tmp = 0.0d0
<                  c3tmp = 0.0d0
<                  CALL dforce( i, bec_bgrp, vkb, c0_bgrp, c2tmp, c3tmp, tg_rhos, tg_rhos_siz, itmp, ftmp, nbsp_bgrp, nspin )
<                  idx_in = 1
<                  DO idx = 1, incr, 2
<                     IF( i + idx - 1 <= nbsp_bgrp ) THEN
<                        IF( ispin_bgrp( i + idx - 1 ) == ispin_bgrp( MIN( nbsp_bgrp, i+incr-1 ) ) ) THEN
<                           c2( (idx_in-1)*ngw+1 : idx_in*ngw ) = c2tmp( (idx_in-1)*ngw+1 : idx_in*ngw )
<                        END IF
<                        IF( ispin_bgrp( i + idx     ) == ispin_bgrp( MIN( nbsp_bgrp, i+incr-1 ) ) ) THEN
<                           c3( (idx_in-1)*ngw+1 : idx_in*ngw ) = c3tmp( (idx_in-1)*ngw+1 : idx_in*ngw )
<                        END IF
<                     END IF 
<                     idx_in = idx_in + 1
<                  END DO
< 
<                  DEALLOCATE( itmp )
<                  DEALLOCATE( ftmp )
<                  DEALLOCATE( c3tmp )
<                  DEALLOCATE( c2tmp )
< 
<               ELSE
<               
<                  CALL dforce( i, bec_bgrp, vkb, c0_bgrp, c2, c3, tg_rhos, tg_rhos_siz, ispin_bgrp, f_bgrp, nbsp_bgrp, nspin )
< 
<               END IF
---
>               CALL dforce( i, bec, vkb, c0, c2, c3, tg_rhos, tg_rhos_siz, ispin, f, n, nspin )
221c162
<               CALL dforce( i, bec_bgrp, vkb, c0_bgrp, c2, c3, rhos, SIZE(rhos,1), ispin_bgrp, f_bgrp, nbsp_bgrp, nspin )
---
>               CALL dforce( i, bec, vkb, c0, c2, c3, rhos, SIZE(rhos,1), ispin, f, n, nspin )
232c173
<              CALL dforce_efield ( bec_bgrp, i, c0_bgrp, c2, c3, rhos)
---
>              CALL dforce_efield ( bec, i, c0, c2, c3, rhos)
236c177
<              CALL dforce_efield2 ( bec_bgrp, i, c0_bgrp, c2, c3, rhos)
---
>              CALL dforce_efield2 ( bec, i, c0, c2, c3, rhos)
241,243c182,184
<                  IF( i + idx - 1 <= nbsp_bgrp ) THEN
<                     cm_bgrp( :, i+idx-1) = c0_bgrp(:,i+idx-1)
<                     cm_bgrp( :, i+idx  ) = c0_bgrp(:,i+idx  )
---
>                  IF( i + idx - 1 <= n ) THEN
>                     cm( :, i+idx-1) = c0(:,i+idx-1)
>                     cm( :, i+idx  ) = c0(:,i+idx  )
250c191
<               IF( i + idx - 1 <= nbsp_bgrp ) THEN
---
>               IF( i + idx - 1 <= n ) THEN
252,253c193,194
<                     CALL wave_steepest( cm_bgrp(:, i+idx-1 ), c0_bgrp(:, i+idx-1 ), emaver, c2(:), ngw, idx_in )
<                     CALL wave_steepest( cm_bgrp(:, i+idx   ), c0_bgrp(:, i+idx   ), emaver, c3(:), ngw, idx_in )
---
>                     CALL wave_steepest( cm(:, i+idx-1 ), c0(:, i+idx-1 ), emaver, c2, ngw, idx_in )
>                     CALL wave_steepest( cm(:, i+idx   ), c0(:, i+idx   ), emaver, c3, ngw, idx_in )
255,256c196,197
<                     CALL wave_verlet( cm_bgrp(:, i+idx-1 ), c0_bgrp(:, i+idx-1 ), verl1, verl2, emaver, c2(:), ngw, idx_in )
<                     CALL wave_verlet( cm_bgrp(:, i+idx   ), c0_bgrp(:, i+idx   ), verl1, verl2, emaver, c3(:), ngw, idx_in )
---
>                     CALL wave_verlet( cm(:, i+idx-1 ), c0(:, i+idx-1 ), verl1, verl2, emaver, c2, ngw, idx_in )
>                     CALL wave_verlet( cm(:, i+idx   ), c0(:, i+idx   ), verl1, verl2, emaver, c3, ngw, idx_in )
259,260c200,201
<                     cm_bgrp(1,i+idx-1) = CMPLX(real(cm_bgrp(1,i+idx-1)),0.0d0,kind=dp)
<                     cm_bgrp(1,i+idx  ) = CMPLX(real(cm_bgrp(1,i+idx  )),0.0d0,kind=dp)
---
>                     cm(1,i+idx-1) = CMPLX(real(cm(1,i+idx-1)),0.0d0,kind=dp)
>                     cm(1,i+idx  ) = CMPLX(real(cm(1,i+idx  )),0.0d0,kind=dp)
274c215
<      END IF
---
> !    END IF               
280c221
< 
---
> !
300c241
<       USE gvect,  ONLY : gstart
---
>       USE reciprocal_vectors,  ONLY : gstart
304a246,247
>       USE mp_global,           ONLY : use_task_groups
>   !
306c249,250
<       USE fft_base, ONLY: dffts
---
>   !
>   !
309c253
<       USE mp_global, ONLY: intra_bgrp_comm 
---
>       USE mp_global, ONLY: intra_image_comm 
311c255
<       USE ldaU_cp
---
>       USE ldaU
347c291
<        IF( dffts%have_task_groups ) CALL errore(' runcp_force_pairing ',' task_groups not implemented ', 1)
---
>        IF( use_task_groups ) CALL errore(' runcp_force_pairing ',' task_groups not implemented ', 1)
475c419
<       CALL mp_sum ( intermed, intra_bgrp_comm )
---
>       CALL mp_sum ( intermed, intra_image_comm )
493a438
> 
Only in ../../../ffn2_tsvdw_master/CPV: runcp.F90
Only in ../../../ffn2_tsvdw_master/CPV: runcp.o
Only in .: smallbox.f90
Only in .: smallbox_grid.f90
Only in .: smallbox_gvec.f90
Only in .: smallbox_lib.f90
Only in .: smallbox_subs.f90
diff ./spline.f90 ../../../ffn2_tsvdw_master/CPV/spline.f90
22c22
< ! NB: splines are always "natural splines", i.e. values of first
---
> ! NB: splines are always ``natural splines'', i.e. values of first
Only in ../../../ffn2_tsvdw_master/CPV: spline.F90
Only in ../../../ffn2_tsvdw_master/CPV: spline.o
Only in ../../../ffn2_tsvdw_master/CPV: splines.mod
Only in ../../../ffn2_tsvdw_master/CPV: step_constraint.mod
diff ./stop_run.f90 ../../../ffn2_tsvdw_master/CPV/stop_run.f90
16c16,17
<   USE control_flags,      ONLY : lpath, lconstrain
---
>   USE control_flags,      ONLY : lpath, lconstrain, lcoarsegrained, &
>                                  program_name
19c20,21
<   USE image_io_routines,   ONLY : io_image_stop
---
>   USE path_variables,     ONLY : path_deallocation
>   USE path_io_routines,   ONLY : io_path_stop
20a23
>   USE metadyn_vars,       ONLY : deallocate_metadyn_vars
21a25
>   USE reciprocal_vectors, ONLY : mill_g
29c33
<   CALL environment_end( 'CP' )
---
>   CALL environment_end( program_name )
31c35
<   IF ( lpath ) CALL io_image_stop()
---
>   IF ( lpath ) CALL io_path_stop()
36a41,46
>   IF ( lcoarsegrained ) CALL deallocate_metadyn_vars()
>   !
>   IF ( lpath ) CALL path_deallocation()
>   !
>   if( allocated( mill_g ) ) deallocate( mill_g )
> 
Only in ../../../ffn2_tsvdw_master/CPV: stop_run.F90
Only in ../../../ffn2_tsvdw_master/CPV: stop_run.o
diff ./stress.f90 ../../../ffn2_tsvdw_master/CPV/stress.f90
14c14
<       USE mp_global,     ONLY: intra_bgrp_comm
---
>       USE mp_global,     ONLY: intra_image_comm
34c34
<       CALL mp_sum( de3x3, intra_bgrp_comm )
---
>       CALL mp_sum( de3x3, intra_image_comm )
48c48,49
<       USE gvecs,              ONLY: ngms
---
>       USE reciprocal_vectors, ONLY: gstart
>       USE gvecs,              ONLY: ngs
68c69
<       ALLOCATE( drhoe( ngms, 6 ), rhoe( ngms ) )
---
>       ALLOCATE( drhoe( ngs, 6 ), rhoe( ngs ) )
70,71c71,72
<       rhoe( 1:ngms ) = rhoeg( 1:ngms, 1 )
<       IF( nspin > 1 ) rhoe( 1:ngms ) = rhoe( 1:ngms ) + rhoeg( 1:ngms, 2 )
---
>       rhoe( 1:ngs ) = rhoeg( 1:ngs, 1 )
>       IF( nspin > 1 ) rhoe( 1:ngs ) = rhoe( 1:ngs ) + rhoeg( 1:ngs, 2 )
74c75
<          drhoe( 1:ngms, k ) = - rhoe( 1:ngms ) * dalbe( k )
---
>          drhoe( 1:ngs, k ) = - rhoe( 1:ngs ) * dalbe( k )
92,93c93,94
<       USE gvect, ONLY: gstart
<       USE gvecs,              ONLY: ngms
---
>       USE reciprocal_vectors, ONLY: gstart
>       USE gvecs,              ONLY: ngs
115c116
<       DO ig = gstart, ngms
---
>       DO ig = gstart, ngs
130c131
<       DO ig = gstart, ngms
---
>       DO ig = gstart, ngs
149c150
<    SUBROUTINE stress_kin_x( dekin, c0_bgrp, occ_bgrp ) 
---
>    SUBROUTINE stress_kin_x( dekin, c0, occ ) 
160c161
<       USE gvecw,              ONLY: q2sigma, ecfixed, qcutz, ngw
---
>       USE gvecw,              ONLY: ecsig, ecfix, ecutz, ngw
162c163
<       USE gvect, ONLY: gstart, gg, g
---
>       USE reciprocal_vectors, ONLY: gstart, g, gx
164c165
<       USE electrons_base,     ONLY: nspin, iupdwn_bgrp, nupdwn_bgrp
---
>       USE electrons_base,     ONLY: nspin, iupdwn, nupdwn
171,172c172,173
<       COMPLEX(DP), INTENT(IN)  :: c0_bgrp(:,:)
<       REAL(DP),    INTENT(IN)  :: occ_bgrp(:)
---
>       COMPLEX(DP), INTENT(IN)  :: c0(:,:)
>       REAL(DP),    INTENT(IN)  :: occ(:)
185c186
<       efac = 2.0d0 * qcutz / q2sigma / SQRT(pi)
---
>       efac = 2.0d0 * ecutz / ecsig / SQRT(pi)
188c189
<           arg(ig) = 1.0d0 + efac * exp( -( ( tpiba2 *gg(ig) - ecfixed ) / q2sigma )**2 )
---
>           arg(ig) = 1.0d0 + efac * exp( -( ( tpiba2 * g(ig) - ecfix ) / ecsig )**2 )
197c198
<         DO ib = 1, nupdwn_bgrp( ispin )
---
>         DO ib = 1, nupdwn( ispin )
199c200
<           iwfc = ib + iupdwn_bgrp( ispin ) - 1
---
>           iwfc = ib + iupdwn( ispin ) - 1
201,207c202,208
<             scg = arg(ig) * CONJG( c0_bgrp( ig, iwfc ) ) * c0_bgrp( ig, iwfc )
<             sk(1)  = sk(1) + scg * g( alpha( 1 ), ig ) * g( beta( 1 ), ig )
<             sk(2)  = sk(2) + scg * g( alpha( 2 ), ig ) * g( beta( 2 ), ig )
<             sk(3)  = sk(3) + scg * g( alpha( 3 ), ig ) * g( beta( 3 ), ig )
<             sk(4)  = sk(4) + scg * g( alpha( 4 ), ig ) * g( beta( 4 ), ig )
<             sk(5)  = sk(5) + scg * g( alpha( 5 ), ig ) * g( beta( 5 ), ig )
<             sk(6)  = sk(6) + scg * g( alpha( 6 ), ig ) * g( beta( 6 ), ig )
---
>             scg = arg(ig) * CONJG( c0( ig, iwfc ) ) * c0( ig, iwfc )
>             sk(1)  = sk(1) + scg * gx( alpha( 1 ), ig ) * gx( beta( 1 ), ig )
>             sk(2)  = sk(2) + scg * gx( alpha( 2 ), ig ) * gx( beta( 2 ), ig )
>             sk(3)  = sk(3) + scg * gx( alpha( 3 ), ig ) * gx( beta( 3 ), ig )
>             sk(4)  = sk(4) + scg * gx( alpha( 4 ), ig ) * gx( beta( 4 ), ig )
>             sk(5)  = sk(5) + scg * gx( alpha( 5 ), ig ) * gx( beta( 5 ), ig )
>             sk(6)  = sk(6) + scg * gx( alpha( 6 ), ig ) * gx( beta( 6 ), ig )
209c210
<           dekin = dekin  + occ_bgrp( iwfc ) * sk * tpiba2
---
>           dekin = dekin  + occ( iwfc ) * sk * tpiba2
225c226
<       USE gvecs,        ONLY: ngms
---
>       USE gvecs,        ONLY: ngs
242c243
<                DO ig = 1, ngms
---
>                DO ig = 1, ngs
248c249
<       DO ig = 1, ngms
---
>       DO ig = 1, ngs
269c270
<       use mp_global,          ONLY: me_bgrp, root_bgrp
---
>       use mp_global,          ONLY: me_image, root_image
272,274c273,275
<       USE gvect, ONLY: gstart
<       USE gvecs,              ONLY: ngms
<       USE gvect,              ONLY: ngm
---
>       USE reciprocal_vectors, ONLY: gstart, g
>       USE gvecs,              ONLY: ngs
>       USE gvecp,              ONLY: ngm
310c311
<          DO ig = gstart, ngms
---
>          DO ig = gstart, ngs
354c355
<       use mp_global,          ONLY: me_bgrp, root_bgrp
---
>       use mp_global,          ONLY: me_image, root_image
357,359c358,360
<       USE gvect, ONLY: gstart, gg
<       USE gvecs,              ONLY: ngms
<       USE gvect,              ONLY: ngm
---
>       USE reciprocal_vectors, ONLY: gstart, g
>       USE gvecs,              ONLY: ngs
>       USE gvecp,              ONLY: ngm
388c389
<          hgm1( ig ) = 1.D0 / gg(ig) / tpiba2
---
>          hgm1( ig ) = 1.D0 / g(ig) / tpiba2
408c409
<       if ( me_bgrp == root_bgrp ) then
---
>       if ( me_image == root_image ) then
427c428
<         USE mp_global,    ONLY: intra_bgrp_comm
---
>         USE mp_global,    ONLY: intra_image_comm
445c446
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
454c455
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
463c464
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
472c473
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
481c482
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
490c491
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
499c500
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
508c509
<         CALL mp_sum( detmp, intra_bgrp_comm )
---
>         CALL mp_sum( detmp, intra_image_comm )
524c525
<       SUBROUTINE compute_gagb_x( gagb, g, ngm, tpiba2 )
---
>       SUBROUTINE compute_gagb_x( gagb, gx, ngm, tpiba2 )
535c536
<          REAL(DP), INTENT(IN)  :: g(:,:)
---
>          REAL(DP), INTENT(IN)  :: gx(:,:)
541,544c542,544
< !$omp parallel do default(shared), private(k)
<          DO ig = 1, ngm          
<             DO k = 1, 6
<                gagb( k, ig ) = g( alpha( k ), ig ) * g( beta( k ), ig ) * tpiba2
---
>          DO k = 1, 6
>             DO ig = 1, ngm          
>                gagb( k, ig ) = gx( alpha( k ), ig ) * gx( beta( k ), ig ) * tpiba2
Only in ../../../ffn2_tsvdw_master/CPV: stress.F90
Only in ../../../ffn2_tsvdw_master/CPV: stress.o
Only in ../../../ffn2_tsvdw_master/CPV: stress_param.mod
Only in ../../../ffn2_tsvdw_master/CPV: tsvdw.f90
Only in ../../../ffn2_tsvdw_master/CPV: tsvdw.F90
Only in ../../../ffn2_tsvdw_master/CPV: tsvdw_module.mod
Only in ../../../ffn2_tsvdw_master/CPV: tsvdw.o
Only in ../../../ffn2_tsvdw_master/CPV: tune.mod
Only in ../../../ffn2_tsvdw_master/CPV: vanderwaals.f90
Only in .: vofrho.f90
diff ./vol_clu.f90 ../../../ffn2_tsvdw_master/CPV/vol_clu.f90
17,22c17,19
<       use kinds,          only: dp
<       use constants,      only: pi
<       use parameters,     only: nsx
<       use cell_base,      only: alat, at, h, omega, tpiba, tpiba2
<       use electrons_base, only: nspin
<       use ions_base,      only: na, nsp, amass
---
>       use cell_base
>       use electrons_base
>       use ions_base
24,26c21,26
<       use gvect, only: g, gg
<       use gvecs,          only: ngms
<       use gvect,          only: ngm, nl, nlm
---
>       use constants, only: pi
>       use parameters
>       use reciprocal_vectors
>       use gvecs
>       use gvecp, only: ngm
>       use recvecs_indexes
28,30c28,32
<       use control_flags,  only: tpre
<       use fft_base,       ONLY : dfftp
<       USE fft_interfaces, ONLY: invfft
---
>       use control_flags, only: tpre
>       use local_pseudo
>       USE cp_interfaces,    ONLY: fwfft, invfft
>       use grid_dimensions, only: nr1, nr2, nr3,                         &
>      &                   nr1x, nr2x, nr3x, nnr => nnrx
37c39,40
< #ifdef __MPI
---
>       use fft_base
> #ifdef __PARA
41c44
<       USE mp_global,          ONLY: intra_bgrp_comm
---
>       USE mp_global,          ONLY: intra_image_comm
46c49
< #ifdef __MPI
---
> #ifdef __PARA
53c56
<       real(kind=8) rho_real(dfftp%nnr,nspin), rhoc
---
>       real(kind=8) rho_real(nnr,nspin), rhoc
68c71
<       complex(kind=8) s_fac(ngms,nsp), ci
---
>       complex(kind=8) s_fac(ngs,nsp), ci
75c78
< #ifdef __MPI
---
> #ifdef __PARA
80,85c83,88
<       if (abisur) allocate(drho(3,dfftp%nnr))
<       if (abisur) allocate(d2rho(3,dfftp%nnr))
<       if (abisur) allocate(dxdyrho(dfftp%nnr))
<       if (abisur) allocate(dxdzrho(dfftp%nnr))
<       if (abisur) allocate(dydzrho(dfftp%nnr))
<       allocate(psi(dfftp%nnr))
---
>       if (abisur) allocate(drho(3,nnr))
>       if (abisur) allocate(d2rho(3,nnr))
>       if (abisur) allocate(dxdyrho(nnr))
>       if (abisur) allocate(dxdzrho(nnr))
>       if (abisur) allocate(dydzrho(nnr))
>       allocate(psi(nnr))
91c94
< #ifdef __MPI
---
> #ifdef __PARA
130,133c133,136
<             do ir3 = 1,dfftp%nr3
<                do ir2 = 1,dfftp%nr2
<                   do ir1 = 1,dfftp%nr1
<                      ir = ir1 + (ir2-1)*dfftp%nr1 + (ir3-1)*dfftp%nr2*dfftp%nr1
---
>             do ir3 = 1,nr3
>                do ir2 = 1,nr2
>                   do ir1 = 1,nr1
>                      ir = ir1 + (ir2-1)*nr1 + (ir3-1)*nr2*nr1
136,138c139,141
<                         posv(i,ir) = (DBLE(ir1)-1.0d0)*at(i,1)/DBLE(dfftp%nr1) +&
<      &                               (DBLE(ir2)-1.0d0)*at(i,2)/DBLE(dfftp%nr2) +&
<      &                               (DBLE(ir3)-1.0d0)*at(i,3)/DBLE(dfftp%nr3)
---
>                         posv(i,ir) = (DBLE(ir1)-1.0d0)*a1(i)/DBLE(nr1) +&
>      &                              (DBLE(ir2)-1.0d0)*a2(i)/DBLE(nr2) +&
>      &                              (DBLE(ir3)-1.0d0)*a3(i)/DBLE(nr3)
143d145
<             posv(:,:) = posv(:,:)*alat
197c199
<                   cm(k) = cm(k) + tauv(k,ia,is)*amass(is)
---
>                   cm(k) = cm(k) + tauv(k,ia,is)*pmass(is)
199c201
<                mtot = mtot + amass(is)
---
>                mtot = mtot + pmass(is)
223c225
<                            prod = prod + g(k,ig)*tau00(k)
---
>                            prod = prod + gx(k,ig)*tau00(k)
227c229
<                         aux = alfa0*hgt*EXP(-(0.50d0*alfa0**2*gg(ig)*tpiba2))
---
>                         aux = alfa0*hgt*EXP(-(0.50d0*alfa0**2*g(ig)*tpiba2))
257,258c259,260
<             psi(nl(ig)) = rhotmp(ig,1)
<             psi(nlm(ig))= conjg(rhotmp(ig,1))
---
>             psi(np(ig)) = rhotmp(ig,1)
>             psi(nm(ig)) = conjg(rhotmp(ig,1))
261c263
<          do ir = 1,dfftp%nnr
---
>          do ir = 1,nnr
266,267c268,269
<             psi(nl(ig)) = rhotmp(ig,1) + ci*rhotmp(ig,2)
<             psi(nlm(ig))= conjg(rhotmp(ig,1)) + ci*conjg(rhotmp(ig,2))
---
>             psi(np(ig)) = rhotmp(ig,1) + ci*rhotmp(ig,2)
>             psi(nm(ig)) = conjg(rhotmp(ig,1)) + ci*conjg(rhotmp(ig,2))
270c272
<          do ir = 1,dfftp%nnr
---
>          do ir = 1,nnr
279c281
<       do ir = 1,dfftp%nnr
---
>       do ir = 1,nnr
284c286
< #ifdef __MPI
---
> #ifdef __PARA
295c297
<                dist = dist + (pos_aux(j) - 0.5d0*(at(j,1)+at(j,2)+at(j,3)))**2
---
>                dist = dist + (pos_aux(j) - 0.5d0*(a1(j)+a2(j)+a3(j)))**2
297c299
<             dist = dsqrt(dist)*alat
---
>             dist = dsqrt(dist)
309c311
<      &                                DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      &                                DBLE(nr1*nr2*nr3)
313c315
<      &                                DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      &                                DBLE(nr1*nr2*nr3)
368c370
<      &                    DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      &                    DBLE(nr1*nr2*nr3)
394,399c396,401
< #ifdef __MPI
<       call mp_sum(volclu,intra_bgrp_comm)
<       call mp_sum(n_ele,intra_bgrp_comm)
<       if (jellium) call mp_sum(e_j,intra_bgrp_comm)
<       call mp_sum(surfclu,intra_bgrp_comm)
<       call mp_sum(dpvdh,intra_bgrp_comm)
---
> #ifdef __PARA
>       call mp_sum(volclu,intra_image_comm)
>       call mp_sum(n_ele,intra_image_comm)
>       if (jellium) call mp_sum(e_j,intra_image_comm)
>       call mp_sum(surfclu,intra_image_comm)
>       call mp_sum(dpvdh,intra_image_comm)
401,403c403,405
<       volclu = volclu * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
<       n_ele = n_ele * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
<       surfclu = surfclu * omega / DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3) / dthr
---
>       volclu = volclu * omega / DBLE(nr1*nr2*nr3)
>       n_ele = n_ele * omega / DBLE(nr1*nr2*nr3)
>       surfclu = surfclu * omega / DBLE(nr1*nr2*nr3) / dthr
Only in ../../../ffn2_tsvdw_master/CPV: vol_clu.F90
Only in ../../../ffn2_tsvdw_master/CPV: vol_clu.o
Only in .: wannier_base.f90
diff ./wannier.f90 ../../../ffn2_tsvdw_master/CPV/wannier.f90
140c140
<   SUBROUTINE allocate_wannier( nbsp, nrxxs, nspin, ng )
---
>   SUBROUTINE allocate_wannier( nbsp, nnrsx, nspin, ng )
143c143
<     INTEGER, INTENT(in) :: nbsp, nrxxs, nspin, ng
---
>     INTEGER, INTENT(in) :: nbsp, nnrsx, nspin, ng
147,148c147,148
<     ALLOCATE( rhos1( nrxxs, nspin) )
<     ALLOCATE( rhos2( nrxxs, nspin) )
---
>     ALLOCATE( rhos1( nnrsx, nspin) )
>     ALLOCATE( rhos2( nnrsx, nspin) )
185c185
<   REAL(DP) :: tt(3), tt2(3)
---
>   REAL(DP) :: tt(3), cdmm(3), tt2(3)
397,399c397,399
<   SUBROUTINE wf_options( tfirst, nfi, cm, rhovan, bec, dbec, eigr, eigrb, &
<                          taub, irb, ibrav, b1, b2, b3, rhor, drhor, rhog, &
<                          drhog ,rhos, enl, ekin  )
---
>   SUBROUTINE wf_options( tfirst, nfi, cm, rhovan, bec, eigr, eigrb, &
>                          taub, irb, ibrav, b1, b2, b3, rhor, rhog, rhos,   &
>                          enl, ekin  )
404a405
>     USE control_flags,  ONLY : iprsta
414d414
<     REAL(DP)      :: dbec(:,:,:,:)
422,423c422
<     COMPLEX(DP)   :: drhog(:,:,:,:)
<     REAL(DP)      :: drhor(:,:,:,:), rhor(:,:), rhos(:,:)
---
>     REAL(DP)      :: rhor(:,:), rhos(:,:)
436c435
<           CALL rhoofr (nfi,cm, irb, eigrb,bec,dbec,rhovan,rhor,drhor,rhog,drhog,rhos,enl,denl,ekin,dekin6,.false.,j)
---
>           CALL rhoofr (nfi,cm, irb, eigrb,bec,rhovan,rhor,rhog,rhos,enl,denl,ekin,dekin6,.false.,j)
478a478
>     USE smooth_grid_dimensions, ONLY : nnrsx
480,481c480,481
<     USE cell_base,              ONLY : ainv, alat, at
<     USE gvect,                  ONLY : gstart
---
>     USE cell_base,              ONLY : ainv, a1, a2, a3
>     USE reciprocal_vectors,     ONLY : gstart
485d484
<     USE fft_base,               ONLY : dffts
499d497
<     REAL(DP) :: a1(3), a2(3), a3(3)
508,509d505
<     a1(:) = at(:,1)/alat ; a2(:) = at(:,2)/alat ; a3(:) = at(:,3)/alat
< 
550c546
<           DO ir=1,dffts%nnr
---
>           DO ir=1,nnrsx
584c580
<           CALL dforce(i,bec,betae,c0,c2,c3,rhos1,dffts%nnr,ispin,f,nbsp,nspin,rhos2)
---
>           CALL dforce(i,bec,betae,c0,c2,c3,rhos1,nnrsx,ispin,f,nbsp,nspin,rhos2)
586c582
<           CALL dforce(i,bec,betae,c0,c2,c3,rhos,dffts%nnr,ispin,f,nbsp,nspin)
---
>           CALL dforce(i,bec,betae,c0,c2,c3,rhos,nnrsx,ispin,f,nbsp,nspin)
620c616
<     USE cell_base,             ONLY : ainv, alat, at
---
>     USE cell_base,             ONLY : ainv, a1, a2, a3
627d622
<     REAL(DP) :: a1(3), a2(3), a3(3)
630d624
<     a1(:) = at(:,1)/alat ; a2(:) = at(:,2)/alat ; a3(:) = at(:,3)/alat
681c675
<                                  velsm, acc, lambda, lambdam, descla, xnhe0, xnhem,   &
---
>                                  velsm, acc, lambda, lambdam, xnhe0, xnhem,   &
689a684
>     USE control_flags,  ONLY : iprsta
694c689,690
<     USE uspp_param,     ONLY : nvb
---
>     USE ions_base,      ONLY : pmass
>     USE cvan,           ONLY : nvb
696d691
<     USE descriptors,    ONLY : la_descriptor
712d706
<     TYPE(la_descriptor), INTENT(IN) :: descla(:)
744c738
<                        tausm, vels, velsm,acc, lambda, lambdam, descla, xnhe0, xnhem, &
---
>                        tausm, vels, velsm,acc, lambda, lambdam, xnhe0, xnhem, &
Only in ../../../ffn2_tsvdw_master/CPV: wannier.F90
Only in ../../../ffn2_tsvdw_master/CPV: wannier_module.mod
Only in ../../../ffn2_tsvdw_master/CPV: wannier.o
Only in ../../../ffn2_tsvdw_master/CPV: wannier_subroutines.mod
diff ./wave.f90 ../../../ffn2_tsvdw_master/CPV/wave.f90
32c32
<        USE mp_global,          ONLY: me_bgrp, intra_bgrp_comm
---
>        USE mp_global,          ONLY: me_image, intra_image_comm
35c35
<        USE gvect, ONLY: gstart
---
>        USE reciprocal_vectors, ONLY: gzero
45d44
<        LOGICAL :: gzero
47d45
<        gzero = (gstart == 2) 
50c48
<        CALL mp_sum( prod, intra_bgrp_comm )
---
>        CALL mp_sum( prod, intra_image_comm )
52c50
<           IF( me_bgrp == ib_owner( i ) ) THEN
---
>           IF( me_image == ib_owner( i ) ) THEN
74,75c72,73
<     use mp_global,          only : intra_bgrp_comm, nbgrp, inter_bgrp_comm
<     use gvect, only : gstart
---
>     use mp_global,          only : intra_image_comm
>     use reciprocal_vectors, only : gstart
102,104c100
<     CALL mp_sum( ekincm, intra_bgrp_comm )
<     IF( nbgrp > 1 ) &
<        CALL mp_sum( ekincm, inter_bgrp_comm )
---
>     CALL mp_sum( ekincm, intra_image_comm )
110,142d105
< !=----------------------------------------------------------------------------=!
<   subroutine bandsum( bsum, c0, ngw, tbgrp )
< !=----------------------------------------------------------------------------=!
<     !
<     !  This subroutine computes the CP(fake) wave functions kinetic energy
<     
<     USE kinds,              only : DP
<     use mp,                 only : mp_sum
<     use mp_global,          only : intra_bgrp_comm, nbgrp, inter_bgrp_comm
<     USE electrons_base,     ONLY : nbsp, nbsp_bgrp
<     !
<     IMPLICIT NONE
<     !
<     integer, intent(in)      :: ngw    !  number of plane wave coeff.
<     real(DP), intent(out)    :: bsum
<     complex(DP), intent(in)  :: c0( ngw, * )
<     logical, intent(in)      :: tbgrp
<     !
<     integer  :: i, n
< 
<     n = nbsp
<     IF( tbgrp ) n = nbsp_bgrp
< 
<     bsum=0.0d0
<     do i = 1, n
<       bsum = bsum + SUM( DBLE( CONJG( c0( :, i ) ) * c0( :, i ) ) )
<     end do
<     CALL mp_sum( bsum, intra_bgrp_comm )
<     IF( tbgrp ) &
<        CALL mp_sum( bsum, inter_bgrp_comm )
< 
<     return
<   end subroutine bandsum
163c126
<       !  of 1, ( row 1 to PE 1, row 2 to PE 2, .. row nproc_bgrp+1 to PE 1 and
---
>       !  of 1, ( row 1 to PE 1, row 2 to PE 2, .. row nproc_image+1 to PE 1 and
172c135
<       USE mp_global,        ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm
---
>       USE mp_global,        ONLY: nproc_image, me_image, intra_image_comm
220c183
<             CALL mp_bcast( uu, (ip-1), intra_bgrp_comm)
---
>             CALL mp_bcast( uu, (ip-1), intra_image_comm)
265c228
<       USE mp_global,        ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm
---
>       USE mp_global,        ONLY: nproc_image, me_image, intra_image_comm
336c299
<         !  of 1, ( row 1 to PE 1, row 2 to PE 2, .. row nproc_bgrp+1 to PE 1 and so on).
---
>         !  of 1, ( row 1 to PE 1, row 2 to PE 2, .. row nproc_image+1 to PE 1 and so on).
341c304
<         USE mp_global,          ONLY: nproc_bgrp, me_bgrp, intra_bgrp_comm
---
>         USE mp_global,          ONLY: nproc_image, me_image, intra_image_comm
343c306
<         USE gvect, ONLY: gstart
---
>         USE reciprocal_vectors, ONLY: gzero
356d318
<         LOGICAL :: gzero
364c326
<         gzero = (gstart == 2) 
---
> 
366d327
<         
369c330
<             ee(j) = -dotp( gzero, ngw, b(:,j+noff-1), a(:,i+noff-1), intra_bgrp_comm )
---
>             ee(j) = -dotp( gzero, ngw, b(:,j+noff-1), a(:,i+noff-1) )
372c333
<             IF( MOD( (i-1), nproc_bgrp ) == me_bgrp ) THEN
---
>             IF( MOD( (i-1), nproc_image ) == me_image ) THEN
374c335
<                 lambda( (i-1) / nproc_bgrp + 1, j ) = ee(j)
---
>                 lambda( (i-1) / nproc_image + 1, j ) = ee(j)
392c353
<    SUBROUTINE wave_rand_init_x( cm_bgrp )
---
>    SUBROUTINE wave_rand_init_x( cm, n, noff )
400,402d360
< #if defined (__LOWMEM) || defined (__NEW_RND_WF)
<       USE mp,                 ONLY: mp_max, mp_min
< #endif
404,409c362,363
<       USE mp_global,          ONLY: me_bgrp, nproc_bgrp, root_bgrp, intra_bgrp_comm, mpime
<       USE gvect,              ONLY: ig_l2g, gstart
< #if defined (__LOWMEM) || defined (__NEW_RND_WF)
<       USE gvect,              ONLY: mill, gg
< #endif
<       USE gvecw,              ONLY: ngw, ngw_g
---
>       USE mp_global,          ONLY: me_image, nproc_image, root_image, intra_image_comm
>       USE reciprocal_vectors, ONLY: ig_l2g, ngw, ngwt, gzero
412d365
<       USE electrons_base,     ONLY: nbsp, ibgrp_g2l
417c370,371
<       COMPLEX(DP), INTENT(OUT) :: cm_bgrp(:,:)
---
>       INTEGER,     INTENT(IN)  :: n, noff
>       COMPLEX(DP), INTENT(OUT) :: cm(:,:)
420,421c374,375
<       INTEGER :: ntest, ig, ib, ibgrp, lb, ub
<       REAL(DP) ::  rranf1, rranf2, ampre, ggx, fac, r1, r2, r3
---
>       INTEGER :: ntest, ig, ib
>       REAL(DP) ::  rranf1, rranf2, ampre
423,428d376
<       REAL(DP),    ALLOCATABLE :: RND( : , : )
<       INTEGER :: iss, n1, n2, m1, m2, i
< 
<       ! ... initialize the wave functions in such a way that the values
<       ! ... of the components are independent on the number of processors
<       ! ... with __NEW_RND_WF the initialization is independend from G sorting too!
432c380
<       IF( SIZE( cm_bgrp, 1 ) < ngw ) THEN 
---
>       IF( SIZE( cm, 1 ) < ngw ) THEN 
438c386,389
<       cm_bgrp = 0.0d0
---
>       cm( :, noff : noff + n - 1 ) = 0.0d0
> 
>       ! ... initialize the wave functions in such a way that the values
>       ! ... of the components are independent on the number of processors
440c391,392
<       ampre   = 0.01d0
---
>       ampre = 0.01d0
>       ALLOCATE( pwt( ngwt ) )
442,454c394,396
< #if defined (__LOWMEM) || defined (__NEW_RND_WF)
<       ggx = MAXVAL( gg( 1:ngw ) )
<       CALL mp_max( ggx, intra_bgrp_comm )
<       lb = MINVAL( mill )
<       CALL mp_min( lb, intra_bgrp_comm )
<       ub = MAXVAL( mill )
<       CALL mp_max( ub, intra_bgrp_comm )
<       ALLOCATE( RND( 3, lb:ub ) )
< #else
<       ALLOCATE( pwt( ngw_g ) )
<       ntest = ngw_g / 4
<       IF( ntest < SIZE( cm_bgrp, 2 ) ) THEN
<          ntest = ngw_g
---
>       ntest = ngwt / 4
>       IF( ntest < SIZE( cm, 2 ) ) THEN
>          ntest = ngwt
456,464d397
< #endif
<       ! r1 = 0.0d0
<       ! DO ig = 1, ngw
<       !    IF( ig_l2g( ig ) <= ntest ) THEN
<       !      IF( gg( ig ) > r1 ) r1 = gg( ig ) 
<       !    ENDIF
<       ! END DO
<       ! CALL mp_max( r1, intra_bgrp_comm )
<       ! WRITE(*,*) 'r1 = ', r1
468,477c401
<       DO ib = 1, nbsp
< 
< #if defined (__LOWMEM) || defined (__NEW_RND_WF)
<         rnd = 0.0d0
<         DO ig = lb, ub
<            rnd( 1, ig ) = 0.5d0 - randy()
<            rnd( 2, ig ) = 0.5d0 - randy()
<            rnd( 3, ig ) = 0.5d0 - randy()
<         END DO
< #else
---
>       DO ib = noff, noff + n - 1
484,501c408,410
< #endif
<         !
<         ibgrp = ibgrp_g2l( ib )
<         !
<         IF( ibgrp > 0 ) THEN
<           DO ig = 1, ngw
< #if defined (__LOWMEM) || defined (__NEW_RND_WF)
<             IF( gg(ig) < ggx / 2.519d0 ) THEN  ! 2.519 = 4^(2/3), equivalent to keep only (ngw_g/4) values
<                rranf1 = rnd( 1, mill(1,ig) ) * rnd( 2, mill(2,ig) ) * rnd( 3, mill(3,ig) )
<                rranf2 = 0.0d0
<                cm_bgrp( ig, ibgrp ) =  ampre * CMPLX( rranf1, rranf2 ,kind=DP) / ( 1.0d0 + gg(ig) )
<             END IF
< #else
<             cm_bgrp( ig, ibgrp ) = pwt( ig_l2g( ig ) )
< #endif
<           END DO
<         END IF
<         !
---
>         DO ig = 1, ngw
>           cm( ig, ib ) = pwt( ig_l2g( ig ) )
>         END DO
503,504c412,413
<       IF ( gstart == 2 ) THEN
<         cm_bgrp( 1, : ) = (0.0d0, 0.0d0)
---
>       IF ( gzero ) THEN
>         cm( 1, noff : noff + n - 1 ) = (0.0d0, 0.0d0)
507,542c416
<       IF( ALLOCATED( pwt ) ) DEALLOCATE( pwt )
<       IF( ALLOCATED( rnd ) ) DEALLOCATE( rnd )
< 
< #ifdef PIPPO_DEBUG
<       write(1000+mpime,fmt='(8I5)') nbsp, nbsp_bgrp, nudx, nudx_bgrp, nbsp, nbsp_bgrp, nbspx, nbspx_bgrp
<       DO iss = 1, nspin
<          write(1000+mpime,fmt='(5I5)') nupdwn(iss), iupdwn(iss), nupdwn_bgrp(iss), iupdwn_bgrp(iss), i2gupdwn_bgrp(iss)
<       END DO
<       DO ib = 1, nbsp
<          ! write(1000+mpime,fmt='(2I5)') ib, ibgrp_g2l(ib)
<       END DO
< 
<       DO iss = nspin, 1, -1
<          write(1000+mpime,*) 'copy'
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          DO i = m2, m1, -1
<             write(1000+mpime,fmt='(2I5)') i, i-m1+n1
<          END DO
<       END DO
<       DO iss = 1, nspin
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          write(1000+mpime,*) 'zero'
<          DO i = iupdwn(iss), m1-1
<             write(1000+mpime,fmt='(1I5)') i
<          END DO
<          write(1000+mpime,*) 'zero'
<          DO i = m2+1, iupdwn(iss) + nupdwn(iss) - 1
<             write(1000+mpime,fmt='(1I5)') i
<          END DO
<       END DO
< #endif
< 
---
>       DEALLOCATE( pwt )
546,601d419
< 
< 
<     SUBROUTINE c_bgrp_expand_x( c_bgrp )
<       USE kinds,              ONLY: DP
<       USE mp,                 ONLY: mp_sum
<       USE electrons_base,     ONLY: nspin, i2gupdwn_bgrp, nupdwn, iupdwn_bgrp, iupdwn, nupdwn_bgrp
<       USE mp_global,          ONLY: nbgrp, inter_bgrp_comm
<       IMPLICIT NONE
<       COMPLEX(DP) :: c_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2, i
<       IF( nbgrp < 2 ) &
<          RETURN
<       DO iss = nspin, 1, -1
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          DO i = m2, m1, -1
<             c_bgrp(:,i) = c_bgrp(:,i-m1+n1)
<          END DO
<       END DO
<       DO iss = 1, nspin
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          DO i = iupdwn(iss), m1-1
<             c_bgrp(:,i) = 0.0d0
<          END DO
<          DO i = m2+1, iupdwn(iss) + nupdwn(iss) - 1
<             c_bgrp(:,i) = 0.0d0
<          END DO
<       END DO
<       CALL mp_sum( c_bgrp, inter_bgrp_comm )
<       RETURN
<     END SUBROUTINE c_bgrp_expand_x
< 
< 
<     SUBROUTINE c_bgrp_pack_x( c_bgrp )
<       USE kinds,              ONLY: DP
<       USE electrons_base,     ONLY: nspin, i2gupdwn_bgrp, nupdwn, iupdwn_bgrp, iupdwn, nupdwn_bgrp
<       USE mp_global,          ONLY: nbgrp
<       IMPLICIT NONE
<       COMPLEX(DP) :: c_bgrp(:,:)
<       INTEGER :: iss, n1, n2, m1, m2, i
<       IF( nbgrp < 2 ) &
<          RETURN
<       DO iss = 1, nspin
<          n1 = iupdwn_bgrp(iss)
<          n2 = n1 + nupdwn_bgrp(iss) - 1
<          m1 = iupdwn(iss)+i2gupdwn_bgrp(iss) - 1
<          m2 = m1 + nupdwn_bgrp(iss) - 1
<          DO i = n1, n2
<             c_bgrp(:,i) = c_bgrp(:,i-n1+m1)
<          END DO
<       END DO
<       RETURN
<     END SUBROUTINE c_bgrp_pack_x
Only in ../../../ffn2_tsvdw_master/CPV: wave.F90
Only in ../../../ffn2_tsvdw_master/CPV: wave.o
Only in ../../../ffn2_tsvdw_master/CPV: wave_types.F90
Only in ../../../ffn2_tsvdw_master/CPV: wave_types.mod
Only in ../../../ffn2_tsvdw_master/CPV: wave_types.o
Only in .: wfdd.f90
diff ./wf.f90 ../../../ffn2_tsvdw_master/CPV/wf.f90
2c2
< ! Copyright (C) 2002-2011 Quantum ESPRESSO group
---
> ! Copyright (C) 2002-2005 Quantum ESPRESSO group
27,28c27,28
<   USE uspp_param,               ONLY : nvb, ish
<   USE cell_base,                ONLY : omega, at, alat, h, ainv
---
>   USE cvan,                     ONLY : nvb, ish
>   USE cell_base,                ONLY : omega, a1, a2, a3, alat, h, ainv
30c30
<   USE smallbox_gvec,                    ONLY : npb, nmb, ngb
---
>   USE gvecb,                    ONLY : npb, nmb, ngb
32,33c32,34
<   USE gvect,       ONLY : gstart
<   USE control_flags,            ONLY : iverbosity
---
>   USE reciprocal_vectors,       ONLY : gstart
>   USE smooth_grid_dimensions,   ONLY : nnrsx
>   USE control_flags,            ONLY : iprsta
37a39,40
>   USE grid_dimensions,          ONLY : nr1, nr2, nr3
>   USE smallbox_grid_dimensions, ONLY : nnrbx
43,44c46,47
<   USE mp_global,                ONLY : nproc_bgrp, me_bgrp, root_bgrp, intra_bgrp_comm
<   USE fft_interfaces,           ONLY : invfft
---
>   USE mp_global,                ONLY : nproc_image, me_image, root_image, intra_image_comm
>   USE cp_interfaces,            ONLY : invfft
91c94
< #if defined (__MPI)
---
> #if defined (__PARA)
93c96
<   INTEGER :: proc, ntot, ncol, mc, ngpwpp(nproc_bgrp)
---
>   INTEGER :: proc, ntot, ncol, mc, ngpwpp(nproc_image)
106c109
<   me = me_bgrp + 1
---
>   me = me_image + 1
133c136
< #if defined (__MPI)
---
> #if defined (__PARA)
137,138c140,141
<   ALLOCATE( ns( nproc_bgrp ) )
<   ns = nbsp / nproc_bgrp
---
>   ALLOCATE( ns( nproc_image ) )
>   ns = nbsp / nproc_image
140c143
<      IF( (j-1) < MOD( nbsp, nproc_bgrp ) ) ns( j ) = ns( j ) + 1 
---
>      IF( (j-1) < MOD( nbsp, nproc_image ) ) ns( j ) = ns( j ) + 1 
142,143c145,146
<   IF( iverbosity > 3) THEN
<      DO j=1,nproc_bgrp
---
>   IF(iprsta.GT.4) THEN
>      DO j=1,nproc_image
151c154
<   DO proc=1,nproc_bgrp
---
>   DO proc=1,nproc_image
154c157
<      IF( iverbosity > 3) THEN
---
>      IF(iprsta.GT.4) THEN
165c168
<   IF( iverbosity > 3) THEN
---
>   IF(iprsta.GT.4) THEN
179c182
<   CALL redistwf( c, psitot, ngpwpp, ns, intra_bgrp_comm, 1 )
---
>   CALL redistwf( c, psitot, ngpwpp, ns, intra_image_comm, 1 )
190c193
< #if defined (__MPI)
---
> #if defined (__PARA)
239c242
<      IF( iverbosity > 3) THEN
---
>      IF(iprsta.GT.4) THEN
252c255
<      CALL redistwf( c_p, psitot_pl, ngpwpp, ns, intra_bgrp_comm, -1 )
---
>      CALL redistwf( c_p, psitot_pl, ngpwpp, ns, intra_image_comm, -1 )
255c258
<      CALL redistwf( c_m, psitot_mi, ngpwpp, ns, intra_bgrp_comm, -1 )
---
>      CALL redistwf( c_m, psitot_mi, ngpwpp, ns, intra_image_comm, -1 )
310c313
<      ALLOCATE( qv( dfftb%nnr ) )
---
>      ALLOCATE( qv( nnrbx ) )
321c324
<               qv( 1 : dfftb%nnr ) = 0.D0 
---
>               qv( 1 : nnrbx ) = 0.D0 
326c329
< #ifdef __MPI
---
> #ifdef __PARA
334,335c337,338
< #ifdef __MPI
<               CALL mp_sum( qvt, intra_bgrp_comm )
---
> #ifdef __PARA
>               CALL mp_sum( qvt, intra_image_comm )
365c368
<                  qv( 1:dfftb%nnr ) = 0.D0
---
>                  qv( 1:nnrbx ) = 0.D0
374,375c377,378
< #ifdef __MPI
<                  CALL mp_sum( qvt, intra_bgrp_comm )
---
> #ifdef __PARA
>                  CALL mp_sum( qvt, intra_image_comm )
413c416
<      t1=omega/DBLE(dfftp%nr1*dfftp%nr2*dfftp%nr3)
---
>      t1=omega/DBLE(nr1*nr2*nr3)
421c424
<      IF( iverbosity > 3) THEN
---
>      IF(iprsta.GT.4) THEN
440c443
<         CALL mp_sum ( X, intra_bgrp_comm )
---
>         CALL mp_sum ( X, intra_image_comm )
444c447
<         IF( iverbosity > 3) THEN
---
>         IF(iprsta.GT.4) THEN
468,469c471,472
< #ifdef __MPI
<         CALL mp_sum ( Xsp, intra_bgrp_comm )
---
> #ifdef __PARA
>         CALL mp_sum ( Xsp, intra_image_comm )
495,496c498,499
< #ifdef __MPI
<         CALL mp_sum ( Xsp, intra_bgrp_comm )
---
> #ifdef __PARA
>         CALL mp_sum ( Xsp, intra_image_comm )
510c513
< #ifdef __MPI
---
> #ifdef __PARA
532,534c535,537
<         WRITE(38, *) at(:,1)*alat
<         WRITE(38, *) at(:,2)*alat
<         WRITE(38, *) at(:,3)*alat
---
>         WRITE(38, *) a1
>         WRITE(38, *) a2
>         WRITE(38, *) a3
562c565
<               CALL ddyn_u(nbsp,O,Uall) ! Lingzhu Kong
---
>               CALL ddyn_u(nbsp,O,Uall,b1,b2,b3)
569c572
<         IF( iverbosity > 3) THEN
---
>         IF(iprsta.GT.4) THEN
582c585
<              CALL ddyn_u(nupdwn(1), Ospin, Uspin) ! Lingzhu Kong
---
>              CALL ddyn_u(nupdwn(1), Ospin, Uspin,b1,b2,b3)
605c608
<               CALL ddyn_u(nupdwn(2), Ospin, Uspin) ! Lingzhu Kong
---
>               CALL ddyn_u(nupdwn(2), Ospin, Uspin,b1,b2,b3)
631c634
<   IF( iverbosity > 3) THEN
---
>   IF(iprsta.GT.4) THEN
638c641
<   IF( iverbosity > 3) THEN
---
>   IF(iprsta.GT.4) THEN
727c730
< #if defined (__MPI)
---
> #if defined (__PARA)
764c767
<   USE constants,        ONLY : tpi, bohr_radius_angs
---
>   USE constants,        ONLY : tpi, autoaf => BOHR_RADIUS_ANGS
766,767c769,770
<   USE control_flags,    ONLY : iverbosity
<   USE mp_global,        ONLY : me_bgrp
---
>   USE control_flags,    ONLY : iprsta
>   USE mp_global,        ONLY : me_image
796c799
<   me = me_bgrp + 1
---
>   me = me_image + 1
811d813
< 
846c848
<            WRITE(*,*) "MLWF Generated at Step",ini ! Lingzhu Kong
---
>            WRITE(*,*) "MLWF Generated at Step",ini
848c850
<         IF( iverbosity > 3) THEN
---
>         IF(iprsta.GT.4) THEN
953c955
<            WRITE(*,*) "MLWF Not generated after",ini,"Steps." ! Lingzhu Kong
---
>            WRITE(*,*)  "MLWF Not generated after",ini,"Steps." 
955c957
<         IF( iverbosity > 3) THEN
---
>         IF(iprsta.GT.4) THEN
969c971
< !  IF(me.EQ.1) THEN ! Lingzhu Kong
---
>   IF(me.EQ.1) THEN
972c974
< !  END IF ! Lingzhu Kong
---
>   END IF
977c979
<      sp = (alat*bohr_radius_angs/tpi)**2*SUM(mt*weight)
---
>      sp = (alat*autoaf/tpi)**2*SUM(mt*weight)
1000c1002
<   IF( iverbosity > 3) THEN
---
>   IF(iprsta.GT.4) THEN
1006c1008
<   IF( iverbosity > 3) THEN
---
>   IF(iprsta.GT.4) THEN
1018c1020
<   USE gvect, ONLY : g, mill, gstart
---
>   USE reciprocal_vectors, ONLY : gx, mill_l, gstart
1024c1026
<   USE uspp_param,         ONLY : nvb
---
>   USE cvan,               ONLY : nvb
1026c1028
<   USE mp_global,          ONLY : nproc_bgrp, me_bgrp, intra_bgrp_comm, root_bgrp
---
>   USE mp_global,          ONLY : nproc_image, me_image, intra_image_comm, root_image
1034,1036c1036,1038
< #ifdef __MPI
<   INTEGER :: ntot, proc, ierr, i,j,inw,ngppp(nproc_bgrp)
<   INTEGER :: ii,ig,displs(nproc_bgrp)
---
> #ifdef __PARA
>   INTEGER :: ntot, proc, ierr, i,j,inw,ngppp(nproc_image)
>   INTEGER :: ii,ig,displs(nproc_image)
1050,1051c1052
< 
<   me = me_bgrp + 1
---
>   me = me_image + 1
1053c1054
<   IF ( nbsp < nproc_bgrp ) &
---
>   IF ( nbsp < nproc_image ) &
1062,1067c1063,1068
<      gnx(1,i)=g(1,i)
<      gnx(2,i)=g(2,i)
<      gnx(3,i)=g(3,i)
<      gnn(1,i)=mill(1,i)
<      gnn(2,i)=mill(2,i)
<      gnn(3,i)=mill(3,i)
---
>      gnx(1,i)=gx(1,i)
>      gnx(2,i)=gx(2,i)
>      gnx(3,i)=gx(3,i)
>      gnn(1,i)=mill_l(1,i)
>      gnn(2,i)=mill_l(2,i)
>      gnn(3,i)=mill_l(3,i)
1070c1071
< #ifdef __MPI
---
> #ifdef __PARA
1073c1074
<   DO i=1,nproc_bgrp
---
>   DO i=1,nproc_image
1077c1078
<   CALL mp_set_displs( ngppp, displs, ntot, nproc_bgrp )
---
>   CALL mp_set_displs( ngppp, displs, ntot, nproc_image )
1079c1080
<   IF(me.EQ.1) THEN
---
> ! IF(me.EQ.1) THEN    !Lingzhu Kong
1082,1087c1083
<   ELSE
<      ! NOTE: collected array should be allocated anyway 
<      ! with the right first dimensions, otherwise mp_gather will fail
<      ALLOCATE(bigg(3,1))
<      ALLOCATE(bign(3,1))
<   END IF
---
> ! END IF    !Lingzhu Kong
1131,1132c1127
< 
< #ifdef __MPI
---
> #ifdef __PARA
1134c1129
<   CALL mp_barrier( intra_bgrp_comm )
---
>   CALL mp_barrier( intra_image_comm )
1136c1131
<   CALL mp_gather( gnx, bigg, ngppp, displs, root_bgrp, intra_bgrp_comm )
---
>   CALL mp_gather( gnx, bigg, ngppp, displs, root_image, intra_image_comm )
1138c1133
<   CALL mp_barrier( intra_bgrp_comm )
---
>   CALL mp_barrier( intra_image_comm )
1140c1135
<   CALL mp_gather( gnn, bign, ngppp, displs, root_bgrp, intra_bgrp_comm )
---
>   CALL mp_gather( gnn, bign, ngppp, displs, root_image, intra_image_comm )
1146c1141
< #ifdef __MPI
---
> #ifdef __PARA
1152c1147
<            WRITE(21,*) g(1,ii), g(2,ii), g(3,ii)
---
>            WRITE(21,*) gx(1,ii), gx(2,ii), gx(3,ii)
1172a1168
>                  !             if(err1.lt.vt.and.err2.lt.vt.and.err3.lt.vt) then
1173a1170,1171
>                  !  write (6,*) "Found +", ig,ii,inw, ti,tj,tk
>                  !  write (6,*) "looking for", ti,tj,tk
1214c1212
< #ifdef __MPI
---
> #ifdef __PARA
1232d1229
<                     !              if(err1.lt.vt.and.err2.lt.vt.and.err3.lt.vt) then
1236,1237d1232
<                        !                write (6,*) "Found +", ig,ii,inw 
<                        !               write (6,*) "looking for", -ti,-tj,-tk
1297c1292
< #ifdef __MPI
---
> #ifdef __PARA
1303c1298
< #ifdef __MPI
---
> #ifdef __PARA
1305c1300
<   CALL mp_barrier( intra_bgrp_comm )
---
>   CALL mp_barrier( intra_image_comm )
1307,1310c1302,1305
<   CALL mp_bcast( indexplus,  root_bgrp, intra_bgrp_comm )
<   CALL mp_bcast( indexminus, root_bgrp, intra_bgrp_comm )
<   CALL mp_bcast( tag,        root_bgrp, intra_bgrp_comm )
<   CALL mp_bcast( tagp,       root_bgrp, intra_bgrp_comm )
---
>   CALL mp_bcast( indexplus,  root_image, intra_image_comm )
>   CALL mp_bcast( indexminus, root_image, intra_image_comm )
>   CALL mp_bcast( tag,        root_image, intra_image_comm )
>   CALL mp_bcast( tagp,       root_image, intra_image_comm )
1311a1307
> ! IF (me.EQ.1) THEN              !Lingzhu Kong
1313,1316c1309,1312
<   DEALLOCATE(bigg)
<   DEALLOCATE(bign)
< #ifdef __MPI
< 
---
>      DEALLOCATE(bigg)
>      DEALLOCATE(bign)
> #ifdef __PARA
> ! END IF              !Lingzhu Kong
1328a1325,1326
>   USE smooth_grid_dimensions, ONLY : nnrsx, nr1s, nr2s, nr3s, &
>                                      nr1sx, nr2sx, nr3sx
1330c1328
<   USE mp_global,              ONLY : me_bgrp
---
>   USE mp_global,              ONLY : me_image
1335c1333
<   INTEGER :: ir1, ir2, ir3, ibig3, me, nr1s, nr2s, nr3s, nr1sx, nr2sx, nr3sx
---
>   INTEGER :: ir1, ir2, ir3, ibig3, me
1337c1335,1339
<   me = me_bgrp + 1
---
>   me = me_image + 1
>   !
>   ALLOCATE(xdist(nnrsx))
>   ALLOCATE(ydist(nnrsx))
>   ALLOCATE(zdist(nnrsx))
1339,1348d1340
<   ALLOCATE(xdist(dffts%nnr))
<   ALLOCATE(ydist(dffts%nnr))
<   ALLOCATE(zdist(dffts%nnr))
<   !
<   nr1s = dffts%nr1
<   nr2s = dffts%nr2
<   nr1sx = dffts%nr1x
<   nr2sx = dffts%nr2x
<   nr3sx = dffts%nr3x
<   nr3s = dffts%nr3
1350c1342
< #ifdef __MPI
---
> #ifdef __PARA
1367c1359
< #ifdef __MPI
---
> #ifdef __PARA
1923a1916
>   USE grid_dimensions,        ONLY : nr1, nr2, nr3, nr1x, nr2x, nr3x, nnrx
1925c1918
<   USE mp_global,              ONLY : me_bgrp
---
>   USE mp_global,              ONLY : me_image
1935c1928
<   me = me_bgrp + 1
---
>   me = me_image + 1
1937c1930
<   ALLOCATE(expo(dfftp%nnr,nw1))
---
>   ALLOCATE(expo(nnrx,nw1))
1943,1944c1936,1937
<      DO ir3=1,dfftp%nr3
< #ifdef __MPI
---
>      DO ir3=1,nr3
> #ifdef __PARA
1950,1955c1943,1948
<            DO ir2=1,dfftp%nr2
<               DO ir1=1,dfftp%nr1
<                  x =  (((ir1-1)/DBLE(dfftp%nr1x))*i_1(inw) +                          &
<                       &                  ((ir2-1)/DBLE(dfftp%nr2x))*j_1(inw) +             &
<                       &                  ((ir3-1)/DBLE(dfftp%nr3x))*k_1(inw))*0.5d0*fpi
<                  expo(ir1+(ir2-1)*dfftp%nr1x+(ibig3-1)*dfftp%nr1x*dfftp%nr2x,inw) = CMPLX(COS(x), -SIN(x),kind=DP)
---
>            DO ir2=1,nr2
>               DO ir1=1,nr1
>                  x =  (((ir1-1)/DBLE(nr1x))*i_1(inw) +                          &
>                       &                  ((ir2-1)/DBLE(nr2x))*j_1(inw) +             &
>                       &                  ((ir3-1)/DBLE(nr3x))*k_1(inw))*0.5d0*fpi
>                  expo(ir1+(ir2-1)*nr1x+(ibig3-1)*nr1x*nr2x,inw) = CMPLX(COS(x), -SIN(x),kind=DP)
1958c1951
< #ifdef __MPI
---
> #ifdef __PARA
1977,1979c1970,1975
<   USE kinds,           ONLY : DP
<   USE fft_base,        ONLY : dfftp, dfftb
<   USE mp_global,       ONLY : me_bgrp
---
>   USE kinds,                    ONLY : DP
>   USE grid_dimensions,          ONLY : nnrx, nr1, nr2, nr3, nr1x, nr2x, nr3x
>   USE smallbox_grid_dimensions, ONLY : nnrbx, nr1b, nr2b, nr3b, &
>                                        nr1bx, nr2bx, nr3bx
>   USE fft_base,                 ONLY : dfftp
>   USE mp_global,                ONLY : me_image
1984c1980
<   COMPLEX(DP), INTENT(IN):: qv(dfftb%nnr), vr(dfftp%nnr)
---
>   COMPLEX(DP), INTENT(IN):: qv(nnrbx), vr(nnrx)
1989c1985
<   me = me_bgrp + 1
---
>   me = me_image + 1
1993c1989
<   DO ir3=1,dfftb%nr3
---
>   DO ir3=1,nr3b
1995,1996c1991,1992
<      ibig3=1+MOD(ibig3-1,dfftp%nr3)
< #ifdef __MPI
---
>      ibig3=1+MOD(ibig3-1,nr3)
> #ifdef __PARA
2000c1996
<         DO ir2=1,dfftb%nr2
---
>         DO ir2=1,nr2b
2002,2003c1998,1999
<            ibig2=1+MOD(ibig2-1,dfftp%nr2)
<            DO ir1=1,dfftb%nr1
---
>            ibig2=1+MOD(ibig2-1,nr2)
>            DO ir1=1,nr1b
2005,2007c2001,2003
<               ibig1=1+MOD(ibig1-1,dfftp%nr1)
<               ibig=ibig1 + (ibig2-1)*dfftp%nr1x + (ibig3-1)*dfftp%nr1x*dfftp%nr2x
<               ir  =ir1 + (ir2-1)*dfftb%nr1x + (ir3-1)*dfftb%nr1x*dfftb%nr2x
---
>               ibig1=1+MOD(ibig1-1,nr1)
>               ibig=ibig1 + (ibig2-1)*nr1x + (ibig3-1)*nr1x*nr2x
>               ir  =ir1 + (ir2-1)*nr1bx + (ir3-1)*nr1bx*nr2bx
2011c2007
< #ifdef __MPI
---
> #ifdef __PARA
2026,2027c2022,2023
<   USE gvect,              ONLY : ngm
<   USE gvect, ONLY : g
---
>   USE gvecp,              ONLY : ngm
>   USE reciprocal_vectors, ONLY : gx, mill_l
2030c2026
<   USE mp_global,          ONLY : nproc_bgrp, me_bgrp, root_bgrp, intra_bgrp_comm
---
>   USE mp_global,          ONLY : nproc_image, me_image, root_image, intra_image_comm
2041,2042c2037,2038
< #ifdef __MPI
<   INTEGER proc, ierr, ngdens(nproc_bgrp), displs(nproc_bgrp)
---
> #ifdef __PARA
>   INTEGER proc, ierr, ngdens(nproc_image), displs(nproc_image)
2047c2043
<   me = me_bgrp + 1
---
>   me = me_image + 1
2052,2054c2048,2050
<      gnx(1,i)=g(1,i)
<      gnx(2,i)=g(2,i)
<      gnx(3,i)=g(3,i)
---
>      gnx(1,i)=gx(1,i)
>      gnx(2,i)=gx(2,i)
>      gnx(3,i)=gx(3,i)
2057c2053
< #ifdef __MPI
---
> #ifdef __PARA
2059c2055
<   DO i=1,nproc_bgrp
---
>   DO i=1,nproc_image
2063c2059
<   CALL mp_set_displs( ngdens, displs, ntot, nproc_bgrp )
---
>   CALL mp_set_displs( ngdens, displs, ntot, nproc_image )
2069c2065
<   CALL mp_barrier(intra_bgrp_comm)
---
>   CALL mp_barrier(intra_image_comm)
2071c2067
<   CALL mp_gather( gnx, bigg, ngdens, displs,  root_bgrp, intra_bgrp_comm )
---
>   CALL mp_gather( gnx, bigg, ngdens, displs,  root_image, intra_image_comm )
2081c2077
<      CALL mp_barrier(intra_bgrp_comm)
---
>      CALL mp_barrier(intra_image_comm)
2083c2079
<      CALL mp_gather( rhotmp_g, bigrho, ngdens, displs,  root_bgrp, intra_bgrp_comm )
---
>      CALL mp_gather( rhotmp_g, bigrho, ngdens, displs,  root_image, intra_image_comm )
2153,2154c2149,2150
<   USE gvect, ONLY : g
<   USE gvect,              ONLY : ngm
---
>   USE reciprocal_vectors, ONLY : gx
>   USE gvecp,              ONLY : ngm
2158c2154
<   USE cell_base,          ONLY : at, alat, tpiba, omega
---
>   USE cell_base,          ONLY : a1, a2, a3, tpiba, omega
2163c2159
<   USE mp_global,          ONLY : nproc_bgrp, me_bgrp, root_bgrp, intra_bgrp_comm
---
>   USE mp_global,          ONLY : nproc_image, me_image, root_image, intra_image_comm
2174,2175c2170,2171
< #ifdef __MPI
<   INTEGER proc, ierr, ngdens(nproc_bgrp), displs( nproc_bgrp )
---
> #ifdef __PARA
>   INTEGER proc, ierr, ngdens(nproc_image), displs( nproc_image )
2185c2181
<   me = me_bgrp + 1
---
>   me = me_image + 1
2190,2192c2186,2188
<      gnx(1,i)=g(1,i)
<      gnx(2,i)=g(2,i)
<      gnx(3,i)=g(3,i)
---
>      gnx(1,i)=gx(1,i)
>      gnx(2,i)=gx(2,i)
>      gnx(3,i)=gx(3,i)
2195c2191
< #ifdef __MPI
---
> #ifdef __PARA
2197c2193
<   DO i=1,nproc_bgrp
---
>   DO i=1,nproc_image
2201c2197
<   CALL mp_set_displs( ngdens, displs, ntot, nproc_bgrp )
---
>   CALL mp_set_displs( ngdens, displs, ntot, nproc_image )
2213,2214c2209,2210
< #ifdef __MPI
<   CALL mp_barrier( intra_bgrp_comm )
---
> #ifdef __PARA
>   CALL mp_barrier( intra_image_comm )
2216c2212
<   CALL mp_gather( gnx, bigg, ngdens, displs, root_bgrp,intra_bgrp_comm )
---
>   CALL mp_gather( gnx, bigg, ngdens, displs, root_image,intra_image_comm )
2218c2214
<   CALL mp_bcast( bigg, root_bgrp, intra_bgrp_comm )
---
>   CALL mp_bcast( bigg, root_image, intra_image_comm )
2224c2220
<   CALL mp_barrier( intra_bgrp_comm )
---
>   CALL mp_barrier( intra_image_comm )
2226c2222
<   CALL mp_gather( rhotmp_g, bigrho, ngdens, displs, root_bgrp,intra_bgrp_comm )
---
>   CALL mp_gather( rhotmp_g, bigrho, ngdens, displs, root_image,intra_image_comm )
2230c2226
<   CALL mp_bcast( bigrho, root_bgrp, intra_bgrp_comm )
---
>   CALL mp_bcast( bigrho, root_image, intra_image_comm )
2252,2254c2248,2250
<   a_direct(1,1:3)=at(1:3,1)*alat
<   a_direct(2,1:3)=at(1:3,2)*alat
<   a_direct(3,1:3)=at(1:3,3)*alat
---
>   a_direct(1,1:3)=a1(1:3)
>   a_direct(2,1:3)=a2(1:3)
>   a_direct(3,1:3)=a3(1:3)
2281,2284c2277,2280
<   IF(zdir.EQ.1) zlen=DSQRT(at(1,1)**2+at(2,1)**2+at(3,1)**2)
<   IF(zdir.EQ.2) zlen=DSQRT(at(1,2)**2+at(2,2)**2+at(3,2)**2)
<   IF(zdir.EQ.3) zlen=DSQRT(at(1,3)**2+at(2,3)**2+at(3,3)**2)
<   zlen = zlen*alat
---
>   IF(zdir.EQ.1) zlen=DSQRT(a1(1)**2+a1(2)**2+a1(3)**2)
>   IF(zdir.EQ.2) zlen=DSQRT(a2(1)**2+a2(2)**2+a2(3)**2)
>   IF(zdir.EQ.3) zlen=DSQRT(a3(1)**2+a3(2)**2+a3(3)**2)
> 
2437c2433
<   USE control_flags,          ONLY : iverbosity
---
>   USE control_flags,          ONLY : iprsta
2439,2440c2435,2437
<   USE constants,              ONLY : tpi, bohr_radius_angs
<   USE mp_global,              ONLY : me_bgrp
---
>   USE constants,              ONLY : tpi, autoaf => BOHR_RADIUS_ANGS
>   USE smooth_grid_dimensions, ONLY : nr1s, nr2s, nr3s
>   USE mp_global,              ONLY : me_image
2472c2469
<   me = me_bgrp + 1
---
>   me = me_image + 1
2516c2513
<            WRITE(*,*) "MLWF Generated at Step",k ! Lingzhu Kong
---
>            WRITE(*, *) "MLWF Generated at Step",k
2518c2515
<         IF( iverbosity > 3 ) THEN
---
>         IF(iprsta.GT.4) THEN
2737c2734
<            WRITE(*,*) "MLWF Not generated after",k,"Steps." ! Lingzhu Kong
---
>            WRITE(*, *) "MLWF Not generated after",k,"Steps."
2739c2736
<         IF( iverbosity > 3 ) THEN
---
>         IF(iprsta.GT.4) THEN
2762c2759
<      sp = (alat*bohr_radius_angs/tpi)**2*SUM(mt*weight)
---
>      sp = (alat*autoaf/tpi)**2*SUM(mt*weight)
2803c2800
<   USE mp_global,              ONLY : nproc_bgrp, me_bgrp, root_bgrp, intra_bgrp_comm
---
>   USE mp_global,              ONLY : nproc_image, me_image, root_image, intra_image_comm
2810,2811c2807,2808
<   INTEGER ::i, ig, proc, ntot, ngpwpp(nproc_bgrp)
<   INTEGER ::displs(nproc_bgrp)
---
>   INTEGER ::i, ig, proc, ntot, ngpwpp(nproc_image)
>   INTEGER ::displs(nproc_image)
2814c2811
< #if defined (__MPI)
---
> #if defined (__PARA)
2816c2813
<   DO proc=1,nproc_bgrp
---
>   DO proc=1,nproc_image
2820c2817
<   CALL mp_set_displs( ngpwpp, displs, ntot, nproc_bgrp )
---
>   CALL mp_set_displs( ngpwpp, displs, ntot, nproc_image )
2824c2821
<   IF ( me_bgrp == root_bgrp ) THEN
---
>   IF ( me_image == root_image ) THEN
2832c2829
<   CALL mp_barrier( intra_bgrp_comm )
---
>   CALL mp_barrier( intra_image_comm )
2834c2831
<   CALL mp_gather( c(:,jw), psitot, ngpwpp, displs, root_bgrp, intra_bgrp_comm )
---
>   CALL mp_gather( c(:,jw), psitot, ngpwpp, displs, root_image, intra_image_comm )
2838c2835
<   IF( me_bgrp == root_bgrp ) THEN
---
>   IF( me_image == root_image ) THEN
2868a2866
>   USE control_flags,          ONLY : iprsta
2871c2869,2870
<   USE mp_global,              ONLY : me_bgrp
---
>   USE smooth_grid_dimensions, ONLY : nr1s, nr2s, nr3s
>   USE mp_global,              ONLY : me_image
2887a2887
>   REAL(DP), PARAMETER :: autoaf=0.529177d0
2906c2906
<   me = me_bgrp + 1
---
>   me = me_image + 1
3073d3072
< !==============================================================================
3075d3073
<     SUBROUTINE ddyn_u(nbsp, O, U)
3077,3078c3075
< ! input: the overlap matrix O
< ! ouput: the unitary transformation matrix U
---
>     SUBROUTINE ddyn_u(m, Omat, Umat,b1,b2,b3)
3080,3088c3077,3142
<        USE kinds,            ONLY : DP
<        USE wannier_base,     ONLY : wf_friction, nsteps, tolw, adapt, wf_q, weight, nw, wfdt
<        USE cell_base,        ONLY : alat
<        USE constants,        ONLY : tpi, autoaf => BOHR_RADIUS_ANGS
<        USE mp_global,        ONLY : nproc_image, me_image, intra_image_comm
<        USE cp_main_variables, ONLY: descla
<        USE cp_interfaces,     ONLY: distribute_lambda, collect_lambda
<        USE printout_base,     ONLY : printout_base_open, printout_base_unit, printout_base_close
<        USE parallel_include
---
>     USE kinds,            ONLY : DP
>     USE io_global,        ONLY : stdout
>     USE wannier_base,     ONLY : wf_friction, nsteps, tolw, adapt, wf_q, &
>                                weight, nw, wfdt
>     USE cell_base,        ONLY : alat
>     USE constants,        ONLY : tpi, autoaf => BOHR_RADIUS_ANGS
>     USE electrons_base,   ONLY : nbsp
>     USE control_flags,    ONLY : iprsta
>     USE mp_global,        ONLY : me_image
>     USE printout_base,    ONLY : printout_base_open, printout_base_unit, &
>                                  printout_base_close
>     USE parallel_include
> 
>     IMPLICIT NONE
> 
>     INTEGER ::  i ,j, inw,k
>     REAL(DP) :: t0, fric, t2, oldt0,fric1
>     REAL(DP) :: spread,sp
>     INTEGER :: nmax, iter
>     REAL(DP) :: eps, diff
>     INTEGER  :: me, iunit,ini
> 
> 
>     INTEGER ,INTENT(in) :: m
>     REAL(DP), INTENT(in) :: b1(3),b2(3),b3(3)
>     REAL(DP), INTENT(inout) :: Umat(m,m)
>     COMPLEX(DP), INTENT(inout) :: Omat(nw,m,m)
> 
>     REAL(DP), ALLOCATABLE,DIMENSION(:,:) :: identy,Uminus, Uplus,Uo,temp,temp1, U1,W,lambda, X2,X3,Y2,Y3
>     COMPLEX(DP), ALLOCATABLE, DIMENSION(:, :, :) :: Oc,temp2,A
>     REAL(DP) , ALLOCATABLE , DIMENSION(:) :: mt
> 
> ALLOCATE(Oc(nw,m,m))
> ALLOCATE(A(nw,m,m))
> ALLOCATE(  U1(m,m) )
> ALLOCATE(  Uplus(m,m))
> ALLOCATE(  Uo(m,m)  )
> ALLOCATE(  Uminus(m,m))
> ALLOCATE(  temp(m,m))
> ALLOCATE(  W(m,m)  )
> ALLOCATE( lambda(m,m))
> ALLOCATE(mt(nw))
> ALLOCATE(temp1(m,m))
> ALLOCATE(temp2(nw,m,m))
> ALLOCATE(identy(m,m))
> ALLOCATE(X2(m,m))
> ALLOCATE(X3(m,m))
> ALLOCATE(Y2(m,m))
> ALLOCATE(Y3(m,m))
> me = me_image + 1
> eps=1.0E-13_DP
> nmax=20
> A=Omat
> fric=wf_friction
>            Umat=0.D0
>           DO i=1,m
>            Umat(i,i)=1.D0
>           END DO
> Oc=Omat
> identy=Umat
>   oldt0=0.D0
>   Uo=Umat! Uo set like this?
>   Uminus=Uo
>   temp1=Umat
>   temp=Uminus
>   temp2=A
3090,3098c3144,3180
<        IMPLICIT NONE
<    
<        INTEGER ,      INTENT(in)    :: nbsp
<        REAL(DP),      INTENT(out)   :: U(nbsp,nbsp)
<        COMPLEX(DP),   INTENT(inout) :: O(nw,nbsp,nbsp)
<    
<        INTEGER                      :: ista(0:nproc_image-1),iend(0:nproc_image-1)
<        REAL(DP),    ALLOCATABLE,  DIMENSION(:,:) :: identy,Um,Up,U0,Ul,W,X2,X3,tmpr2,tmpi2, tmpr,tmpi
<        COMPLEX(DP), ALLOCATABLE,  DIMENSION(:, :, :) :: Oc, Ocold, Ol
---
> CALL start_clock('ddyn_2') 
>   DO ini=1, nsteps
> CALL start_clock('ddyn_3.1')
>      t0=0.D0     !use t0 to store the value of omega
>      DO inw=1, nw
>         DO i=1, m
>            t0=t0+DBLE(CONJG(Oc(inw, i, i))*Oc(inw, i, i))
>         END DO
>      END DO
>      IF(ABS(t0-oldt0).LT.tolw) THEN
> 	     IF(me.EQ.1) THEN
> 	     WRITE(*,*) "MLWF Generated at Step",ini
> 	     END IF
>              IF(iprsta.GT.4) THEN
>                WRITE( stdout, * ) "MLWF Generated at Step",ini
>             END IF
> 
>  GO TO 241
>      END IF
> 
>        IF(oldt0 .GT. t0)THEN
>        fric=fric/2.D0
>         Uo=identy
>         Uminus=identy	
>       END IF      
>       IF(oldt0 .LT. t0)THEN  
>         !  Uo=Uminus
>         !   Uminus=temp
>     
>         Uo=identy
>         Uminus=identy         
>    END IF
>  !   calculate d(omega)/dUo and store result in W
>  !   this is the force for the damped dynamics
> ! A
> !B1, B2 ,B3 COMPLEX, all 3D nw*m*m
> !=========================================================================
3100,3101c3182,3200
<        INTEGER  ::  i, j, inw, nmax, iter, iunit,ini, nr, nc, ir, ic, ierr, nlam
<        REAL(DP) :: t0, myt0, fric, t2(nw), mt(nw), oldt0,fric1,spread,sp, eps, wfdt2, fricp, fricm
---
>     A=temp2
> !=============================================================    
> W=0.D0
>  DO  inw=1, nw
>          t2=weight(inw)
>             DO j=1,m
>             DO i=1,m
>       W(i,j)=W(i,j)+2.D0*t2*REAL((A(inw,i,j)+A(inw,j,i))*CONJG(Oc(inw,j,j)) )
>             END DO
>             END DO    
>    END DO    
> 
> Uplus=0.D0
> fric1=fric/(2.d0*wfdt)
>       DO j=1,m
>         DO i=1,m
>  Uplus(i,j)=(2*Uo(i,j)-(1-fric1)*Uminus(i,j)+wfdt*wfdt*W(i,j)/wf_q)/(1+fric1)
>         END DO
>      END DO
3103,3153c3202,3207
<        nlam = 1
<        IF( SIZE( descla ) < 2 ) THEN
<           IF( descla(1)%active_node > 0 ) &
<              nlam = descla(1)%nrcx
<        ELSE
<           IF( ( descla(1)%active_node > 0 ) .OR. ( descla(2)%active_node > 0 ) ) &
<              nlam = MAX( descla(1)%nrcx, descla(2)%nrcx )
<        END IF
<    
<        ALLOCATE(Oc(nbsp,nbsp, nw), Ocold(nbsp,nbsp,nw), Ol(nlam,nlam,nw))
<        ALLOCATE(Up(nlam,nlam), U0(nlam,nlam), Um(nlam,nlam), Ul(nlam,nlam),  X2(nbsp,nbsp), X3(nbsp,nbsp))
<        ALLOCATE(W(nlam,nlam), identy(nlam,nlam))
<        ALLOCATE(tmpr(nlam,nlam), tmpi(nlam,nlam), tmpr2(nlam,nlam), tmpi2(nlam,nlam))
< 
<        IF(me_image.EQ.0) THEN
<           iunit = printout_base_unit( "spr" )
<           CALL printout_base_open( "spr" )
<        END IF
< 
<        eps=1.0E-13_DP
<        nmax=50
<        fric=wf_friction
<        oldt0=0.D0
<       
<        nr = descla(1)%nr
<        nc = descla(1)%nc
<        ir = descla(1)%ir
<        ic = descla(1)%ic
< 
<        do inw = 1, nw
<           X2(:,:) =  REAL(O(inw, :, :))
<           X3(:,:) = AIMAG(O(inw, :, :))
<      
<           call distribute_lambda(X2, tmpr, descla(1))
<           call distribute_lambda(X3, tmpi, descla(1))
<       
<           Oc(:,:,inw) = DCMPLX(X2,X3)
<           Ol(:,:,inw) = DCMPLX(tmpr,tmpi)
<        enddo
<       
<        Ocold = Oc
<       
<        X2=0.D0
<        DO i=1,nbsp
<           X2(i,i)=1.D0
<        END DO
<        call distribute_lambda(X2, identy, descla(1))
<     
<        Ul = identy
<     
<        call para_range(1, nbsp, nproc_image, ista, iend)
---
> ! eps and nmax fixed value
> ! iter: number of iteration to reach orthogonality
> !output: Uplus
> CALL start_clock('ortho_u')
> CALL ortho_u(Uplus,Uo,m,lambda,diff,eps,nmax)
> CALL stop_clock('ortho_u')
3155,3160c3209,3211
<        DO inw = 1,nw
<           t2(inw) = 2.D0 * weight(inw)
<        ENDDO
<     
<        U0 = identy            
<        Up = identy            
---
>      temp=Uminus
>      Uminus=Uo
>      Uo=Uplus
3162,3202c3213,3235
<        DO ini=1, nsteps
<     
<           Um = identy 
<           U0 = identy 
<    
<           fric1 = fric/(2*wfdt)  
<           wfdt2 = wfdt*wfdt/(wf_q*(1+fric1))
<           fricp = 2.d0/(1+fric1)
<           fricm = (1-fric1)/(1+fric1)
<     
<           DO j = 1, nc
<              DO i = 1, nr
<                 W(i,j) = 0.D0
<                 DO inw = 1, nw
<                    W(i,j) = W(i,j) + &
<                    t2(inw)*REAL((Ocold(i+ir-1,j+ic-1,inw)+Ocold(j+ic-1,i+ir-1,inw))*CONJG(Oc(j+ic-1,j+ic-1,inw)) )
<                 ENDDO
<                 Up(i,j)=fricp*U0(i,j)-fricm*Um(i,j)+wfdt2*W(i,j)   
<              END DO
<           END DO
<     
<           CALL ortho_u(Up,U0,nlam,identy,eps,nmax,nbsp)  
<           CALL sqr_mm_cannon( 'N', 'N', nbsp, 1.0d0, Ul, nlam, Up, nlam, 0.0d0, tmpr, nlam, descla(1))  
<           Ul = tmpr
< 
<           Ocold = Oc
<           DO inw = 1, nw
<              tmpr(:,:)=REAL(Ol(:,:,inw))
<              tmpi(:,:)=AIMAG(Ol(:,:,inw))
<    
<              CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, Ul, nlam, tmpr, nlam, 0.0d0, tmpr2, nlam, descla(1)) 
<              CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, Ul, nlam, tmpi, nlam, 0.0d0, tmpi2, nlam, descla(1)) 
<              CALL sqr_mm_cannon( 'N', 'N', nbsp, 1.0d0, tmpr2, nlam, Ul, nlam, 0.0d0, tmpr, nlam, descla(1)) 
<              CALL sqr_mm_cannon( 'N', 'N', nbsp, 1.0d0, tmpi2, nlam, Ul, nlam, 0.0d0, tmpi, nlam, descla(1)) 
<    
<              call collect_lambda(X2, tmpr, descla(1) )
<              call collect_lambda(X3, tmpi, descla(1))
<    
<              Oc(:,:,inw)=CMPLX(X2,X3)
<           ENDDO
<    
---
>      temp1=Umat
>      U1=0.D0
>      CALL DGEMM ('N', 'N', m,m,m,1.d0,Umat,m,Uo,m,0.d0,U1,m) !U1=Umat*U
>      
>      Umat=U1
>  !   update Oc
>      
>      temp2=Oc
>   X2=0.d0
>     X3=0.d0
>      DO inw=1,nw
>      X2(:,:)=REAL(Omat(inw,:,:))
>      X3(:,:)=AIMAG(Omat(inw,:,:))
>        CALL DGEMM ('T', 'N', m,m,m,1.d0,Umat,m,X2,m,0.d0,Y2,m)
>          CALL DGEMM ('T', 'N', m,m,m,1.d0,Umat,m,X3,m,0.d0,Y3,m)
>  X2=0.d0
>  X3=0.d0
>    CALL DGEMM ('N','N',m,m,m,1.d0,Y2,m,Umat,m,0.d0,X2,m)
>      CALL DGEMM ('N','N',m,m,m,1.d0,Y3,m,Umat,m,0.d0,X3,m)
>      Oc(inw,:,:)=CMPLX(X2,X3)
>   X2=0.D0
>   X3=0.D0
>   END DO
3203a3237
>     IF(ABS(t0-oldt0).GE.tolw.AND.ini.GE.nsteps) THEN
3205,3225c3239,3245
<        myt0=0.D0
<        DO i = ista(me_image), iend(me_image)
< !      DO i = 1, nbsp
<           DO inw=1, nw
<              myt0=myt0+DBLE(CONJG(Oc( i, i, inw))*Oc( i, i, inw))
<           END DO
<        END DO
< #ifdef __MPI
<        CALL mpi_allreduce (myt0, t0, 1, MPI_DOUBLE_PRECISION, MPI_SUM, &
<                            intra_image_comm, ierr)
< #endif
< !      t0 = myt0
<        if(mod(ini,10) == 0)print *, 'spread at ', ini, ' = ', t0
<        IF(ABS(t0-oldt0).LT.tolw) THEN
<          WRITE(*,*) "MLWF Generated at Step",ini
<          exit
<        ELSEIF(ini.GE.nsteps) THEN
<          WRITE(*,*) "MLWF Not generated after",ini,"Steps."
<        END IF
< 
<        IF(oldt0 .GT. t0) fric=fric/2.D0
---
> IF(me.EQ.1) THEN
>      WRITE(*,*) "MLWF Not generated after",ini,"Steps."
>      END IF
>           GO TO 241
>          END IF
>       oldt0=t0
>    END DO !cycl for nsteps
3227c3247
<        oldt0=t0
---
> 241 continue 
3229c3249
<      END DO !cycl for nsteps
---
> CALL stop_clock('ddyn_2')
3231,3233c3251,3257
<      spread=0.0d0
<      DO i=1, nbsp
<         mt=1.D0-DBLE(Oc(i,i,:)*CONJG(Oc(i,i,:)))
---
> spread=0.0d0
>      IF(me.EQ.1) THEN
>          iunit = printout_base_unit( "spr" )
>       CALL printout_base_open( "spr" )
>       END IF
>          DO i=1, m
>         mt=1.D0-DBLE(Oc(:,i,i)*CONJG(Oc(:,i,i)))
3235,3253c3259,3279
<         IF(me_image.EQ.0) WRITE(iunit, '(f10.7)') sp
<         print *, 'sp = ',i, sp
<         IF ( sp < 0.D0 ) &
<            CALL errore( 'cp-wf', 'Something wrong WF Spread negative', 1 )  
<         spread=spread+sp
<      END DO
< 
<      IF(me_image.EQ.0) CALL printout_base_close( "spr" )
< 
<      spread=spread/nbsp
<      IF(me_image.EQ.0) write(*,*) "Average spread = ", spread
< 
<      call collect_lambda(U,Ul,descla(1))
< 
<      do inw = 1, nw
<         O(inw,:,:) = Oc(:,:,inw)
<      enddo
< 
<      DEALLOCATE(tmpr,tmpi,tmpr2,tmpi2,identy,Oc,Ocold,Up,U0,Um,W,Ol, Ul, X2, X3)
---
>           IF(me.EQ.1) THEN
>               WRITE(iunit, '(f10.7)') sp
>           END IF
> 
> 	  IF ( sp < 0.D0 ) &
> 	        CALL errore( 'cp-wf', 'Something wrong WF Spread negative', 1 )  
> 	  spread=spread+sp
>      END DO
>          IF(me.EQ.1) THEN
>             CALL printout_base_close( "spr" )
>          END IF
>      spread=spread/m
>      IF(me.EQ.1) THEN
> 	          write(*,*) "Average spread = ", spread
> 	  END IF
>      IF(iprsta.GT.4) THEN
>       WRITE( stdout, * ) "Average spread = ", spread
>      END IF
> Omat=Oc
>     DEALLOCATE(Y2,Y3,X2,X3,identy,temp2,temp1,Oc,A,U1,Uplus,Uo,Uminus,temp,W,lambda,mt)
> RETURN
3255,3256c3281
<      RETURN
<      END SUBROUTINE ddyn_u
---
> END SUBROUTINE ddyn_u
3260c3285
<       SUBROUTINE  ortho_u(up,u0,nlam,identy,eps,nmax,nbsp)
---
> SUBROUTINE  ortho_u(up,u0,m,lambda_u,diff,eps,nmax)
3268,3313c3293,3391
<       USE kinds,            ONLY : DP
<       USE mp_global,        ONLY : me_image, intra_image_comm
<       USE mp,               ONLY : mp_max
<       USE cp_main_variables,       ONLY  : descla
<  
<       IMPLICIT NONE
< 
<       INTEGER, INTENT(IN)    :: nlam, nmax, nbsp
<       REAL(DP),INTENT(INOUT) :: up(nlam,nlam)
<       REAL(DP),INTENT(IN)    :: u0(nlam,nlam), identy(nlam,nlam),eps
<       REAL(DP) :: delta
<       INTEGER  :: i,j,iter, nc, nr
< 
<       REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: xloc,tmp, tmp2, tmp2t, amat, bmat
<       ALLOCATE( xloc(nlam,nlam))
<       ALLOCATE( tmp(nlam,nlam),tmp2(nlam,nlam),tmp2t(nlam,nlam) )
<       ALLOCATE( amat(nlam,nlam),bmat(nlam,nlam))
< 
<       nr = descla(1)%nr
<       nc = descla(1)%nc
< 
<       CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, up, nlam, up, nlam, 0.0d0, amat, nlam, descla(1))
<       CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, up, nlam, u0, nlam, 0.0d0, bmat, nlam, descla(1))
< 
<       amat = identy-amat
<       bmat = identy-bmat
<       xloc = 0.5d0*amat
< 
<       delta = 1.0E10_DP
<       DO iter = 1,nmax
< 
<          CALL sqr_mm_cannon( 'N', 'N', nbsp, 1.0d0, bmat, nlam, xloc, nlam, 0.0d0, tmp2, nlam, descla(1))
<          CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, xloc, nlam, xloc, nlam, 0.0d0, tmp, nlam, descla(1))
< 
<          CALL sqr_tr_cannon( nbsp, tmp2, nlam, tmp2t, nlam, descla(1) )
< 
<          do j=1,nc
<             do i=1,nr
<                xloc(i,j)=0.5d0*(amat(i,j) + tmp2(i,j) + tmp2t(i,j) - tmp(i,j) )
<             end do
<          end do
< 
<          IF(iter .GE. 3) THEN
< 
<             tmp = up         ! upnew = up + u0*xloc
<             CALL sqr_mm_cannon( 'N', 'N', nbsp, 1.0d0, u0, nlam, xloc, nlam, 1.0d0, tmp, nlam, descla(1))
---
>   USE kinds,            ONLY : DP
>   USE control_flags,    ONLY : iprsta
>   USE io_global,        ONLY : stdout
>   USE mp_global,        ONLY :  me_image                                                                                                
>  IMPLICIT NONE
>                                                                                                   
>   INTEGER, INTENT(IN) :: m , nmax
>   REAL(DP),INTENT(INOUT) :: up(m,m),diff,lambda_u(m,m),eps
>   REAL(DP),INTENT(IN) :: u0(m,m)
>   REAL(DP) :: umax, utmp, umix, diff_old, delta
>   INTEGER  :: i,j,k,iter
>                                                                                          
>   REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: uptemp,upt, xloc, tmp1, tmp2,tmp3,dd, xdiff,amat, bmat
> 	                                                                                        
> 	  ALLOCATE( upt(m,m) )
> 	  ALLOCATE( xloc(m,m))
> 	  ALLOCATE(tmp1(m,m))
> 	  ALLOCATE(tmp2(m,m))
> 	  ALLOCATE(tmp3(m,m))
> 	  ALLOCATE(dd(m,m)  )
> 	  ALLOCATE(xdiff(m,m))
> 	  ALLOCATE(amat(m,m))
> 	  ALLOCATE(bmat(m,m))
> 	  ALLOCATE(uptemp(m,m))
> 	  !     amat = up^t up
> 	  !     bmat = up^t u0
> 	  upt=TRANSPOSE(up)
> 	  CALL DGEMM ('N', 'N', m,m,m,1.d0,upt,m,up,m,0,amat,m)
> 	  CALL DGEMM ('N', 'N', m,m,m,1.d0,upt,m,u0,m,0,bmat,m)
>           if(iprsta.gt.4) then
>              write(6,*)
>                  write(6,'(26x,a)') '    amat '
>               do i=1,m
>                   write(6,'(7f11.6)') (amat(i,j),j=1,m)
>                  end do
>             write(6,*)
>                  write(6,'(26x,a)') '    bmat '
>            do i=1,m
>                  write(6,'(7f11.6)') (bmat(i,j),j=1,m)
>                 end do
>        endif
> 
>        
>        dd=0.d0
>        tmp1=0.d0
> !
>              do i=1,m
>              tmp1(i,i)=1.d0
>              end do
>                                                                                                   
>              do j=1,m
>              do i=1,m
>                 xloc(i,j) = 0.5d0*(tmp1(i,j)-amat(i,j))
>              end do
>              end do
>       !                calculation of lagranges multipliers
>    uptemp=up
>    eps=1.0E-13
> !To save computation time, only call get_delta after 3 iteration
>        
>    call start_clock('ortho_iter')
>     DO  iter=1,nmax
>      call start_clock('getdelta')            
> !   IF(iter .GE. 3) THEN
>           CALL get_delta(delta,uptemp,m)
> !   END IF
>    call stop_clock('getdelta')   
>           IF(eps .LT. delta) THEN
>                       tmp2=0.d0
>                       dd=0.d0
>                       CALL DGEMM ('N', 'N', m,m,m,1.D0,bmat,m,xloc,m,0,tmp2,m)
>                       CALL DGEMM ('T', 'N', m,m,m,1.D0,xloc,m,xloc,m,0,dd,m)
>                             tmp3=0.d0
>                             do j=1,m
>                             do i=1,m
>                      xdiff(i,j)=0.5d0*(tmp1(i,j)-amat(i,j)-tmp2(i,j)-tmp2(j,i)-dd(i,j))
>                                tmp3(i,j)=0.5d0*(xloc(i,j)+xloc(j,i))+xdiff(i,j)
>                            end do
>                            end do
>                      xloc=tmp3 
>   IF(iter .GE. 2) THEN                                                   
>                    tmp3=0.d0
>                    CALL DGEMM ('N', 'N', m,m,m,1.D0,u0,m,xloc,m,0,tmp3,m)
>                    uptemp=up
>                do j=1,m
>                do i=1,m
>                     uptemp(j,i)=uptemp(j,i)+tmp3(j,i)
>                  end do
>                  end do
>    END IF
>            ELSE
>                  up=uptemp    
>                  go to 20
>             END IF
>                                                                                             
>                   END DO
>  20 continue
>  call stop_clock('ortho_iter') 
>   diff=0.d0
3315,3320c3393,3422
<             tmp2 = identy
<             CALL sqr_mm_cannon( 'T', 'N', nbsp, 1.0d0, tmp, nlam, tmp, nlam, -1.0d0, tmp2, nlam, descla(1))
<             delta = 0.d0
<             do j=1,nc
<             do i=1,nr
<                delta=max(delta,abs(tmp2(i,j)) )
---
>   
> DEALLOCATE(uptemp,upt, xloc, tmp1, tmp2,tmp3,dd, xdiff,amat, bmat)
>  return
>                                                                                              
>    END SUBROUTINE ortho_u
> 
> 
>     SUBROUTINE get_delta(umax,up,m)
> 
>      USE kinds,            ONLY : DP
>       implicit none
>       INTEGER ,INTENT(in) :: m
>       REAL(DP),INTENT(inout) :: umax
>       REAL(DP), INTENT(in) :: up(m,m)
>       REAL(DP),ALLOCATABLE,DIMENSION(:,:) :: ups
>       integer :: i,j,k
>       real(DP) :: utmp
>     ALLOCATE(ups(m,m))
>       umax=0.0
>        CALL DGEMM ('T', 'N', m,m,m,1.d0,up,m,up,m,0.d0,ups,m)
>      do j=1,m
>      do i=1,m
>           utmp=0.0
>                     if (i.eq.j) then
>                      utmp=abs(ups(i,j)-1.0)
>                      umax=max(umax,utmp)
>                  else
>                  utmp=abs(ups(i,j))
>             umax=max(umax,utmp)
>             end if
3323,3345c3425,3427
<             CALL mp_max( delta, intra_image_comm )
<             IF( delta .le. eps ) exit
<          ENDIF
< 
<       ENDDO
< 
<       up = tmp
<       DEALLOCATE(xloc, amat, bmat, tmp, tmp2, tmp2t)
<       return
<     
<       END SUBROUTINE ortho_u
< 
<       SUBROUTINE para_range(n1, n2, nprocs, ista, iend)
<       INTEGER n1,n2,nprocs,ista(0:nprocs-1),iend(0:nprocs-1)
<       INTEGER iwork1,iwork2
< 
<       iwork1 = (n2 - n1 + 1) / nprocs
<       iwork2 = MOD(n2 - n1 + 1, nprocs)
<       do irank = 0,nprocs-1
<          ista(irank) = irank * iwork1 + n1 + MIN(irank, iwork2)
<          iend(irank) = ista(irank) + iwork1 - 1
<          IF (iwork2 > irank) iend(irank) = iend(irank) + 1
<       enddo
---
>     DEALLOCATE(ups)
>      return
>  END SUBROUTINE get_delta
3347,3348d3428
<       return
<       end
Only in ../../../ffn2_tsvdw_master/CPV: wf.F90
Only in ../../../ffn2_tsvdw_master/CPV: wf.o
